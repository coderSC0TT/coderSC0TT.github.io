<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库内核01</title>
      <link href="/2023/09/04/cmu15445-01/"/>
      <url>/2023/09/04/cmu15445-01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>爆肝 爆肝 爆肝</p>]]></content>
      
      
      <categories>
          
          <category> oceanbase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02 IN BETWEEN</title>
      <link href="/2023/09/04/SQL%E9%80%9F%E9%80%9A-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-02/"/>
      <url>/2023/09/04/SQL%E9%80%9F%E9%80%9A-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>IN让我们的代码简洁<br>WHERE state &#x3D;’VA’ OR state&#x3D;’VB’ OR state&#x3D;’VC’<br>可以直接写成 WHERE state in (‘VA’,’VB’,’VC’)</p><p>BETWEEN让我们的代码简洁 可以比较同一属性的范围数值<br>WHERE points &gt;&#x3D;1000 AND points &lt;&#x3D;2000<br>-&gt;<br>WHERE points BETWEEN 1000 AND 2000</p>]]></content>
      
      
      <categories>
          
          <category> sql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01 SELECT WHERE AND OR NOT</title>
      <link href="/2023/09/03/SQL%E9%80%9F%E9%80%9A-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-01select-where/"/>
      <url>/2023/09/03/SQL%E9%80%9F%E9%80%9A-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-01select-where/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>DBMS 数据库管理系统 用来管理数据库<br>关系型数据库中数据存储在利用关系互相链接的表中<br>用SQL来查询 修改数据</p><p>USE sql_store; 用的哪个文件夹<br>SELECT *获取列 *代表返回全部列<br>From customers<br>– WHERE customers_id &#x3D;1  WHERE筛选 – 是注释<br>OPENED BY  first_name 按名字排列</p><p>关于SELECT<br>…<br>SELECT<br>     last_name,<br>     first_name,<br>     points,<br>     (points+10)*100 AS discount_fact   关于AS 可以给列别名 想要带空格就加双引号<br>…</p><p>SELECT DISTINCT state<br>DISTINCT 关键字可以去重</p><p>关于WHERE<br>WHERE 进行筛选<br>USE sql_store;<br>SELECT *<br>From customers<br>WHERE points&gt;1000 AND points &lt;2000 筛选已选列中满足要求的<br>也可以 WHERE NOT (points&gt;1000 AND points &lt;2000)</p>]]></content>
      
      
      <categories>
          
          <category> sql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>权限管控</title>
      <link href="/2023/09/02/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-10%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7/"/>
      <url>/2023/09/02/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-10%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ls -l 可以用列表的形式查看内容 并显示权限细节<br>依次为 文件&#x2F;文件夹权限控制信息 文件&#x2F;文件夹所属用户 文件&#x2F;文件夹所属用户组<br>权限细节一共十个槽位</p><p>1的位置-是文件 d文件夹 l软链接<br>234是所属用户权限 567是所属用户组权限 剩下的是其它用户权限<br>即u-user<br>g-group<br>o-other<br>r read 查看<br>w 修改<br>x 作为程序执行</p><p>chmod [-R] 权限 文件或文件夹<br>-R 针对文件夹 对文件夹内的全部内容应用同样操作<br>例:chmod u&#x3D;rwx,g&#x3D;r,o&#x3D;x test.txt</p><p>chown [-R] [用户] [:] [用户组] 文件或文件夹<br>只有root用户可执行</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>grep wc和管道符</title>
      <link href="/2023/09/01/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-06grep-wc-%E7%AE%A1%E9%81%93%E7%AC%A6/"/>
      <url>/2023/09/01/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-06grep-wc-%E7%AE%A1%E9%81%93%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>grep从文件中通过关键字过滤文件行<br>grep [-n] 关键字 文件路径<br>-n表示显示匹配到的行号<br>如 grep -n a test1.txt</p><p>wc命令统计文件的行数 单词数量等<br>wc [-c -m -l -w] 文件路径<br>-c bytes数量 -m统计字符数量 -l统计行数 -w统计单词数量</p><p>管道符 | 将管道符左边命令的结果作为右边命令的输入<br>只要能产生输出的内容的命令都可以和管道符结合使用<br>如 cat text.txt | wc -l </p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>echo tail 重定向符</title>
      <link href="/2023/09/01/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-07echo-tail-%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%A6/"/>
      <url>/2023/09/01/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-07echo-tail-%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>echo 内容 在命令行显示内容<br>&#96;&#96;飘号中的内容会作为命令执行<br>如输出pwd的内容 echo <code>pwd</code></p><p>tail [-f -num] 文件路径<br>-f表示持续跟着<br>-num表示查看尾部多少行 默认十行</p><p>重定向符</p><blockquote><p>将左侧的命令覆盖写入符号右侧的指定内容中</p><blockquote><p>将左侧的命令追加写入符号右侧的指定文件中<br>echo “wtf” &gt;&#x2F;&gt;&gt; test.txt<br>也可以ls&gt;test.txt </p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vim编译器</title>
      <link href="/2023/09/01/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-08vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2023/09/01/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-08vim%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>命令模式  所敲按键编辑器都理解为命令 驱动执行不同的功能 不能自由进行文本编辑<br>输入模式 自由编辑<br>底线命令模式 以:开始 通常用于文件的保存 退出<br>vim&#x2F;vi 文件路径<br>如果文件路径表示的文件不存在 用于编辑新文件 如果存在 用于编辑已有文件<br>一开始进入是命令模式 命令模式才可以切换到输入模式或者底线命令模式<br>命令模式到输入模式按i esc退出<br>命令模式到底线命令按:进入底线命令模式 wq保存退出</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>root用户 用户组</title>
      <link href="/2023/09/01/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-09root%E7%94%A8%E6%88%B7/"/>
      <url>/2023/09/01/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-09root%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>root用户为超级管理员 拥有最大的系统操作权限<br>su - 用户名 切换用户 默认表示切换到root用户 exit退出</p><p>sudo +其它命令 即可为这个命令临时赋予root授权</p><p>Linux中可配置多个linux用户以及用户组<br>(管理必须有root权限)<br>创建用户组 groupadd 用户组名<br>删除用户组 groupdel 用户组名</p><p>创建用户 useradd [-g -d] 用户名<br>无-g默认创建同名用户组并自动加入  有-g加入已有的同名组<br>-d指定用户home路径 默认是&#x2F;home&#x2F;用户名</p><p>例1:useradd test 会创建一个叫test的用户 并加入一个叫test的用户组 其默认home路径在home下</p><p>例2:useradd test2 -g test -d &#x2F;home&#x2F;test22<br>test2加入用户组test 其home路径在home&#x2F;test22下</p><p>删除用户 userdel [-r] 用户名<br>-r把用户目录也删了</p><p>id 用户名<br>查看用户信息 0</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux前置内容</title>
      <link href="/2023/08/31/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-01%E5%88%9D%E8%AF%86linux/"/>
      <url>/2023/08/31/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-01%E5%88%9D%E8%AF%86linux/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.操作系统作为软件的一种 是用户和计算机硬件的桥梁 负责调度键盘文字输入 调度显示器显示内容 cpu内存供给等等 等于就是给硬件安排活动<br>2.Linux由系统内核以及系统级应用程序组成 内核调度cpu 内存 文件系统等 而应用程序包含文件管理器 任务管理器等<br>3.程序调用内核 内核调度硬件<br>4.linux发行版是指内核之上封装系统级应用程序 组合在一起即Linux发行版<br>5.虚拟机是在系统中通过虚拟化软件得到虚拟化硬件 给虚拟化硬件安装真实操作系统(总不可能把自己电脑重装成linux系统吧)<br>6.命令行 效率更高更稳定<br>7.传统方式获取linux操作系统环境是安装完整虚拟机 如VMware 也可以用WSL 更加简单快捷<br>WSL是用于Windows系统之上的Linux子系统 作用是在Windows系统中获得Linux系统环境 直连硬件 无需虚拟机</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>目录结构命令基础</title>
      <link href="/2023/08/31/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-02%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/08/31/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-02%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux目录为树形结构<br>只有一个根目录&#x2F; 层次关系也用&#x2F;来表示: &#x2F;user&#x2F;local&#x2F;h.txt 开头斜杠为根目录 后面表示层级关系</p><p>Linux命令基础</p><p>command -options paramenter<br>命令本身+命令行为细节选项+命令参数(指向目标)</p><p>ls命令 ls [-a,-l,-h] [路径]<br>列出目录下的内容<br>直接输入ls命令会展示当前工作目录下的内容:默认当前登录用户的home目录为当前工作目录 指的是操作用户的个人账户目录 路径为 &#x2F;home&#x2F;用户名<br>Linux中.开头文件为隐藏文件或文件夹 -a才可以看<br>-h列出文件的大小(kb mb gb)<br>-l是按列表 竖向展示<br>可以组合使用 如ls -al   ls -a -l</p><p>cd命令(change directory) cd [路径]<br>cd无需选项 只有参数表示切换到哪个目录下<br>cd不写参数 表示回到默认的用户的home目录</p><p>pwd命令(print work directory)<br>pwd无选项无参数 直接输入 查看当前的工作目录</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>相对路径以及绝对路径</title>
      <link href="/2023/08/31/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-03%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
      <url>/2023/08/31/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-03%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>绝对路径以根目录作为起点 如 cd &#x2F;home&#x2F;users&#x2F;Desktop<br>相对路径以当前目录为起点 无需以&#x2F;开头 如 cd Desktop<br>&#x2F;home&#x2F;users&#x2F;Desktop 切换回上一级 &#x2F;home&#x2F;users 可以直接cd 也可以通过特殊路径符来完成<br>.表示当前目录 cd.&#x2F;Desktop 和 cd Desktop效果一致<br>..表示上一级目录 cd .. 表示切换到上一级目录 cd ..&#x2F;.. 切换到上二级目录<br>~表示home目录 cd ~即可切换到home目录 cd ~&#x2F;Desktop 切换到home内的Desktop目录</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基本文件操作1</title>
      <link href="/2023/08/31/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-04-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/08/31/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-04-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>mkdir (make directory) 用来创造文件夹<br>mkdir [-p] 路径<br>参数必填 相对绝对路径均可 -p可选 表示自动创建不存在的父目录 也就是有了-p 一整个链条都将创建完成</p><p>注意:创建文件夹需要修改权限 请确保操作都在home目录内</p><p>touch 路径<br>用来创建文件 参数必填 表示创建的文件路径 如 touch test.txt<br>Linux文件夹蓝色 文件白色 或者ls -l 会有标注</p><p>cat 路径<br>读取文件 直接将内容显示出来 如cat test.txt</p><p>more 路径<br>more支持翻页 如果文件内容过多 可以一页页的展示 空格翻页 q退出查看</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基本文件操作2</title>
      <link href="/2023/08/31/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-05%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/08/31/linux-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-05%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>cp [-r] 参数1 参数2<br>复制文件夹加 -r<br>参数1表示被复制的文件或文件夹<br>参数2表示被复制去的地方</p><p>mv 参数1 参数2 移动文件&#x2F;文件夹<br>若参数2不存在 则为一个改名操作</p><p>rm [-r] 参数1 参数2 … 参数N<br>-r用于删除文件夹<br>rm支持通配符* 用来模糊匹配<br><em>就是通配符 test</em>表示匹配任何以test开头的内容 *test <em>test</em>同理<br>su - root进入超级管理员模式 exit退回普通用户</p><p>我们使用的命令的本体是一个个的二进制可执行程序</p><p>which 要查找的命令  查找命令程序文件本体的位置</p><p>按文件名查找<br>find 起始路径 -name “被查找文件名”<br>按文件大小搜索<br>find 起始路径 -size +&#x2F;-n[KMG]</p><ul><li>-表示搜索大于 小于的 n是大小数字 KMG是大小单位 kb mb或gb 用小写</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博弈搜索</title>
      <link href="/2023/07/19/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88%E6%90%9C%E7%B4%A2/"/>
      <url>/2023/07/19/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MAX节点的评估下限值α:<br>假设其MIN子节点有N个 如果第一个MIN子节点评估值为α 则对于其它子节点 如果有高于α的 取最高值为该MAX节点评估值 如果没有则就是α<br>所以该MAX节点的评估值不会低于α 故称其为MAX节点的评估下限值α</p><p>MIN节点评估的上限值β:<br>假设其MAX子节点有N个 如果第一个MAX子节点评估值为β 则对于其它子节点 如果有低于β的 取最低值为该MIN节点评估值 如果没有则就是β<br>所以该MIN节点的评估值不会高于β 故称其为MIN节点的评估上限值β</p><p>α剪枝:<br>MAX节点下限为α 其所有MIN子节点中评估值β上限小于等于α的的节点其以下部分可以不搜了<br>β剪枝:<br>MIN节点的上限为β 其所有MAX子节点中α下限大于等于β的节点 其以下部分不搜了</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>urllib</title>
      <link href="/2023/07/18/%E7%88%AC%E8%99%AB-urllib%E4%BD%BF%E7%94%A8-urllib/"/>
      <url>/2023/07/18/%E7%88%AC%E8%99%AB-urllib%E4%BD%BF%E7%94%A8-urllib/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这个是自带的库</p><figure class="highlight plaintext"><figcaption><span>[] [爬虫]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>this指针</title>
      <link href="/2023/07/18/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88/"/>
      <url>/2023/07/18/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>c++中类内成员变量和成员函数分开存储<br>只有非静态成员变量才属于类的对象上<br>空对象内存大小为1个字节 区分空对象占内存的位置</p><p>每一个静态函数只会诞生一份函数实例 多个同类型的对象会共用一块代码 如何区分呢<br>this指针指向被调用的成员函数所属的对象<br>其隐含每一个非静态成员函数内 无需定义直接使用</p><p>所以当形参与成员变量同名时 可用this指针来区分<br>在类的非静态成员函数中返回对象本身 可使用return *this</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(int age)</span><br><span class="line">&#123;</span><br><span class="line">//this指向被调用的成员函数的所属对象</span><br><span class="line">//也就是谁调用的这个有参构造 就指向谁 </span><br><span class="line">this-&gt;age=age;</span><br><span class="line">&#125;</span><br><span class="line">Person&amp; PersonAddAge(Person &amp;p)//必须引用 否则调用拷贝构造函数 </span><br><span class="line">&#123;</span><br><span class="line">this-&gt;age+=p.age;</span><br><span class="line">//this指向p2的指针 *this指向的就是p2这个对象本体 </span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">//1.解决名称冲突 </span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p1(18); //this指向了p1 </span><br><span class="line">cout&lt;&lt;&quot;p1年龄为&quot;&lt;&lt;p1.age&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">//2.返回对象本身用*this</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">Person p1(10);</span><br><span class="line">Person p2(10);</span><br><span class="line">p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);</span><br><span class="line">cout&lt;&lt;&quot;p2的年龄为:&quot;&lt;&lt;p2.age&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//test01();</span><br><span class="line">test02();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空指针调用成员函数 传入指针为NULL 不能访问属性</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void showClassName()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;this is Person class&quot;&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> void showPersonAge()</span><br><span class="line"> &#123;</span><br><span class="line"> //报错原因是传入的指针为NULL</span><br><span class="line"> if(this==NULL) return;</span><br><span class="line">cout&lt;&lt;&quot;age为&quot;&lt;&lt;this-&gt;m_Age&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  int m_Age;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Person *p=NULL;</span><br><span class="line">p-&gt;showClassName();</span><br><span class="line">p-&gt;showPersonAge();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>友元</title>
      <link href="/2023/07/18/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E5%8F%8B%E5%85%83/"/>
      <url>/2023/07/18/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E5%8F%8B%E5%85%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>全局函数做友元 其实就是声明一个函数可访问私有属性</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">//全局函数做友元声明 goodgay可以访问building中私有成员 </span><br><span class="line">friend void goodGay(Building &amp;building); </span><br><span class="line">public:</span><br><span class="line">string m_settingRoom;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//全局函数</span><br><span class="line">void goodGay(Building &amp;building)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;正在访问全局变量1&quot;&lt;&lt;building.m_settingRoom&lt;&lt;endl; </span><br><span class="line">    cout&lt;&lt;&quot;正在访问全局变量2&quot;&lt;&lt;building.m_BedRoom&lt;&lt;endl;</span><br><span class="line">    //m_bedroom本来访问不了  </span><br><span class="line">&#125;</span><br><span class="line">void test01() //m_settingRoom是public 随便访问 </span><br><span class="line">&#123;</span><br><span class="line">Building building;</span><br><span class="line">goodGay(building);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类做友元 一个类能访问其它类的私有成员<br>以下代码有些复杂 因为用的是类外声明函数(加定义域)</p><p>大致就是<br>1.先声明一个Building类<br>2.写一个GoodGay类 里面声明了其构造函数 内部维护一个指针<br>3.Building类中有一个构造函数 两个属性 公有的客厅以及私有的卧室<br>4.类外写building的构造函数 初始化了客厅卧室<br>5.类外写GoodGay的构造函数<br>6.声明友元 可访问私有的卧室</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Building;</span><br><span class="line">class GoodGay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">GoodGay();</span><br><span class="line">void visit(); //参观函数访问Building中的属性 </span><br><span class="line">private:</span><br><span class="line">        Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">//声明GoodGay是本类的好朋友 可以访问 </span><br><span class="line">friend class GoodGay;</span><br><span class="line">public:</span><br><span class="line">    Building();//先声明 </span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">string m_SittingRoom; //客厅</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">string m_BedRoom;//卧室 </span><br><span class="line">     </span><br><span class="line"> &#125;;</span><br><span class="line"> //类外写成员函数 加个作用域就行了 </span><br><span class="line">Building::Building()</span><br><span class="line">&#123;</span><br><span class="line">m_SittingRoom=&quot;客厅&quot;;</span><br><span class="line">m_BedRoom=&quot;卧室&quot;; </span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">GoodGay::GoodGay()</span><br><span class="line">&#123;</span><br><span class="line">//相当于在堆区创建建筑物对象 new返回了一个指针</span><br><span class="line">building=new Building;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">void GoodGay::visit()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;好基友类正在访问1&quot;&lt;&lt;building-&gt;m_SittingRoom&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;好基友类正在访问2&quot;&lt;&lt;building-&gt;m_BedRoom&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">GoodGay gg;</span><br><span class="line">gg.visit();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成员函数做友元<br>其实就是把上文代码中visit函数前面加个friend 放Building类下</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">//声明visit函数是本类的好朋友 可以访问 </span><br><span class="line">friend void GoodGay::visit(); </span><br><span class="line">public:</span><br><span class="line">    Building();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">string m_SittingRoom; </span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">string m_BedRoom;//卧室    </span><br><span class="line"> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结 等于说就是这一个操作</p>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>const修饰成员函数</title>
      <link href="/2023/07/18/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
      <url>/2023/07/18/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//this指针的本质是指针常量 指向是不可以修改的</span><br><span class="line">//在成员函数后面加const 修饰的是this指向 让指针指向的值也不可以修改</span><br><span class="line">void showPerson() const</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_B=100;//特殊 </span><br><span class="line">//this-&gt;m_A=100; 不可修改</span><br><span class="line">//this=NULL; 不可修改 </span><br><span class="line"> &#125; </span><br><span class="line"> int m_A;</span><br><span class="line"> mutable int m_B;//特殊变量 即使在常函数中也可以修改 </span><br><span class="line">&#125;; </span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">const Person p1;//常对象</span><br><span class="line">//p.m_A=100; 报错 不可以修改</span><br><span class="line">p1.m_B=100;</span><br><span class="line"></span><br><span class="line">//常对象只能调用常函数 </span><br><span class="line">p1.showPerson(); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>类对象作为类成员</title>
      <link href="/2023/06/30/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98/"/>
      <url>/2023/06/30/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们发现先调用的是Phone的构造函数 说明类对象作为类成员 先调用类成员的构造函数<br>由先进后出的原则 类对象的析构函数也是最后调用的</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//类对象作为类成员 </span><br><span class="line"></span><br><span class="line">class Phone</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">~Phone()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Phone的析构函数的调用&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">Phone()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Phone的无参构造函数的调用&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">Phone(string pName)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Phone的有参构造函数的调用&quot;&lt;&lt;endl; </span><br><span class="line">m_PName=pName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//手机品牌名称 </span><br><span class="line">string m_PName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//有了有参构造函数 不会自动提供无参构造函数</span><br><span class="line">Person()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Person默认构造函数的调用&quot;&lt;&lt;endl; </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ~Person()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Person析构函数的调用&quot;&lt;&lt;endl; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">//Phone m_Phone=pName 其实是一个隐式构造法  刚好m_PName也是string类型 </span><br><span class="line">Person(string name,string pName)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Person有参构造函数的调用&quot;&lt;&lt;endl; </span><br><span class="line">m_Name=name;</span><br><span class="line">m_Phone= pName; </span><br><span class="line">&#125;</span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p(&quot;张三&quot;,&quot;Mate10&quot;);</span><br><span class="line">//我们发现Phone先被调用 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test01();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态成员变量以及函数</title>
      <link href="/2023/06/30/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/"/>
      <url>/2023/06/30/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>静态成员就是在成员变量和成员函数前加上关键字static 称为静态成员<br>也是有访问权限的 需要类内声明 类外初始化</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//所有对象共享同一份数据</span><br><span class="line">//编译阶段就分配内存</span><br><span class="line">//类内声明 类外初始化操作</span><br><span class="line">static int m_A; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Person::m_A=100;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p;</span><br><span class="line">cout&lt;&lt;p.m_A&lt;&lt;endl;//100</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A=200;</span><br><span class="line">cout&lt;&lt;p.m_A&lt;&lt;endl;//200</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">//静态成员变量不属于某个对象上 所有对象共享同一份数据</span><br><span class="line">//因此静态变量有两种方式访问</span><br><span class="line"></span><br><span class="line">//1.通过对象</span><br><span class="line">Person p;</span><br><span class="line">cout&lt;&lt;p.m_A&lt;&lt;endl;</span><br><span class="line">//2. 通过类名</span><br><span class="line">cout&lt;&lt;Person::m_A&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">Person::m_A=200;</span><br><span class="line">cout&lt;&lt;Person::m_A&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//test01();</span><br><span class="line">test02();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员函数</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//静态成员函数</span><br><span class="line">//所有对象共享同一个函数</span><br><span class="line">//静态成员函数只能访问静态成员变量</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public://静态函数有访问权限 </span><br><span class="line">static void func() //声明 </span><br><span class="line">&#123;</span><br><span class="line">m_A=100; //静态成员函数可以访问静态成员变量 </span><br><span class="line">//m_B=100; 无法访问 </span><br><span class="line">cout&lt;&lt;&quot;static void func的调用&quot; &lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int m_A; //类内声明 类外初始化 </span><br><span class="line"></span><br><span class="line">int m_B; </span><br><span class="line"> &#125; ;</span><br><span class="line"> </span><br><span class="line">int Person::m_A=0; </span><br><span class="line"> </span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">//1.通过对象访问</span><br><span class="line">Person p;</span><br><span class="line">p.func();</span><br><span class="line"></span><br><span class="line">//2.通过类名访问</span><br><span class="line">Person::func(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">return 0;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初始化列表赋初值</title>
      <link href="/2023/06/29/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E8%B5%8B%E5%88%9D%E5%80%BC/"/>
      <url>/2023/06/29/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E8%B5%8B%E5%88%9D%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>十分简单 知道就行</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">// 传统</span><br><span class="line">//Person(int a,int b,int c)</span><br><span class="line">//&#123;</span><br><span class="line">//m_A=a;</span><br><span class="line">//m_B=b;</span><br><span class="line">//m_C=c;</span><br><span class="line">//&#125;</span><br><span class="line">Person(int a,int b,int c):m_A(a),m_B(b),m_C(c)&#123;&#125;</span><br><span class="line"></span><br><span class="line">int m_A;</span><br><span class="line">int m_B;</span><br><span class="line">int m_C;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">//Person p(10,20,30); 传统 </span><br><span class="line">Person p(10,20,30); </span><br><span class="line">cout&lt;&lt;&quot;m_A为&quot;&lt;&lt;p.m_A&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;m_B为&quot;&lt;&lt;p.m_B&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;m_C为&quot;&lt;&lt;p.m_C&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test01();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝与浅拷贝</title>
      <link href="/2023/06/29/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2023/06/29/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如果数据开在堆上 那么浅拷贝可能出现重复释放的情况 所以我们必须学会使用深拷贝</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//深拷贝与浅拷贝 </span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Person默认构造函数的调用&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Person()  </span><br><span class="line">&#123;</span><br><span class="line">//析构代码还可以释放堆区的数据 体现作用</span><br><span class="line">if(m_Height!=NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_Height;</span><br><span class="line">m_Height=NULL;//野指针置空 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">cout&lt;&lt;&quot;Person析构函数的调用&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(int age,int height)</span><br><span class="line">&#123;</span><br><span class="line">m_Age=age; </span><br><span class="line">m_Height=new int(height);//数据开在堆上 new返回的是地址 </span><br><span class="line">cout&lt;&lt;&quot;Person有参构造函数的调用&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(const Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Person拷贝构造函数的调用&quot;&lt;&lt;endl;</span><br><span class="line">m_Age=p.m_Age;</span><br><span class="line">//m_Height=p.m_Height; 编译器默认实现的就是这行代码 </span><br><span class="line"></span><br><span class="line">//深拷贝操作 重建另一个地址 </span><br><span class="line">m_Height= new int(*p.m_Height); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int m_Age;</span><br><span class="line">int *m_Height; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p1(18,160);</span><br><span class="line">cout&lt;&lt;&quot;p1的年龄为:&quot;&lt;&lt;p1.m_Age&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;p1的身高为:&quot;&lt;&lt;*p1.m_Height&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">Person p2(p1);</span><br><span class="line">cout&lt;&lt;&quot;p2的年龄为:&quot;&lt;&lt;p2.m_Age&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;&quot;p2的身高为:&quot;&lt;&lt;*p2.m_Height&lt;&lt;endl; </span><br><span class="line">//我们没提供拷贝构造函数  但是编译器自己提供了(浅拷贝)</span><br><span class="line"></span><br><span class="line">//注意 先构造的后析构 此时浅拷贝带来的问题是堆区的重复释放</span><br><span class="line">//因为p2是完全由p1复制的 p2先释放 清空了堆区中相应数据 而p1指针不为空 二次释放 所以出错</span><br><span class="line">//可以用深拷贝来解决 让p2m_Height指向另一个地址 但是数值和p1一样  参照49行 </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test01();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对象特性</title>
      <link href="/2023/06/28/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/"/>
      <url>/2023/06/28/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>构造函数 初始化<br>析构函数 清理<br>如果你不提供 编译器会提供 但是是空实现</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//1.构造函数没有返回值 不用写void</span><br><span class="line">//函数名与类名相同</span><br><span class="line">//构造函数可以有参数 可以发生重载</span><br><span class="line">//创建对象的时候 构造函数 而且只调用一次 </span><br><span class="line">Person()</span><br><span class="line">&#123;</span><br><span class="line">//如果你不自己写 就是空的 </span><br><span class="line">cout&lt;&lt;&quot;Person构造函数的调用&quot;&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line">//2.析构函数 进行清理的操作</span><br><span class="line">//没有返回值 不写void </span><br><span class="line">//函数名与类名相同 区别是在其之前加 ~</span><br><span class="line">//不可以有参数 不能重载</span><br><span class="line">//对象在销毁前自动调用一次 </span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Person析构函数的调用&quot;;</span><br><span class="line"> &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p;//在栈上 调用结束后就释放了 会调用析构函数 </span><br><span class="line"> &#125; </span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">test01(); </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//构造函数的分类以及调用</span><br><span class="line">//分类</span><br><span class="line">//1.按照参数 无参构造(默认构造)和有参构造</span><br><span class="line">//2. 普通构造 和 拷贝构造 </span><br><span class="line">Person()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;&quot;Person无参构造函数的调用&quot;&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">Person(int a)</span><br><span class="line">&#123;</span><br><span class="line">age=a;</span><br><span class="line">cout&lt;&lt;&quot;Person有参构造函数的调用&quot;&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line">//拷贝构造函数 要加const 要引用 </span><br><span class="line">Person(const Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">//拷贝传入的人的身上的所有属性 </span><br><span class="line">age=p.age;</span><br><span class="line"> &#125; </span><br><span class="line">//2.析构函数</span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Person析构函数的调用&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> int age; </span><br><span class="line">&#125;;</span><br><span class="line">//调用 </span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">//1.括号法 首要用这个 </span><br><span class="line">Person p; //默认构造函数的调用 </span><br><span class="line">Person p2(10);//有参构造函数的调用</span><br><span class="line">Person p3(p2); //拷贝构造函数 </span><br><span class="line">//注意:调用默认构造不要加小括号 会被认为是函数 声明 </span><br><span class="line"></span><br><span class="line">//显示法 </span><br><span class="line">Person p4=Person(10);//调用有参构造</span><br><span class="line">Person p5=Person(p2); </span><br><span class="line">//注意:不要利用拷贝构造函数 初始化匿名对象 会被认为是对象声明 </span><br><span class="line">Person(10); //匿名对象 当前行执行完就无了 </span><br><span class="line"></span><br><span class="line">//隐式转换法</span><br><span class="line">Person p6=10; //Person p6=Person(10)</span><br><span class="line">Person p7=p5;//相当于构造 </span><br><span class="line"> &#125; </span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">test01(); </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝构造函数的调用时机</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//拷贝构造函数调用时期</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Person默认构造函数的调用&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Person析构函数的调用&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(int age)</span><br><span class="line">&#123;</span><br><span class="line">m_Age=age; </span><br><span class="line">cout&lt;&lt;&quot;Person有参构造函数的调用&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(const Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">m_Age=p.m_Age; </span><br><span class="line">cout&lt;&lt;&quot;Person拷贝构造函数的调用&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int m_Age; </span><br><span class="line">&#125;;</span><br><span class="line">//拷贝构造函数调用时期</span><br><span class="line">//1.使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p1(20);</span><br><span class="line">Person p2(p1);</span><br><span class="line">cout&lt;&lt;&quot;p2的年龄为&quot;&lt;&lt;p2.m_Age&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">//2.值传递的方式给函数参数传值</span><br><span class="line">void doWork(Person p)//值传递会启用拷贝函数 这个函数里面的改变不改变原p </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">Person p;</span><br><span class="line">doWork(p); </span><br><span class="line"> &#125; </span><br><span class="line">//3.值方式返回局部对象 </span><br><span class="line">Person doWork2()</span><br><span class="line">&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout&lt;&lt;(int*)&amp;p1&lt;&lt;endl;</span><br><span class="line">return p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">Person p=doWork2();</span><br><span class="line">cout&lt;&lt;(int*)&amp;p&lt;&lt;endl; //p1和p2不是同一个对象 但是devc++优化了 是一样的 </span><br><span class="line">//先创建了p1 启用了拷贝构造函数 有了p2 然后p1释放了 最后p2也释放了 </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//test01();</span><br><span class="line">//test02();</span><br><span class="line">test03(); </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认情况下c++编译器至少给一个类添加三个函数<br>1.默认构造函数(无参 函数体为空)<br>2.默认析构函数(无参 函数体为空)<br>3.默认拷贝构造函数 对属性进行值拷贝</p><p>构造函数调用规则如下<br>1.如果定义了有参构造函数 不会提供默认无参构造函数 但是会提供默认拷贝构造函数(值拷贝)<br>2.如果定义了拷贝构造函数 不会再提供其它构造函数</p>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>封装</title>
      <link href="/2023/06/27/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"/>
      <url>/2023/06/27/c-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>封装是c++面向对象的三大特性之一<br>封装的意义：<br>1.将属性和行为作为一个整体 表现生活中的事物<br>2.将属性和行为加以权限控制</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//设计一个学生类 属性有姓名和学号</span><br><span class="line">//可以给姓名和学号赋值 可以显示学生姓名以及学号 </span><br><span class="line"></span><br><span class="line">class Student </span><br><span class="line">&#123;</span><br><span class="line">//访问权限</span><br><span class="line">//公共权限</span><br><span class="line">public:</span><br><span class="line">    //属性 半径</span><br><span class="line">string m_Name;</span><br><span class="line">int m_Id;</span><br><span class="line"></span><br><span class="line">//行为 成员函数以及成员方法 </span><br><span class="line">//显示姓名以及学号 </span><br><span class="line">void showStudent()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;姓名是&quot;&lt;&lt;m_Name&lt;&lt;&quot; &quot;&lt;&lt;&quot;学号是&quot;&lt;&lt;m_Id&lt;&lt;endl; </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">//给姓名赋值</span><br><span class="line">void setN(string name,int id)</span><br><span class="line">&#123;</span><br><span class="line">m_Name=name;</span><br><span class="line">m_Id=id; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//创建具体的学生(对象) </span><br><span class="line">//实例化 </span><br><span class="line">Student s1;</span><br><span class="line">//给学生对象的属性进行赋值</span><br><span class="line">s1.setN(&quot;张三&quot;,123);</span><br><span class="line"></span><br><span class="line">s1.showStudent(); </span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种访问权限<br>公共权限 public 成员 类内类外都可以访问<br>保护权限 protected 成员 类内可以访问 类外不可以访问 儿子可以访问父亲中的保护内容<br>私有权限 private 成员 类内可以访问 类外不可以访问 儿子不可以访问父亲中的保护内容(继承知识)</p><p>struct和class唯一的区别就在于默认的访问权限不同<br>struct 默认公共<br>class 默认私有<br>成员属性设置为私有 可以自己控制读写的权限</p><p>类中可以用其余类作为成员存在</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//设置x y</span><br><span class="line">void setX(int x)</span><br><span class="line">&#123;</span><br><span class="line">m_X=x; </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> void setY(int y)</span><br><span class="line">&#123;</span><br><span class="line">m_Y=y; </span><br><span class="line"> &#125;</span><br><span class="line"> //获取x,y </span><br><span class="line"> int getX()</span><br><span class="line"> &#123;</span><br><span class="line"> return m_X; </span><br><span class="line">&#125;</span><br><span class="line">int getY()</span><br><span class="line"> &#123;</span><br><span class="line"> return m_Y; </span><br><span class="line">&#125; </span><br><span class="line">private:</span><br><span class="line">int m_X;</span><br><span class="line">int m_Y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Circle</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//设置半径</span><br><span class="line">void setR(int r)</span><br><span class="line">&#123;</span><br><span class="line"> m_R=r;</span><br><span class="line"> &#125;</span><br><span class="line"> //设置圆心 </span><br><span class="line"> void setCenter(Point center)</span><br><span class="line"> &#123;</span><br><span class="line"> m_Center=center; </span><br><span class="line"> &#125;</span><br><span class="line"> //获取圆心</span><br><span class="line"> Point getCenter()</span><br><span class="line"> &#123;</span><br><span class="line"> return m_Center;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">int m_R;</span><br><span class="line">Point m_Center;</span><br><span class="line">&#125;;</span><br><span class="line">//计算两点之间距离 平方 </span><br><span class="line">void isInCircle(Circle &amp;c,Point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">int distance=</span><br><span class="line">(c.getCenter().getX()-p.getX())*(c.getCenter().getX()-p.getX())</span><br><span class="line">+(c.getCenter().getY()-p.getY())*(c.getCenter().getY()-p.getY());</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Circle c;</span><br><span class="line">Point p;</span><br><span class="line">//略 </span><br><span class="line">return 0; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>同时还有极其重要的一点 我们可以拆分 例如头文件里写声明 源文件里写实现函数</p><p>源文件(point.h)第一行写#pragma once 防止头文件重复包含</p><p>将类复制到源文件 删到只剩声明 分号补全</p><p>源文件里#include “point.h”<br>只需要函数了<br>因为函数是成员函数 所以需要加上作用域 如类名为Point<br>void Point::setX(int x)<br>修改过后的两个文件如下(只对Point操作了)</p><p>头文件</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//设置x y</span><br><span class="line">void setX(int x);</span><br><span class="line"> </span><br><span class="line"> void setY(int y);</span><br><span class="line"> //获取x,y </span><br><span class="line"> int getX();</span><br><span class="line">int getY();</span><br><span class="line">private:</span><br><span class="line">int m_X;</span><br><span class="line">int m_Y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>源文件</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include &quot;point.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Point::setX(int x) &#123;</span><br><span class="line">m_X=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Point::setY(int y) &#123;</span><br><span class="line">m_Y=y;</span><br><span class="line">&#125;</span><br><span class="line">//获取x,y</span><br><span class="line">int Point::getX() &#123;</span><br><span class="line">return m_X;</span><br><span class="line">&#125;</span><br><span class="line">int Point::getY() &#123;</span><br><span class="line">return m_Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Circle &#123;</span><br><span class="line">public:</span><br><span class="line">//设置半径</span><br><span class="line">void setR(int r) &#123;</span><br><span class="line">m_R=r;</span><br><span class="line">&#125;</span><br><span class="line">//设置圆心</span><br><span class="line">void setCenter(Point center) &#123;</span><br><span class="line">m_Center=center;</span><br><span class="line">&#125;</span><br><span class="line">//获取圆心</span><br><span class="line">Point getCenter() &#123;</span><br><span class="line">return m_Center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">int m_R;</span><br><span class="line">Point m_Center;</span><br><span class="line">&#125;;</span><br><span class="line">//计算两点之间距离 平方</span><br><span class="line">void isInCircle(Circle &amp;c,Point &amp;p) &#123;</span><br><span class="line">int distance=</span><br><span class="line">    (c.getCenter().getX()-p.getX())*(c.getCenter().getX()-p.getX())</span><br><span class="line">    +(c.getCenter().getY()-p.getY())*(c.getCenter().getY()-p.getY());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">Circle c;</span><br><span class="line">Point p;</span><br><span class="line">//略</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数高级</title>
      <link href="/2023/06/26/c-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/"/>
      <url>/2023/06/26/c-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.函数默认参数 如果设置了默认参数 自己传了数据就用传的数据 没传就是 默认值<br>2.如果某个位置有了默认参数 那么从这个位置往后的位置也需要有默认参数<br>3.如果函数声明有默认参数 那么函数实现就不能有默认参数 声明和实现只能有一个有默认参数</p><p>占位参数<br>返回值类型 函数名(数据类型){}<br>1.使用的时候必须传入参数<br>2.占位参数可以有默认参数</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void func(int a,int)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">fun(10,10);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>函数重载<br>作用:函数名可以相同 提高复用性<br>需满足的条件<br>1.在同一个作用域下<br>2.函数名称相同<br>3.函数参数类型不同 或者个数不同 或者顺序不同</p><p>注意:函数的返回值不可以作为函数重载的条件</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func(int x)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">func();</span><br><span class="line">func(10);</span><br><span class="line">return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>引用</title>
      <link href="/2023/06/26/c-%E5%BC%95%E7%94%A8/"/>
      <url>/2023/06/26/c-%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>引用就是给变量起别名 两者地位相同<br>数据类型 &amp;别名&#x3D;原名</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=10;</span><br><span class="line">int &amp;b=a;//引用必须初始化 一旦初始化后不能发生改变 </span><br><span class="line">cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;b=&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">b=100;</span><br><span class="line">cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;b=&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请看注释 引用做参数更方便</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//值传递 </span><br><span class="line">void swap01(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">int t=b;</span><br><span class="line">b=a;</span><br><span class="line">a=t;</span><br><span class="line">&#125;</span><br><span class="line">//地址传递</span><br><span class="line">void swap02(int *a,int *b) //传入的是地址 所以需要用指针接收</span><br><span class="line">&#123;</span><br><span class="line">int t=*a;</span><br><span class="line">*a=*b;</span><br><span class="line">*b=t;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">//引用传递 </span><br><span class="line">void swap03(int &amp;a,int &amp;b) //&amp;a和&amp;b是a,b的别名 形参会修饰实参</span><br><span class="line">&#123;</span><br><span class="line">int t=a;</span><br><span class="line">a=b;</span><br><span class="line">b=t;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=10;</span><br><span class="line">int b=20;</span><br><span class="line"></span><br><span class="line">swap01(a,b);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">swap02(&amp;a,&amp;b);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">a=10;</span><br><span class="line">b=20;</span><br><span class="line">swap03(a,b);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>引用作函数的返回值<br>1.不要返回局部变量的引用 因为局部变量存放在栈区 函数结束会被释放<br>2.函数的调用可以作为左值</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int&amp; test01()</span><br><span class="line">&#123;</span><br><span class="line">static int a=10;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int &amp;ref=test01();</span><br><span class="line">cout&lt;&lt;&quot;ref=&quot;&lt;&lt;ref&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">//如果函数返回值是引用  可以作为左值 </span><br><span class="line">test01()=1000;</span><br><span class="line">cout&lt;&lt;&quot;ref=&quot;&lt;&lt;ref&lt;&lt;endl; //这个时候ref已经是a的别名 修改a等于修改ref</span><br><span class="line">return 0; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>引用的本质其实是一个指针常量 一旦初始化后就不能改变指向</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void func(int &amp;ref)</span><br><span class="line">&#123;</span><br><span class="line">ref=100; //ref是引用 转换为*ref=100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=10;</span><br><span class="line">   //自动转换为int* const ref=&amp;a</span><br><span class="line">int&amp; ref=a;</span><br><span class="line">   //发现ref是引用 转换为*ref=20</span><br><span class="line">ref=20; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量引用 用来修饰形参 防止误操作<br>const int &amp;ref&#x3D;10<br>修饰后变为只读 不能修改</p>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通讯录系统</title>
      <link href="/2023/06/25/c-%E9%80%9A%E8%AE%AF%E5%BD%95%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/06/25/c-%E9%80%9A%E8%AE%AF%E5%BD%95%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>系统需求<br>包括添加联系人<br>显示联系人<br>删除联系人<br>查找联系人<br>修改联系人<br>清空联系人<br>退出通讯录</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAX 1000</span><br><span class="line"></span><br><span class="line">//菜单页面</span><br><span class="line">void showMenu()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;**********************&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*****1.添加联系人*****&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*****2.显示联系人*****&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*****3.删除联系人*****&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*****4.查找联系人*****&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*****5.修改联系人*****&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*****6.清空联系人*****&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*****0.退出通讯录*****&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;**********************&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//联系人结构体</span><br><span class="line">struct Person</span><br><span class="line">&#123;</span><br><span class="line">string m_Name;</span><br><span class="line">int m_Sex;</span><br><span class="line">int m_Age;</span><br><span class="line">string m_Phone;</span><br><span class="line">string m_Addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//通讯录结构体</span><br><span class="line">struct Addressbooks</span><br><span class="line">&#123;</span><br><span class="line">struct Person personArray[MAX];//联系人数组</span><br><span class="line">int m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//1.添加联系人</span><br><span class="line">void addPerson(Addressbooks* abs)</span><br><span class="line">&#123;</span><br><span class="line">if (abs-&gt;m_Size == MAX)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;通讯录已满&quot; &lt;&lt; endl;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line">cout &lt;&lt; &quot;请输入姓名&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].m_Name = name;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;请输入性别&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;1 --- 男&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;2 --- 女&quot; &lt;&lt; endl;</span><br><span class="line">int sex = 0;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; sex;</span><br><span class="line">if (sex == 1 || sex == 2)</span><br><span class="line">&#123;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].m_Sex = sex;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;输入有误请重新输入&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int age = 0;</span><br><span class="line">cout &lt;&lt; &quot;请输入年龄&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; age;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].m_Age = age;</span><br><span class="line"></span><br><span class="line">string phone;</span><br><span class="line">cout &lt;&lt; &quot;请输入电话&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; phone;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].m_Phone = phone;</span><br><span class="line"></span><br><span class="line">string address;</span><br><span class="line">cout &lt;&lt; &quot;请输入家庭住址&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; address;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].m_Addr = address;</span><br><span class="line"></span><br><span class="line">//更新通讯录人数</span><br><span class="line">abs-&gt;m_Size++;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;); //请按任意键继续</span><br><span class="line">system(&quot;cls&quot;); //清屏</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//2.显示联系人</span><br><span class="line">void showPerson(Addressbooks* abs)</span><br><span class="line">&#123;</span><br><span class="line">if (abs-&gt;m_Size == 0)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;通讯录为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; abs-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; abs-&gt;personArray[i].m_Name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;性别：&quot; &lt;&lt; (abs-&gt;personArray[i].m_Sex == 1 ? &quot;男&quot; : &quot;女&quot;) &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; abs-&gt;personArray[i].m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;电话：&quot; &lt;&lt; abs-&gt;personArray[i].m_Phone &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;地址：&quot; &lt;&lt; abs-&gt;personArray[i].m_Addr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//检测联系人是否存在</span><br><span class="line">int isExist(Addressbooks* abs, string name)</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; abs-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (abs-&gt;personArray[i].m_Name == name)</span><br><span class="line">&#123;</span><br><span class="line">return i; //如果找到 输出下标</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3.删除联系人</span><br><span class="line">void deletePerson(Addressbooks* abs)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;请输入删除联系人的姓名&quot; &lt;&lt; endl;</span><br><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">int ret = isExist(abs, name);</span><br><span class="line">if (ret != -1)</span><br><span class="line">&#123;</span><br><span class="line">for (int i = ret; i &lt; abs-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">abs-&gt;personArray[i] = abs-&gt;personArray[i + 1];//数据前移</span><br><span class="line">&#125;</span><br><span class="line">abs-&gt;m_Size--;</span><br><span class="line">cout &lt;&lt; &quot;删除成功&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//4.查找联系人</span><br><span class="line">void findPerson(Addressbooks* abs)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;请输入您要查找的联系人&quot; &lt;&lt; endl;</span><br><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">int ret = (isExist(abs, name));</span><br><span class="line">if (ret != -1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; abs-&gt;personArray[ret].m_Name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;性别：&quot; &lt;&lt; (abs-&gt;personArray[ret].m_Sex == 1 ? &quot;男&quot; : &quot;女&quot;) &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; abs-&gt;personArray[ret].m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;电话：&quot; &lt;&lt; abs-&gt;personArray[ret].m_Phone &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;地址：&quot; &lt;&lt; abs-&gt;personArray[ret].m_Addr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//5.修改联系人</span><br><span class="line">void modifyPerson(Addressbooks* abs)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;请输入您要修改的联系人&quot; &lt;&lt; endl;</span><br><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">int ret = (isExist(abs, name));</span><br><span class="line">if (ret != -1)</span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line">cout &lt;&lt; &quot;请输入更改后姓名&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">abs-&gt;personArray[ret].m_Name = name;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;请输入更改后性别&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;1 --- 男&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;2 --- 女&quot; &lt;&lt; endl;</span><br><span class="line">int sex = 0;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; sex;</span><br><span class="line">if (sex == 1 || sex == 2)</span><br><span class="line">&#123;</span><br><span class="line">abs-&gt;personArray[ret].m_Sex = sex;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;输入有误请重新输入&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int age = 0;</span><br><span class="line">cout &lt;&lt; &quot;请输入更改后年龄&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; age;</span><br><span class="line">abs-&gt;personArray[ret].m_Age = age;</span><br><span class="line"></span><br><span class="line">string phone;</span><br><span class="line">cout &lt;&lt; &quot;请输入更改后电话&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; phone;</span><br><span class="line">abs-&gt;personArray[ret].m_Phone = phone;</span><br><span class="line"></span><br><span class="line">string address;</span><br><span class="line">cout &lt;&lt; &quot;请输入更改后家庭住址&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; address;</span><br><span class="line">abs-&gt;personArray[ret].m_Addr = address;</span><br><span class="line">cout &lt;&lt; &quot;修改成功&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 清空联系人</span><br><span class="line">void cleanPerson(Addressbooks* abs)</span><br><span class="line">&#123;</span><br><span class="line">abs-&gt;m_Size = 0;</span><br><span class="line">cout &lt;&lt; &quot;通讯录已清空&quot; &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Addressbooks abs;</span><br><span class="line">abs.m_Size = 0;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">int select = 0;</span><br><span class="line">showMenu();</span><br><span class="line">cin &gt;&gt; select;</span><br><span class="line">switch (select)</span><br><span class="line">&#123;</span><br><span class="line">case 1://添加联系人</span><br><span class="line">addPerson(&amp;abs);</span><br><span class="line">break;</span><br><span class="line">case 2://显示联系人</span><br><span class="line">showPerson(&amp;abs);</span><br><span class="line">break;</span><br><span class="line">case 3://删除联系人</span><br><span class="line">&#123;</span><br><span class="line">deletePerson(&amp;abs);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case 4://查找联系人</span><br><span class="line">findPerson(&amp;abs);</span><br><span class="line">break;</span><br><span class="line">case 5://修改联系人</span><br><span class="line">modifyPerson(&amp;abs);</span><br><span class="line">break;</span><br><span class="line">case 6://清空联系人</span><br><span class="line">cleanPerson(&amp;abs);</span><br><span class="line">break;</span><br><span class="line">case 0://退出联系人</span><br><span class="line">cout &lt;&lt; &quot;欢迎下次使用&quot; &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内存模型</title>
      <link href="/2023/06/25/c-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/06/25/c-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>内存分区模型</p><p>不同区域存放的数据 赋予不同的生命周期 给我们更大的灵活编程</p><p>程序运行前只有代码区以及全局区</p><p>代码区<br>存放函数体的二进制代码(cpu执行的机器指令) 由操作系统进行管理的<br>1.共享:对于频繁被执行的程序只需要在内存中有一份代码<br>2.只读：防止程序以外修改它的指令</p><p>全局区<br>存放 全局变量 静态变量(static修饰) 字符串常量 全局常量(const修饰的全局变量)<br>全局区不包括const修饰的局部变量<br>程序结束后由操作系统释放</p><p>程序运行后</p><p>栈区<br>编译器自动分配释放 存放函数参数值 局部变量 形参数据<br>不要返回局部变量的地址</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int * func()</span><br><span class="line">&#123;</span><br><span class="line">int a=10;//局部变量存放在栈区 栈区数据在函数执行完后自动释放 </span><br><span class="line">return &amp;a; //返回局部变量的地址 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int *p=func();</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;*p&lt;&lt;endl;//第一次正确 因为编译器做了保留 </span><br><span class="line">cout&lt;&lt;*p&lt;&lt;endl;//乱码 </span><br><span class="line">system(&quot;pause&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆区 程序员分配 释放 若不释放则程序结束时由操作系统回收<br>c++中主要利用new在堆区开辟</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int * func()</span><br><span class="line">&#123;</span><br><span class="line">//利用new关键字可以将数据开辟到堆区  返回地址 </span><br><span class="line">//指针的本质也是局部变量 此处其保存的地址放在栈上 指针保存的地址指向的数据是放在堆区 </span><br><span class="line">int*p=new int(10); //new返回的是该数据类型的指针(地址)</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int *p=func();</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">system(&quot;pause&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进阶基础操作<br>手动释放用delete</p><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int * func()</span><br><span class="line">&#123; </span><br><span class="line">//在堆区创建整型数据</span><br><span class="line">//new返回的是该数据类型的指针</span><br><span class="line">int *arr=new int[10];</span><br><span class="line">for(int i=0;i&lt;100;i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i]=i+100;</span><br><span class="line">&#125; </span><br><span class="line">delete[] arr; //删除数组需要加中括号 </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">int *p=func();</span><br><span class="line">cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">delete p;</span><br><span class="line">cout&lt;&lt;*p&lt;&lt;endl;//此时被释放了 乱码 </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> void test02()</span><br><span class="line">&#123;</span><br><span class="line">//创建10整型数据的数组在堆区 </span><br><span class="line">new int [10];//10代表十个元素 </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">func();</span><br><span class="line">test01();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>指针以及结构体回顾</title>
      <link href="/2023/06/24/c-%E6%8C%87%E9%92%88/"/>
      <url>/2023/06/24/c-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>指针就是地址</p><figure class="highlight plaintext"><figcaption><span>[指针] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=10; </span><br><span class="line">int *p; //定义指针</span><br><span class="line">p=&amp;a; //让指针记录变量a的地址 等于是取a的地址赋给p </span><br><span class="line"></span><br><span class="line">//使用指针</span><br><span class="line">*p=1000; //非定义时*表示解引用 找到指针指向的内存的数据</span><br><span class="line">cout&lt;&lt;&quot;*p=&quot;&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl; //此时均改为了1000 </span><br><span class="line"></span><br><span class="line">//空指针 用于给指针变量进行初始化 不可以访问 </span><br><span class="line">int *p1=NULL; </span><br><span class="line"></span><br><span class="line">    //野指针 指针变量指向非法空间 必须避免 </span><br><span class="line">int *p2=(int *)0x1100;</span><br><span class="line"></span><br><span class="line">//常量指针 const修饰指针 指针指向的值不可以改</span><br><span class="line">const int *p2=&amp;a;</span><br><span class="line"></span><br><span class="line">//指针常量 const跟在常量前 修饰常量 指针指向不可以改 </span><br><span class="line">int * const p3=&amp;a;</span><br><span class="line"></span><br><span class="line">//均不可以改</span><br><span class="line">const int * const p4=&amp;a;</span><br><span class="line"></span><br><span class="line">//指针与数组 </span><br><span class="line">int arr[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125; ;</span><br><span class="line">int *p3=arr; //arr就是数组首地址</span><br><span class="line">p3++; //指针向后偏移四个字节</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap1(int *p1,int *p2) //利用指针做函数参数可以修改实参的值 </span><br><span class="line">&#123;</span><br><span class="line">int t=*p1;</span><br><span class="line">*p1=*p2;</span><br><span class="line">*p2=t;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[结构体] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Student//创建学生数据类型 学生姓名年龄分数</span><br><span class="line">&#123;</span><br><span class="line">string name;//成员列表(属性) </span><br><span class="line">int age;</span><br><span class="line">int score;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//三种创建方式</span><br><span class="line"></span><br><span class="line">//1</span><br><span class="line">struct Student s1;</span><br><span class="line">s1.name=&quot;张三&quot;;</span><br><span class="line"></span><br><span class="line">//2</span><br><span class="line">struct Student s2=&#123;&quot;李四&quot;,10,11&#125;; </span><br><span class="line"></span><br><span class="line">//3 struct Student 后面直接创建 </span><br><span class="line"></span><br><span class="line">//创建结构体数组</span><br><span class="line">struct Student arr[2]=</span><br><span class="line">&#123;</span><br><span class="line">&#123;&quot;张三&quot;,19,100&#125;,</span><br><span class="line">&#123;&quot;李四&quot;，18，22&#125;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//赋值</span><br><span class="line">arr[1].name=&quot;王五&quot;;</span><br><span class="line">//遍历结构数组</span><br><span class="line">for(int i=0;i&lt;2;i++) cout&lt;&lt;arr[i].name&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Student s2=&#123;&quot;赵五&quot;,18,100&#125;; </span><br><span class="line"></span><br><span class="line">//指针指向结构体变量 </span><br><span class="line">student *p4 = &amp;s2;</span><br><span class="line"></span><br><span class="line">    //指针访问结构体变量中数据</span><br><span class="line">cout&lt;&lt;p4-&gt;name&lt;&lt;endl; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心</title>
      <link href="/2023/05/15/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"/>
      <url>/2023/05/15/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这道题要学一下重载运算符 思路就是如果先按右端点排序 区间有点就过<br>无点 就加点在区间右端点</p><figure class="highlight plaintext"><figcaption><span>[905区间选点] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100010;</span><br><span class="line">int n;</span><br><span class="line">struct Range</span><br><span class="line">&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">    bool operator &lt; (const Range &amp;w) const</span><br><span class="line">    &#123;</span><br><span class="line">        return r&lt;w.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        range[i]=&#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(range,range+n);</span><br><span class="line">    </span><br><span class="line">    int res=0,ed=-2e9;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(range[i].l&gt;ed)</span><br><span class="line">        &#123;</span><br><span class="line">            res++;</span><br><span class="line">            ed=range[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间分组这道题可以用求最大区间厚度的思想</p><figure class="highlight plaintext"><figcaption><span>[区间分组] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100100;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int b[2 * N], idx;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf (&quot;%d&quot;, &amp;n);</span><br><span class="line">    for(int i = 0; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        int l, r;</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;l, &amp;r);</span><br><span class="line">        b[idx ++] = l * 2;//标记左端点为偶数。</span><br><span class="line">        b[idx ++] = r * 2 + 1;// 标记右端点为奇数。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(b, b + idx);</span><br><span class="line"></span><br><span class="line">    int res = 1, t = 0;</span><br><span class="line">    for(int i = 0; i &lt; idx; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b[i] % 2 == 0) t ++;</span><br><span class="line">        else t --;</span><br><span class="line">        res = max(res, t);</span><br><span class="line">    &#125;</span><br><span class="line">    printf (&quot;%d\n&quot;, res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;1</span><br></pre></td></tr></table></figure><p>这道题的思路就是 得出每个起点小于st的区间的右端点最大值 再将其更新为st</p><figure class="highlight plaintext"><figcaption><span>[区间覆盖] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int st,ed;</span><br><span class="line">const int N=100010;</span><br><span class="line"></span><br><span class="line">struct Range</span><br><span class="line">&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">    bool operator &lt; (const Range &amp;w ) const</span><br><span class="line">    &#123;</span><br><span class="line">        return l&lt;w.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    bool f=false;</span><br><span class="line">    cin&gt;&gt;st&gt;&gt;ed;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        range[i]=&#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(range,range+n);</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++) //找每个起点在st左边的区间的右端点的最大值</span><br><span class="line">    &#123;</span><br><span class="line">        int j=i,r=-2e9;</span><br><span class="line">        while(j&lt;n &amp;&amp; range[j].l&lt;=st)</span><br><span class="line">        &#123;</span><br><span class="line">            r=max(r,range[j].r);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(r&lt;st) //如果遍历完了 右端点都比线段左端点小 说明不行</span><br><span class="line">        &#123;</span><br><span class="line">            res=-1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        res++;</span><br><span class="line">        if(r&gt;=ed)</span><br><span class="line">        &#123;</span><br><span class="line">            f=true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        st=r;</span><br><span class="line">        i=j-1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!f) cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">    else cout&lt;&lt;res&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>合并果子的思路很简单 就是每次都找最小的两个合并 用堆来维护</p><figure class="highlight plaintext"><figcaption><span>[合并果子] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>由浅入深dp2.0</title>
      <link href="/2023/04/26/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922-0/"/>
      <url>/2023/04/26/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922-0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><figcaption><span>[01背包1.0 关键代码] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int x ,int spV, int sumW)</span><br><span class="line">&#123;</span><br><span class="line">    if(x&gt;n) return 0;</span><br><span class="line">    else if(spV&lt;v[x]) return dfs(x+1,spV,sumW);</span><br><span class="line">    else if(spv&gt;=v[x])</span><br><span class="line">    &#123;</span><br><span class="line">        return max(dfs(x+1,spV,sumW),dfs(x+1,spV-v[x],sumW+w[x]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//记忆化搜索后</span><br><span class="line">int dfs(int x ,int spV) //sumW不影响边界 抹去</span><br><span class="line">&#123;</span><br><span class="line">    if(mem[x][spV]) return mem[x][spV];</span><br><span class="line">    int sum=0;</span><br><span class="line">    if(x&gt;n) sum= 0;</span><br><span class="line">    else if(spV&lt;v[x]) sum= dfs(x+1,spV,sumW);</span><br><span class="line">    else if(spv&gt;=v[x])</span><br><span class="line">    &#123;</span><br><span class="line">        sum=max(dfs(x+1,spV,sumW),dfs(x+1,spV-v[x],sumW+w[x]));</span><br><span class="line">    &#125;</span><br><span class="line">    mem[x][spV]=sum;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//递推</span><br><span class="line">for(int i=n;i&gt;=1;i--) //从底部开始</span><br><span class="line">&#123;</span><br><span class="line">    for(int j=0;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(j&lt;v[i]) f[i][j]=f[i+1][j];</span><br><span class="line">        else f[i][j]=max(f[i+1][j],f[i+1][j-v[i]]+w[i]);</span><br><span class="line">        //就是直接dfs方程复制过来</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;f[1][m]; //终点是这个 第一个物品 体积是满的</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然可以优化成一维 我们只需要注意一个问题<br>为什么二维不用倒序 一维必须倒序呢?<br>十分简单的一个道理<br>由f[i][j]&#x3D;max(f[i+1][j],f[i+1][j-v[i]]+w[i]) 此时的f[x][y]需是当前状态<br>若0-v枚举 如:i  i  i  (i-1  i-1  i-1)<br>括号内是未更新的状态</p><p>若v-0枚举则规避了这个问题</p><figure class="highlight plaintext"><figcaption><span>[洛谷1048采药(01背包一维优化)] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int t[10010],w[10010];</span><br><span class="line">int f[100];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m; //n是时间 m是数量 </span><br><span class="line">for(int i=1;i&lt;=m;i++) cin&gt;&gt;t[i]&gt;&gt;w[i];</span><br><span class="line">for(int i=m;i&gt;=1;i--)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=n;j&gt;=t[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">if(j&lt;t[i]) f[j]=f[j];</span><br><span class="line">else if(j&gt;=t[i])</span><br><span class="line">&#123;</span><br><span class="line">f[j]=max(f[j],f[j-t[i]]+w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/04/25/%E7%AE%97%E6%B3%95-stl%E5%BF%85%E4%BC%9A/"/>
      <url>/2023/04/25/%E7%AE%97%E6%B3%95-stl%E5%BF%85%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二分法究极版</title>
      <link href="/2023/04/23/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%B3%95%E7%A9%B6%E6%9E%81%E7%89%88/"/>
      <url>/2023/04/23/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%B3%95%E7%A9%B6%E6%9E%81%E7%89%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>事情的起因是 蓝桥杯的时候二分法调了半天还错了 于是我决定重新进行一个归纳与记忆<br>用记忆以及运用最好的方法</p><p>对于这种有序数组的查找 我们一般称其为二分查找<br>例如 大致几类问题<br>1.寻找大于5的第一个数的下标<br>2.寻找大于等于5的第一个数的下标<br>3.寻找大于5的最后一个数的下标…诸如此类<br>那么如何进行记忆呢<br>查找关于x的 check() 如果是对对对错型 则 mid&lt;x或mid&lt;&#x3D;x 以此来确定分界线的位置<br>如果是错错错对型 则将数组逆序存储<br>然后我们再对l r的选取进行思考<br>如果是mid&lt;4: 1 2 3 |4 4 4 4 6 8 边界即在|处 l是3 小于4的第一个数 r是4 大于等于4的第一个数<br>如果是mid&lt;&#x3D;4 1 2 3 4 4 4 4 4| 6 8 l是大于4的最后一个数<br>怎么记呢 条件&lt;4 就是在小于4的第一个数前划一竖线<br>&lt;&#x3D;4 就是在最后一个&lt;&#x3D;4的数的右边划一个竖线</p><p>若有N个数 则从下标为1开始存<br>初始化l指针为0 r指针为N+1</p><figure class="highlight plaintext"><figcaption><span>[二分查找] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int l=0,r=N+1</span><br><span class="line"> while(l+1!=r)</span><br><span class="line"> &#123;</span><br><span class="line">    int mid=(l+r)/2;</span><br><span class="line">    if(check(q[mid]))</span><br><span class="line">    &#123;</span><br><span class="line">        l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    else r=mid;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>单调有序数组的二分查找就到此为止了<br>接下来是用的最多的 二分答案 这样的题就太多了</p><p>一般分为<br>1.最小值最大类型(满足条件的答案越来越大)<br>2.最大值最小类型</p><figure class="highlight plaintext"><figcaption><span>[2440] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e5+10;</span><br><span class="line">int n,k,a[N];</span><br><span class="line">bool check(int x);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">int longest=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line">    if(a[i]&gt;=longest) longest=a[i];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int l=0,r=longest;</span><br><span class="line">while(l+1&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">int mid=(l+r)/2;</span><br><span class="line">if(check(mid)) l=mid;</span><br><span class="line">else r=mid;</span><br><span class="line">&#125;</span><br><span class="line">if(l&lt;1) cout&lt;&lt;0&lt;&lt;endl;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    if(check(r)) cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">    else cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125; </span><br><span class="line">bool check(int x)</span><br><span class="line">&#123;</span><br><span class="line">int sum=0;</span><br><span class="line">for(int j=1;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">sum+=(a[j]/x);</span><br><span class="line">&#125;</span><br><span class="line">if(sum&gt;=k) return true;</span><br><span class="line">else return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[2678] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e5+7;</span><br><span class="line">int a[N],ans;</span><br><span class="line">bool check(int x,int b[],int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">int now=0,tot=0;</span><br><span class="line">for(int j=1;j&lt;=n+1;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[j]-a[now]&lt;x) tot++;//如果距离小 这颗石头可以搬走 </span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">now=j;// 如果距离大,就跳过去  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(tot&gt;m) return false;</span><br><span class="line">else return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int L,n,m;</span><br><span class="line">cin&gt;&gt;L&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">a[n+1]=L;</span><br><span class="line">int l=1,r=L;</span><br><span class="line">while(l+1&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">int mid=(l+r)&gt;&gt;1;</span><br><span class="line">if (check(mid,a,n,m))</span><br><span class="line">&#123;</span><br><span class="line">l=mid; </span><br><span class="line">    &#125;</span><br><span class="line">else r=mid;</span><br><span class="line">&#125;</span><br><span class="line">if(check(r,a,n,m)) cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">else cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯天梯赛补题</title>
      <link href="/2023/04/23/%E7%AE%97%E6%B3%95-%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
      <url>/2023/04/23/%E7%AE%97%E6%B3%95-%E5%A4%A9%E6%A2%AF%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><figcaption><span>[分寝室] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=10000;</span><br><span class="line">int n0,n1,n;</span><br><span class="line">int a[N],b[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a1=-1,b1=-1,m=100000; </span><br><span class="line">cin&gt;&gt;n0,n1,n;</span><br><span class="line">for(int i=1;i&lt;=n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">int j=n-i;</span><br><span class="line">if(a!=i &amp;&amp; a%i=0 &amp;&amp; b%j==0 &amp;&amp; b!=j)</span><br><span class="line">&#123;</span><br><span class="line">int aa=a/i,bb=b/j;res=abs(aa-bb);</span><br><span class="line">if(mn&gt;res) a1=i,a2=j,m=res;</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">if(a1==-1 &amp;&amp; b1==-1) cout&lt;&lt;&quot;NO Solution&quot;;</span><br><span class="line">else cout&lt;&lt;a1&lt;&lt;&quot; &quot;&lt;&lt;b1;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题很可惜 没想到用dfs 还是比赛状态问题<br>事实上是很简单的 一个飞机只要最早时间在lasttime及以后 如果最早时间刚好是lasttime 就立马降落<br>否则就它自己的最早时间降落</p><figure class="highlight plaintext"><figcaption><span>[飞机降落] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int t;</span><br><span class="line">int n;</span><br><span class="line">const int N=10000;</span><br><span class="line">int a[N],b[N],c[N];</span><br><span class="line">bool st[N];</span><br><span class="line">bool flag;</span><br><span class="line"></span><br><span class="line">void dfs(int u,int lasttime)</span><br><span class="line">&#123;</span><br><span class="line">if(flag) return;</span><br><span class="line">if(u&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">flag=true;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(!st[i])</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]+b[i]&gt;=lasttime)</span><br><span class="line">&#123;</span><br><span class="line">st[i]=true;</span><br><span class="line">    if(a[i]&gt;lasttime) dfs(u+1,a[i]+c[i]);</span><br><span class="line">    else dfs(u+1,lasttime+c[i]);</span><br><span class="line">    st[i]=false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">&#125;</span><br><span class="line">memset(st,false,sizeof st);</span><br><span class="line">flag=false;</span><br><span class="line">dfs(1,0);</span><br><span class="line">if(flag) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>s.substr(i,len) 从s的第i位开始截取长度为len的串<br>s.erase(i,n) 删除从pos开始的n个字符 比如erase(0,1) 就是删除第一个字符<br>s.find(s1,n) 在s中从下标n开始查找s1 返回找到的第一个下标<br>s.find(s1,n) 在s中从下标n开始查找s1 返回找到的第一个下标<br>s.rfind(s1,n) 在s中从下标n开始向前查找s1<br>没有的话均返回-1</p><figure class="highlight plaintext"><figcaption><span>[剪贴] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=10000;</span><br><span class="line">string s,ss;</span><br><span class="line">int n;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0);</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">int cd=s.size();</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">int a,b;</span><br><span class="line">string str1,str2,str3,str4,str5;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">a-=1; b-=1;//变成下标 </span><br><span class="line">cin&gt;&gt;str1&gt;&gt;str2;</span><br><span class="line">str3=s.substr(a,b-a+1); //剪贴板内容 </span><br><span class="line">s.erase(a,b-a+1);</span><br><span class="line">int x=s.find(str1+str2);</span><br><span class="line">if(x==-1) s+=str3; //没有加后面 </span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">str5=s.substr(x+str1.size());</span><br><span class="line">s.erase(x+str1.size());</span><br><span class="line">s=s+str3+str5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[藏宝图] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">int cnt1=0;</span><br><span class="line">int cnt2=0; </span><br><span class="line">int dx[]=&#123;1,0,-1,0&#125;;</span><br><span class="line">int dy[]=&#123;0,1,0,-1&#125;;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int used[n][m];</span><br><span class="line">    int g[n][m];</span><br><span class="line">    memset(used,0,sizeof used);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%1d&quot;,&amp;g[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(g[i][j]!=0 &amp;&amp; used[i][j]==0) //如果是陆地或者宝藏且没标记过</span><br><span class="line">            &#123;</span><br><span class="line">                bool flag=0; //宝藏状态</span><br><span class="line">                used[i][j]=1;</span><br><span class="line">                if(g[i][j]&gt;=2)//有宝藏</span><br><span class="line">                &#123;</span><br><span class="line">                    flag=1;</span><br><span class="line">                &#125;</span><br><span class="line">                PII q[n*m];</span><br><span class="line">                q[0]=&#123;i,j&#125;;</span><br><span class="line">                int hh=0,tt=0;</span><br><span class="line">                while(hh&lt;=tt)</span><br><span class="line">                &#123;</span><br><span class="line">                    auto t=q[hh++];</span><br><span class="line">                    for(int k=0;k&lt;4;k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        int a=t.first+dx[k];</span><br><span class="line">                        int b=t.second+dy[k];</span><br><span class="line">                        if(a&lt;0 || a&gt;=n || b&lt;0 || b&gt;=m || g[a][b]==0 || used[a][b]==1) continue; //越界</span><br><span class="line">                        used[a][b]=1;</span><br><span class="line">                        if(g[a][b]&gt;=2) flag=1;</span><br><span class="line">                        q[++tt]=&#123;a,b&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">             </span><br><span class="line">                &#125;</span><br><span class="line">                cnt1++;</span><br><span class="line">                if(flag) cnt2++;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt1&lt;&lt;&quot; &quot;&lt;&lt;cnt2&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 补题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图论 最短路问题</title>
      <link href="/2023/04/18/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA2-0/"/>
      <url>/2023/04/18/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA2-0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>源点-起点 汇点-终点</p><p>迪杰斯特拉朴素版<br>1.初始化dist起点为0 其余点为无穷大<br>2.重复n次 每次找到未确定的离起点最短的点t 用t对其它点的距离进行更新<br>3.将点t标记为已确定</p><figure class="highlight plaintext"><figcaption><span>[迪杰斯特拉朴素版] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=520;</span><br><span class="line">int n,m,dist[N],g[N][N];</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">int dj()</span><br><span class="line">&#123;</span><br><span class="line">    memset(dist,0x3f,sizeof dist); </span><br><span class="line">    dist[1]=0; //除了起点都初始化为正无穷</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int t=-1;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!st[j] &amp;&amp;(t==-1 || dist[t]&gt;dist[j])) //找t 即dist最小值 </span><br><span class="line">            &#123;</span><br><span class="line">                t=j; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st[t]=true;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[j]=min(dist[j],dist[t]+g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(dist[n]==0x3f3f3f3f) return -1;</span><br><span class="line">    else return dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    memset(g,0x3f,sizeof g);</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        g[a][b]=min(g[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    int t=dj();</span><br><span class="line">    cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很简单 n次迭代 循环所有边 如果第n次仍松弛 说明有负权回路</p><figure class="highlight plaintext"><figcaption><span>[bellman-ford] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 510, M = 1e4 + 10;</span><br><span class="line">int n, m, k;</span><br><span class="line">int dist[N], back[N];</span><br><span class="line">struct Edge &#123;</span><br><span class="line">    int a, b, c;</span><br><span class="line">&#125; edge[M];</span><br><span class="line"></span><br><span class="line">int bellman_ford() &#123;</span><br><span class="line">    dist[1] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= k; i++) &#123;  //此处k 经过不超过k条边的最短路距离</span><br><span class="line">        memcpy(back, dist, sizeof dist);</span><br><span class="line">        for (int j = 1; j &lt;= m; j++) &#123;</span><br><span class="line">            int a = edge[j].a, b = edge[j].b, w = edge[j].c;</span><br><span class="line">            dist[b] = min(dist[b], back[a] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (dist[n] &gt;= 0x3f3f3f3f / 2) return -0x3f3f3f3f;</span><br><span class="line">    return dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        edge[i] = &#123;u, v, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(dist, 0x3f3f3f3f, sizeof dist);</span><br><span class="line">    int ans = bellman_ford();</span><br><span class="line">    if (ans == -0x3f3f3f3f) puts(&quot;impossible&quot;);</span><br><span class="line">    else printf(&quot;%d&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图论 拓扑序列 dfsbfs</title>
      <link href="/2023/04/12/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA1-0/"/>
      <url>/2023/04/12/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA1-0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>tips:树是一种特殊的图 是无环连通图</p><p>有向图边有方向 如a-&gt;b<br>无向图边没有方向 a&lt;-&gt;b<br>无向图是特殊的有向图 我们就先理解有向图的储存</p><p>1.邻接矩阵 其实就是一个二维数组 g[a][b]就存储a-&gt;b 有权重就是权重 没有就是bool值表示有无边 邻接矩阵不能有重边 只能保留一条 这个比较浪费空间</p><p>2.邻接表 就是n个节点 每个都开单链表 就跟哈希拉链法一样</p><p>每个h[i]链中表示的是连接i结点的所有结点 也就是为每一个点都开一个单链表 里面是无序的<br>所以h[i]存的是n个头结点</p><figure class="highlight plaintext"><figcaption><span>[存邻接表] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const int N=10010;</span><br><span class="line">int h[N],ne[N],e[N],st[N],idx;</span><br><span class="line"></span><br><span class="line">void add(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=b; //存编号</span><br><span class="line">    ne[idx]=h[a]; //插入 让此结点的下一结点指向之前的头结点</span><br><span class="line">    h[a]=idx; //替换头结点</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[树的重心(dfs用法)] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1001000;</span><br><span class="line">bool st[N]; //存有没有遍历过</span><br><span class="line"></span><br><span class="line">int h[N],e[N],ne[N]; </span><br><span class="line">int n;</span><br><span class="line">int ans=N;</span><br><span class="line">int idx=0;</span><br><span class="line"></span><br><span class="line">void add(int a, int b) </span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=b; </span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx; </span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    st[u]=true;</span><br><span class="line">    int sum=1; //当前子树大小为1 因为包含当前这个点</span><br><span class="line">    int res=0; //删掉点后每一个连通块的最大值</span><br><span class="line">    for(int i=h[u];i!=-1;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        int j=e[i]; </span><br><span class="line">        if(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            int s=dfs(j); //当前子树的子树大小</span><br><span class="line">            res=max(res,s); //子树的子树也是一部分</span><br><span class="line">            sum+=s; //这是归的一个过程 只能意会</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res=max(res,n-sum); //放连通块中点的最大值</span><br><span class="line">    ans=min(res,ans);</span><br><span class="line"></span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    memset(h,-1,sizeof h);</span><br><span class="line">    for(int i=0;i&lt;n-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        add(a,b),add(b,a); //无向图</span><br><span class="line">    &#125; </span><br><span class="line">    dfs(1);</span><br><span class="line">    cout &lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[图的层次遍历] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1e5+10;</span><br><span class="line"></span><br><span class="line">int h[N], e[N], idx, ne[N];</span><br><span class="line">int d[N]; //存储每个节点离起点的距离  d[1]=0</span><br><span class="line">int n, m; //n个节点m条边</span><br><span class="line">int q[N]; //存储层次遍历序列 0号节点是编号为1的节点</span><br><span class="line"></span><br><span class="line">void add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int bfs()</span><br><span class="line">&#123;</span><br><span class="line">    int hh=0,tt=0;</span><br><span class="line"></span><br><span class="line">    q[0]=1; //0号节点是编号为1的节点</span><br><span class="line"></span><br><span class="line">    memset(d,-1,sizeof d);</span><br><span class="line"></span><br><span class="line">    d[1]=0; //存储每个节点离起点的距离</span><br><span class="line"></span><br><span class="line">    //当我们的队列不为空时</span><br><span class="line">    while(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        //取出队列头部节点</span><br><span class="line">        int t=q[hh++];</span><br><span class="line"></span><br><span class="line">        //遍历t节点的每一个邻边</span><br><span class="line">        for(int i=h[t];i!=-1;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int j=e[i];</span><br><span class="line">            //如果j没有被扩展过</span><br><span class="line">            if(d[j]==-1)</span><br><span class="line">            &#123;</span><br><span class="line">                d[j]=d[t]+1; //d[j]存储j节点离起点的距离，并标记为访问过</span><br><span class="line">                q[++tt] = j; //把j结点 压入队列</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    memset(h,-1,sizeof h);</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        add(a,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;bfs()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拓扑序列<br>对于一个图中所有点构成的序列A满足 对于图中每一条边(x,y) x在A中都出现在y之前<br>简而言之所有边都是从前指向后的 有向无环图(拓扑图)一定存在拓扑序列</p><p>入度:有多少条边指向自己<br>出度：有多少边指向别人</p><p>性质 一个有向无环图一定存在一个入度为0的点<br>所有入度为0的点(无任何点指向自己的点)可以作为起点<br>1.将所有入度为0的点入队<br>2.宽搜过程 枚举所有初边</p><figure class="highlight plaintext"><figcaption><span>[拓扑图] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100100;</span><br><span class="line"></span><br><span class="line">int n,m,idx,e[N],ne[N],h[N],d[N],q[N];</span><br><span class="line"></span><br><span class="line">void add(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool topp()</span><br><span class="line">&#123;</span><br><span class="line">    int hh=0,tt=-1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!d[i]) q[++tt]=i; //入度为0的编号入队</span><br><span class="line">    &#125;</span><br><span class="line">    while(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        int t=q[hh++];</span><br><span class="line">        for(int i=h[t];i!=-1;i=ne[i]) //拓展队头元素</span><br><span class="line">        &#123;</span><br><span class="line">            int j=e[i];</span><br><span class="line">            d[j]--; //删除边 也就是对应点入度-1</span><br><span class="line">            if(d[j]==0) q[++tt]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tt==n-1; //如果队尾下标已经n-1 说明插入了n个元素 排列完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    memset(h,-1,sizeof h);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        add(x,y);</span><br><span class="line">        d[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(topp())</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;n;i++) cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    else cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进制转换</title>
      <link href="/2023/04/03/%E7%AE%97%E6%B3%95-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/04/03/%E7%AE%97%E6%B3%95-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>十进制转n进制</p><p>整数：<br>十进制转二进制： 除以2 反向取余数 直到商为0<br>十进制转八进制： 除以8 反向取余数 直到商为0<br>所以十进制转n进制 只需要除以n 反向取余数直到商为0</p><p>小数：<br>乘n取整 顺序输出<br>如0.68十进制转二进制 精确到后五位<br>0.68<em>2&#x3D;1.36 -&gt;1<br>0.36</em>2&#x3D;0.72 -&gt;0<br>0.72<em>2&#x3D;1.44 -&gt;1<br>0.44</em>2&#x3D;0.88 -&gt;0<br>0.88*2&#x3D;1.76 -&gt;1 达到要求的精度</p><p>所以0.68D&#x3D;0.10101B<br>小数部分10-&gt;a 11-&gt;b以此类推</p><p>二进制 八进制 十六进制转化为十进制</p><p>整数<br>二进制转化为十进制1011<br>1<em>2^3 +0</em>2^2 +1<em>2^1 +1</em>2^0&#x3D;11</p><p>小数<br>和整数操作相似 但是小数部分从小数点后一位指数为-1开始<br>依次-2 -3</p><p>如八进制0.45转换为十进制<br>4<em>8^(-1) + 5</em>8^(-2)&#x3D;0.578125</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>由浅入深dp1.0</title>
      <link href="/2023/03/30/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92dp/"/>
      <url>/2023/03/30/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92dp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>顺序： 暴力搜索 -&gt; 记忆化搜索 -&gt; 递推</p><p>记忆化搜索&#x3D;暴力+记录答案<br>递推公式&#x3D;dfs向下递归公式<br>递归数组初始值&#x3D;递归的边界</p><p>用mem存已经有的值</p><figure class="highlight plaintext"><figcaption><span>[上台阶1] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long n;</span><br><span class="line">int mem[10000];</span><br><span class="line"></span><br><span class="line">int dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(mem[x]) return mem[x]; //如果已经有值 用现成的 </span><br><span class="line"></span><br><span class="line">    int sum=0;</span><br><span class="line">    if(x==1) sum=1;</span><br><span class="line">    else if(x==2) sum=2;</span><br><span class="line">    else sum=dfs(x-1)+dfs(x-2);</span><br><span class="line">    mem[x]=sum;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int res=dfs(n);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>递归中 递是自顶向下把大问题分解为子问题的过程 而归 是自底向上产生答案的过程<br>此处我们知道了递归搜索树底的答案<br>由此 我们可以自底向上递推出答案 </p><figure class="highlight plaintext"><figcaption><span>[上台阶2] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int f[10000];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    f[1]=1;</span><br><span class="line">    f[2]=2;</span><br><span class="line">    if(n==1 || n==2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">        return 0; </span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=3;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=f[i-1]+f[i-2];//也就是dfs的状态转移公式</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是<br>1.想实现记忆化搜索 dfs参数需要尽可能少 因为记忆的时候若有n个参数 需开n维数组存<br>如这道题 如果额外一个参数sum记总共偷的钱 是不利于记忆化的<br>2.不应该把不影响到边界的参数放函数中<br>3.想剪枝那么得尽可能多放能剪枝的参数 (提前结束程序) 所以剪枝和记忆化搜索需要权衡</p><figure class="highlight plaintext"><figcaption><span>[acwing1049大盗阿福] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int home[10000];</span><br><span class="line">int mem[10000];</span><br><span class="line">int n,T;</span><br><span class="line"></span><br><span class="line">int dfs(int x) //x表示正在考虑哪家店</span><br><span class="line">&#123;</span><br><span class="line">    if(mem[x]) return mem[x];</span><br><span class="line">    int sum=0;</span><br><span class="line">    if(x&gt;n) sum=0; //没店就是0</span><br><span class="line">    else sum=max(dfs(x+1),dfs(x+2)+home[x]) //若不选第x家 则看x+1家 若选 则看往后第二家 值要加上home[x]</span><br><span class="line"></span><br><span class="line">    mem[x]=sum; //都是套路</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        for(int i=1;i&lt;=n;i++) cin&gt;&gt;home[i];</span><br><span class="line">        memset(mem,0,sizeof mem); //必须记得重置</span><br><span class="line">        int res=dfs(1);</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mem[i] 存的是 从第i个店铺开始能获取到的最大价值(i-n)</p><p>上述都是递归到搜索树最底部再回溯 都是归的过程产生答案<br>而递推 我们则需要从最底部推回去 推回去 这一点很重要<br>总而言之就是递归搜索树的底部是什么状态 就要从什么状态开始<br>这道题的树的底部是搜索到了最后一家店 所以从n开始枚举<br>从n开始枚举 但方程不变</p><p>如果从1开始枚举 则1是底部 首先导入的元素是n  则为 f[i]&#x3D;max(f[i-1],f[i-2]+home[i])<br>由于数组越界问题 f下标同时加2等效  f[i+2]&#x3D;max(f[i+1],f[i]+home[i]) 此时f[i]存的是从1-i个店铺的劫掠最大值 f[n]为答案</p><figure class="highlight plaintext"><figcaption><span>[acwing1049大盗阿福2.0] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int home[10000];</span><br><span class="line">int f[10000];</span><br><span class="line"></span><br><span class="line">int n,T;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        for(int i=1;i&lt;=n;i++) cin&gt;&gt;home[i];</span><br><span class="line">        memset(mem,0,sizeof f); //必须记得重置</span><br><span class="line">        for(int i=n;i&gt;=1;i--) </span><br><span class="line">        &#123;</span><br><span class="line">            f[i]=max(f[i+1],f[i+2]+home[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;f[1]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>求最优子问题 dfs(x)&#x3D;max(dfs(x+1),dfs(x+2))<br>求子问题的和 dfs(x)&#x3D;dfs(x+1)+dfs(x+2)</p><figure class="highlight plaintext"><figcaption><span>[P1216数字三角形1,。0] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int r;</span><br><span class="line">int a[1010][1010];</span><br><span class="line">int mem[1010][1010];</span><br><span class="line"></span><br><span class="line">int dfs(int x1,int y1)</span><br><span class="line">&#123;</span><br><span class="line">    if(mem[x1][y1]) return mem[x1][y1];</span><br><span class="line">    int sum=0;</span><br><span class="line">    if(x&gt;n || y&gt; n) sum=0;</span><br><span class="line">    else sum=max(a[i+1][j],a[i+1][j+1])+g[i][j];</span><br><span class="line">    mem[x1]=sum;</span><br><span class="line">    return sum; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;r;</span><br><span class="line">for(int i=1;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=i;j++) cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">    int res=dfs(1,1);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写递推方程 递推方程便和dfs方程一样 但是需要从搜索树底部开始<br>即i从n开始枚举<br>如果要从1开始枚举 这道题中 最下面一行都有可能是终点 需要循环遍历得最大值</p><figure class="highlight plaintext"><figcaption><span>[P1216数字三角形2.0] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int r;</span><br><span class="line">int a[1010][1010];</span><br><span class="line">int f[1010][1010];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;r;</span><br><span class="line">for(int i=1;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=i;j++) cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=r;i&gt;=1;i--)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=r;j++)</span><br><span class="line">&#123;</span><br><span class="line">f[i][j]=max(f[i+1][j],f[i+1][j+1])+a[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[1][1]&lt;&lt;endl; </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>细节化の宽搜BFS2.0</title>
      <link href="/2023/03/26/%E7%AE%97%E6%B3%95-%E5%AE%BD%E6%90%9CBFS2-0/"/>
      <url>/2023/03/26/%E7%AE%97%E6%B3%95-%E5%AE%BD%E6%90%9CBFS2-0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>小进阶<br>关于memset<br>它是按照字节对内存块初始化 对于int数组 只能初始化为0或-1 否则不稳定<br>其它情况还是for来初始化比较妥当<br>初始化一个0x3f 可以当无穷大使用</p><p>因为调用库会有点慢 所以应学会数组模拟队列<br>快速复习一下<br>int q[N],hh&#x3D;0,tt&#x3D;-1; &#x2F;&#x2F;hh队头 tt队尾 头在左边便于数组操作<br>&#x2F;&#x2F;插入<br>q[++tt]&#x3D;x;<br>&#x2F;&#x2F;弹出<br>hh++; 队头指针直接右移一个位置<br>&#x2F;&#x2F;判断是否为空<br>if(hh&lt;&#x3D;tt) not empty<br>else empty</p><p>bfs中队列的两个性质<br>1.队列里最多存在两种状态 当取出队头 队尾就会新增x+1<br>2.单调性 前一段状态为x 后一段状态为x+1</p><p>双端队列<br>由bfs队列中性质 若是走白给的点 那么就把这个点插到队头继续搜<br>如果是要费用的点 插到队尾 这样就保证了单调性</p><figure class="highlight plaintext"><figcaption><span>[洛谷4554] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">int n,m,a,b,x1,y3,x2,y2;</span><br><span class="line">char g[510][510];</span><br><span class="line">int dist[510][510];</span><br><span class="line"></span><br><span class="line">int dx[]=&#123;1,-1,0,0&#125;;</span><br><span class="line">int dy[]=&#123;0,0,1,-1&#125;;</span><br><span class="line"></span><br><span class="line">typedef pair &lt;int,int&gt; PII;</span><br><span class="line">deque &lt;PII&gt; q; //双端队列</span><br><span class="line"></span><br><span class="line">int bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">q.push_back(&#123;x,y&#125;);</span><br><span class="line">dist[x][y]=0;</span><br><span class="line">while(q.size())</span><br><span class="line">&#123;</span><br><span class="line">auto t=q.front();</span><br><span class="line">q.pop_front();</span><br><span class="line">char ch=g[t.first][t.second];</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int a=t.first+dx[i];</span><br><span class="line">int b=t.second+dy[i];</span><br><span class="line">if(a&lt;0 || a&gt;=n || b&lt;0 || b&gt;=m) continue;</span><br><span class="line">if(dist[a][b]&gt;=0 ) continue;</span><br><span class="line"></span><br><span class="line">if(g[a][b]==ch)</span><br><span class="line">&#123;</span><br><span class="line">dist[a][b]=dist[t.first][t.second]; //如果有点可以走且符号一样 费用为0 </span><br><span class="line">q.push_front(&#123;a,b&#125;); //这个点插到最前面优先搜 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(g[a][b]!=ch)</span><br><span class="line">&#123;</span><br><span class="line">dist[a][b]=dist[t.first][t.second]+1;</span><br><span class="line">q.push_back(&#123;a,b&#125;); //如果这点要花费 那么就从 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(a==x2 &amp;&amp; b==y2) return dist[x2][y2];</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"> return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m, n||m )</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%s&quot;,g[i]);</span><br><span class="line">&#125;</span><br><span class="line">memset(dist,-1,sizeof dist);</span><br><span class="line">q.clear();</span><br><span class="line">cin&gt;&gt;x1&gt;&gt;y3&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line"></span><br><span class="line">int res=bfs(x1,y3);</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.首先 棋盘那么多变化 肯定是存不了的 可以用字符串来表示这个棋盘 这便是一个状态压缩<br>然后需要一维数组到二维数组 二维数组到一维数组的变化 这是个小技巧<br>2. map 把一个string 对应一个int 存步骤数<br>3. count看map里有没有已经出现过下一个要走的点 如果已经出现过就没必要走了<br>4. 需要回溯 因为是对于一个点四个方向去看 </p><figure class="highlight plaintext"><figcaption><span>[洛谷1379八数码难题] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string end1=&quot;123804765&quot;;</span><br><span class="line"></span><br><span class="line">int dx[]=&#123;0,0,1,-1&#125;;</span><br><span class="line">int dy[]=&#123;1,-1,0,0&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;string,int&gt; dist;</span><br><span class="line">queue&lt;string&gt; q;</span><br><span class="line"></span><br><span class="line">int bfs(string start)</span><br><span class="line">&#123;</span><br><span class="line">q.push(start);</span><br><span class="line">dist[start]=0;</span><br><span class="line"></span><br><span class="line">while(q.size())</span><br><span class="line">&#123;</span><br><span class="line">auto t=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line">if(t==end1) return dist[t];</span><br><span class="line"></span><br><span class="line">int distance=dist[t];</span><br><span class="line">int a=t.find(&#x27;0&#x27;); //找0的下标 </span><br><span class="line">int x1=a/3,y1=a%3;//一维下标转二维</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int x2=x1+dx[i];</span><br><span class="line">int y2=y1+dy[i];</span><br><span class="line">if(x2&lt;0 || x2&gt;=3 || y2&lt;0 || y2&gt;=3) continue;</span><br><span class="line"></span><br><span class="line">int tmp=x2*3 +y2; //二维下标转一维交换位置 </span><br><span class="line">swap(t[a],t[tmp]);</span><br><span class="line">if(!dist.count(t)) //看下一个位置有没有被访问过 </span><br><span class="line">&#123;</span><br><span class="line">dist[t]=distance+1;</span><br><span class="line">q.push(t);</span><br><span class="line">&#125;</span><br><span class="line">swap(t[a],t[tmp]); //必须再换回去 </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string start;</span><br><span class="line">cin&gt;&gt;start;</span><br><span class="line">int res=bfs(start);</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果起点和终点的状态已知 那么可以双向bfs<br>让终点和起点一起入队 同时开始搜 总有一个时刻 起点终点都可以拓展到 此时结束<br>这样空间占用更少 时间占用也更少</p><p>双向bfs维护的是两个队列而不是一个 轮流拓展两个队列 同时用数组或者哈希表记录搜索情况 给从两个方向拓展的节点以不同的标记 当某点被两种标记同时标记时 搜索结束</p><p>使用的条件 必须知道初始状态与结束状态<br>往往涉及如上题的状态压缩</p><p>这道之前有 用双向试一试<br>就是起点初始vs为1 终点为2 如果有个点vs为3则相遇了 return<br>return 的值需要加1 因为终点初始是0 这一格没有算进去<br>再次注意输入的是字符 </p><figure class="highlight plaintext"><figcaption><span>[洛谷] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1010;</span><br><span class="line">int g[N][N]; //存地图</span><br><span class="line">int dist[N][N];</span><br><span class="line">int vs[N][N];</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">queue&lt;PII&gt; s;</span><br><span class="line">int n,x1,y11,x2,y2=0;</span><br><span class="line">PII q[N*N];</span><br><span class="line">int dx[]=&#123;1,0,-1,0&#125;;</span><br><span class="line">int dy[]=&#123;0,1,0,-1&#125;; </span><br><span class="line"></span><br><span class="line">int bfs()</span><br><span class="line">&#123;</span><br><span class="line">memset(dist,-1,sizeof dist);</span><br><span class="line">memset(vs,-1,sizeof vs);</span><br><span class="line"></span><br><span class="line">dist[x1][y11]=0,dist[x2][y2]=0;</span><br><span class="line">vs[x1][y11]=1,vs[x2][y2]=2;</span><br><span class="line">q[0]=&#123;x1,y11&#125;,q[1]=&#123;x2,y2&#125;;</span><br><span class="line">int hh=0,tt=1;</span><br><span class="line">while(hh&lt;=tt)</span><br><span class="line">&#123;</span><br><span class="line">auto t=q[hh++];</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int a=t.first+dx[i];</span><br><span class="line">int b=t.second+dy[i];</span><br><span class="line">if(a&lt;1 || a&gt;n || b&lt;1 || b&gt;n) continue;</span><br><span class="line">if(g[a][b]!=0) continue; //越界 不是马路</span><br><span class="line">if(vs[a][b]+vs[t.first][t.second]==3) //说明拓展到了一个点 </span><br><span class="line">&#123;</span><br><span class="line">return dist[t.first][t.second]+dist[a][b]+1; //记得加1 因为还有一格 </span><br><span class="line">&#125;</span><br><span class="line">if(dist[a][b]&gt;=0) continue; //说明走过了 </span><br><span class="line">dist[a][b]=dist[t.first][t.second]+1;</span><br><span class="line">if(vs[a][b]==-1) </span><br><span class="line">&#123;</span><br><span class="line">vs[a][b]=vs[t.first][t.second]; </span><br><span class="line">&#125;</span><br><span class="line">q[++tt]=&#123;a,b&#125;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">char c;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">g[i][j]=c-&#x27;0&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//if(g[1][1]==0) cout&lt;&lt;2&lt;&lt;endl;</span><br><span class="line">cin&gt;&gt;x1&gt;&gt;y11&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">int res=bfs();</span><br><span class="line">cout&lt;&lt;res;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>八数码也可以用双向bfs 但是就显得有点复杂了 略</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>细节化の宽搜BFS</title>
      <link href="/2023/03/17/%E7%AE%97%E6%B3%95-%E5%AE%BD%E6%90%9CBFS/"/>
      <url>/2023/03/17/%E7%AE%97%E6%B3%95-%E5%AE%BD%E6%90%9CBFS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>BFS<br>主要解决两类问题<br>1.从a出发是否存在到达b的路径<br>2.从a出发到b的最短路径<br>数据20以内dfs可能行。。。推荐bfs<br>大概就是对于一个点 一层一层访问周围的点（类似于子节点的子节点）<br>整体思路：<br>起始 扩散 终止</p><p>需要队列的原因：需要一层一层遍历 相邻节点的访问顺序需要确定<br>即使得先遍历到的节点先被存储 再按照存储先后顺序取出来遍历其子节点 综上所述队列符合</p><p>两道热身题</p><figure class="highlight plaintext"><figcaption><span>[洛谷1716离开中山路] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1010;</span><br><span class="line">int g[N][N]; //存地图</span><br><span class="line">int dist[N][N];</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">queue&lt;PII&gt; s;</span><br><span class="line">int n,x1,y11,x2,y2=0;</span><br><span class="line"></span><br><span class="line">int dx[]=&#123;1,0,-1,0&#125;;</span><br><span class="line">int dy[]=&#123;0,1,0,-1&#125;; </span><br><span class="line"></span><br><span class="line">int bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">memset(dist,-1,sizeof(dist));</span><br><span class="line">s.push(&#123;x,y&#125;);</span><br><span class="line">dist[x][y]=0;</span><br><span class="line">while(!s.empty())</span><br><span class="line">&#123;</span><br><span class="line">auto t=s.front();</span><br><span class="line">s.pop(); //第一个再删掉 </span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int a=t.first+dx[i];</span><br><span class="line">int b=t.second+dy[i];</span><br><span class="line"></span><br><span class="line">if(a&lt;1 ||a&gt;n || b&lt;1 || b&gt;n) continue;</span><br><span class="line">if(dist[a][b]&gt;0) continue;</span><br><span class="line">if(g[a][b]!=0) continue;</span><br><span class="line">s.push(&#123;a,b&#125;);</span><br><span class="line">dist[a][b]=dist[t.first][t.second]+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return dist[x2][y2];</span><br><span class="line"> &#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">char c;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">g[i][j]=c-&#x27;0&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;x1&gt;&gt;y11&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">int res=bfs(x1,y11);</span><br><span class="line">cout&lt;&lt;res;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要求路径 那么定义一个数组 bfs中每一次移动的时候存一下移动前的下标<br>从终点开始推</p><figure class="highlight plaintext"><figcaption><span>[洛谷1443马的遍历] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1010;</span><br><span class="line">int g[N][N]; //存地图</span><br><span class="line">int dist[N][N];</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line"></span><br><span class="line">int n,x1,y11,x2,y2=0;</span><br><span class="line">PII q[N*N];</span><br><span class="line">int dx[]=&#123;1,0,-1,0&#125;;</span><br><span class="line">int dy[]=&#123;0,1,0,-1&#125;; </span><br><span class="line"></span><br><span class="line">int bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">memset(dist,-1,sizeof(dist));</span><br><span class="line">int tt=-1;</span><br><span class="line">int hh=0;</span><br><span class="line">q[++tt]=&#123;x,y&#125;; //其实这里可以将hh tt初始化为0 因为一开始就插了个数了</span><br><span class="line">dist[x][y]=0;</span><br><span class="line">while(hh&lt;=tt)</span><br><span class="line">&#123;   </span><br><span class="line">   auto t = q[hh]; //auto t=s.front();</span><br><span class="line">hh++;         //s.pop();  这里可以写成auto tt=q[hh++]</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int a=t.first+dx[i];</span><br><span class="line">int b=t.second+dy[i];</span><br><span class="line"></span><br><span class="line">if(a&lt;1 ||a&gt;n || b&lt;1 || b&gt;n) continue;</span><br><span class="line">if(dist[a][b]&gt;0) continue;</span><br><span class="line">if(g[a][b]!=0) continue;</span><br><span class="line">q[++tt]=&#123;a,b&#125;;</span><br><span class="line">dist[a][b]=dist[t.first][t.second]+1;</span><br><span class="line">if(dist[x2][y2]&gt;0) return dist[x2][y2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return dist[x2][y2];</span><br><span class="line"> &#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">char c;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">g[i][j]=c-&#x27;0&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;x1&gt;&gt;y11&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">int res=bfs(x1,y11);</span><br><span class="line">cout&lt;&lt;res;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多源bfs 好好感受一下<br>关键就是一开始就把感染源放队列里 这样就保证了同时性</p><figure class="highlight plaintext"><figcaption><span>[洛谷1332血色先锋队] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,a,b;</span><br><span class="line">typedef pair &lt;int,int&gt; PII;</span><br><span class="line">PII q[510*510];</span><br><span class="line">int dist[510][510];</span><br><span class="line"></span><br><span class="line">int dx[]=&#123;0,0,1,-1&#125;;</span><br><span class="line">int dy[]=&#123;-1,1,0,0&#125;;</span><br><span class="line"></span><br><span class="line">int tt=-1,hh=0;</span><br><span class="line"></span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">while(hh&lt;=tt)//不为空 </span><br><span class="line">&#123;</span><br><span class="line">auto t=q[hh++]; //取队头 再弹出队头</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int a=t.first+dx[i];</span><br><span class="line">int b=t.second+dy[i];</span><br><span class="line">if(a&gt;n || a&lt;1 || b&gt;m || b&lt;1) continue;</span><br><span class="line">if(dist[a][b]&gt;=0) continue;</span><br><span class="line">dist[a][b]=dist[t.first][t.second]+1;</span><br><span class="line">q[++tt]=&#123;a,b&#125;;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">memset(dist,-1,sizeof(dist));</span><br><span class="line">for(int i=0;i&lt;a;i++)</span><br><span class="line">&#123;</span><br><span class="line">int x0,y0;</span><br><span class="line">cin&gt;&gt;x0&gt;&gt;y0;</span><br><span class="line">q[++tt]=&#123;x0,y0&#125;;</span><br><span class="line">dist[x0][y0]=0;</span><br><span class="line">&#125;</span><br><span class="line">bfs();</span><br><span class="line">while(b--)</span><br><span class="line">&#123;</span><br><span class="line">int x1,y1;</span><br><span class="line">cin&gt;&gt;x1&gt;&gt;y1;</span><br><span class="line">cout&lt;&lt;dist[x1][y1]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这题跟dfs连通块有点像 但是是反着来的</p><figure class="highlight plaintext"><figcaption><span>[洛谷1162填涂颜色] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int g[35][35];</span><br><span class="line">bool st[35][35];</span><br><span class="line">int dx[]=&#123;0,0,1,-1&#125;;</span><br><span class="line">int dy[]=&#123;1,-1,0,0&#125;;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">PII q[35*35];</span><br><span class="line"></span><br><span class="line">void bfs(int x1,int y1)</span><br><span class="line">&#123;</span><br><span class="line">q[0]=&#123;x1,y1&#125;;</span><br><span class="line">int hh=0;</span><br><span class="line">int tt=0;</span><br><span class="line">while(hh&lt;=tt)</span><br><span class="line">&#123;</span><br><span class="line">auto t=q[hh++]; //取队头 弹出队头</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int a=t.first+dx[i];</span><br><span class="line">int b=t.second+dy[i];</span><br><span class="line">if(g[a][b]==1) continue;</span><br><span class="line">if(a&lt;0 || b&lt;0 || a&gt;n+1 || b&gt;n+1 ) continue;</span><br><span class="line">if(st[a][b]) continue;</span><br><span class="line">st[a][b]=true;</span><br><span class="line">q[++tt]=&#123;a,b&#125;;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=n;j++) cin&gt;&gt;g[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bfs(0,0);</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(!st[i][j] &amp;&amp; g[i][j]==0) g[i][j]=2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=n;j++) cout&lt;&lt;g[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题有些细节需要注意<br>1.初始化 fire存的是最早的陨石时间 所以可以初始化为0x3f<br>2.边界问题 因为陨石可以落到边界上 所以往外延伸一圈才是边界<br>3.时间的比较 需要逻辑清晰</p><figure class="highlight plaintext"><figcaption><span>[洛谷2895] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int m;</span><br><span class="line">int dx[]=&#123;0,0,1,-1&#125;;</span><br><span class="line">int dy[]=&#123;1,-1,0,0&#125;;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line"></span><br><span class="line">#define x first</span><br><span class="line">#define y second</span><br><span class="line">PII q[310*310];</span><br><span class="line">bool st[310][310];</span><br><span class="line">int dist[310][310];</span><br><span class="line">int fire[310][310];</span><br><span class="line">int bfs(int x1,int y1)</span><br><span class="line">&#123;</span><br><span class="line">memset(dist,-1,sizeof(dist));</span><br><span class="line">dist[x1][y1]=0;</span><br><span class="line">q[0]=&#123;x1,y1&#125;;</span><br><span class="line">int hh=0,tt=0;</span><br><span class="line">while(hh&lt;=tt)</span><br><span class="line">&#123;</span><br><span class="line">auto t=q[hh++];</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int a=t.x+dx[i];</span><br><span class="line">int b=t.y+dy[i];</span><br><span class="line">if(a&lt;0 || b&lt;0 ) continue;</span><br><span class="line">if(dist[a][b]&gt;0) continue;</span><br><span class="line">if(dist[t.x][t.y]+1&gt;=fire[a][b]) continue;</span><br><span class="line">q[++tt]=&#123;a,b&#125;;</span><br><span class="line">dist[a][b]=dist[t.x][t.y]+1;</span><br><span class="line">q[++tt]=&#123;a,b&#125;;</span><br><span class="line">if(fire[a][b]&gt;1e9) return dist[a][b];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">memset(fire,0x3f,sizeof fire);</span><br><span class="line">while(m--)</span><br><span class="line">&#123;</span><br><span class="line">int x2,y2,t;</span><br><span class="line">cin&gt;&gt;x2&gt;&gt;y2&gt;&gt;t;</span><br><span class="line">fire[x2][y2]=min(t,fire[x2][y2]);</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int a=x2+dx[i];</span><br><span class="line">int b=y2+dy[i];</span><br><span class="line">if(a&lt;0 || a&gt;301 || b&lt;0 || b&gt;301) continue;</span><br><span class="line">fire[a][b]=min(t,fire[a][b]);</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">int res=bfs(0,0);</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl; </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题就是一个二分加bfs的结合<br>注意的问题<br>1.本题行是m 列是n<br>2.队列数组需要开够大<br>3. 二分板子需要记忆清楚</p><figure class="highlight plaintext"><figcaption><span>[洛谷2658] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std; </span><br><span class="line">int h[510][510],flag[510][510];</span><br><span class="line">int x3,y3,ans,cnt1,m,n;</span><br><span class="line">int dx[]=&#123;0,0,1,-1&#125;;</span><br><span class="line">int dy[]=&#123;1,-1,0,0&#125;;</span><br><span class="line">bool st[510][510];</span><br><span class="line">#define x first</span><br><span class="line">#define y second</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">PII q[510*510];</span><br><span class="line"></span><br><span class="line">bool check(int mid1)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;y1&lt;&lt;endl;</span><br><span class="line">q[0]=&#123;x3,y3&#125;;</span><br><span class="line">st[x3][y3]=true;</span><br><span class="line">int cnt2=1; //统计经过的路标个数 </span><br><span class="line">int hh=0;</span><br><span class="line">int tt=0;</span><br><span class="line">while(hh&lt;=tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">auto t=q[hh++];</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int a=t.x+dx[i];</span><br><span class="line">int b=t.y+dy[i];</span><br><span class="line">//cout&lt;&lt;t.x&lt;&lt;&quot; &quot;&lt;&lt;t.y&lt;&lt;endl;</span><br><span class="line">if(a&lt;1 || a&gt;m || b&lt;1 || b&gt;n) continue;</span><br><span class="line">if(abs(h[t.x][t.y]-h[a][b])&gt;mid1) continue;</span><br><span class="line">if(st[a][b]==true) continue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q[++tt]=&#123;a,b&#125;;</span><br><span class="line">st[a][b]=true;</span><br><span class="line"></span><br><span class="line">if(flag[a][b]==1)</span><br><span class="line">&#123;</span><br><span class="line">cnt2++;</span><br><span class="line">//cout&lt;&lt;cnt1&lt;&lt;&quot; &quot;&lt;&lt;cnt2&lt;&lt;endl;</span><br><span class="line">if(cnt2==cnt1) return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=n;j++) cin&gt;&gt;h[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;flag[i][j];</span><br><span class="line">if(flag[i][j]==1) cnt1++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(flag[i][j]==1)</span><br><span class="line">&#123;</span><br><span class="line">x3=i;</span><br><span class="line">y3=j;</span><br><span class="line">//cout&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;y1&lt;&lt;endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//cout&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;y1;</span><br><span class="line">int l=-1;</span><br><span class="line">int r=1e9+10; //找最少的 左边界</span><br><span class="line">while(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">memset(q,0,sizeof(q));</span><br><span class="line">memset(st,false,sizeof(st));</span><br><span class="line">int mid=(l+r)/2;</span><br><span class="line">//cout&lt;&lt;mid&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">if(check(mid))</span><br><span class="line">&#123;</span><br><span class="line">ans=mid;</span><br><span class="line">r=mid-1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else l=mid+1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>透彻の学习DFS3.0</title>
      <link href="/2023/03/13/%E7%AE%97%E6%B3%95-%E6%B7%B1%E6%90%9Cdfs3-0/"/>
      <url>/2023/03/13/%E7%AE%97%E6%B3%95-%E6%B7%B1%E6%90%9Cdfs3-0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天发现了一个函数<br>next_permutation(a,a+n)<br>即求当前排列的下n个排列<br>例如n&#x3D;1 对1234用 求出1243<br>在全排列问题中很有效</p><p>火星人这道题就是说 求一个全排列之下的第n个排列<br>正常也可以dfs写 只需要res到m+1时输出就行了 并且注意要剪枝</p><figure class="highlight plaintext"><figcaption><span>[p1088火星人] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">int a[10100];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    next_permutation(a,a+n);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>烤鸡这道题要先输出方案数 所以要特别做法 用一个二维数组存<br>并且注意剪枝 如果调料还没选完都已经大于n了 那么就不用再往下了 </p><figure class="highlight plaintext"><figcaption><span>[p2089] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">using namespace std;</span><br><span class="line">const int N=5020;  </span><br><span class="line">int n,sum=0;</span><br><span class="line">int mem[59055][20];</span><br><span class="line">int a[N];</span><br><span class="line">int res=0;</span><br><span class="line">void dfs(int x,int sum)</span><br><span class="line">&#123;</span><br><span class="line">if(sum&gt;n) return;</span><br><span class="line">if(x&gt;10)</span><br><span class="line">&#123;</span><br><span class="line">if(sum==n)</span><br><span class="line">&#123;</span><br><span class="line">res++;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">mem[res][i]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=3;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[x]=i;</span><br><span class="line">dfs(x+1,sum+i);</span><br><span class="line">a[x]=0;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">dfs(1,sum);</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">for(int i=1;i&lt;=res;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=10;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;mem[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>火柴这道题非常有意思<br>有两个必须满足的条件<br>一个是a+b&#x3D;c<br>一个是num[a]+num[b]&#x3D;num[c]-4<br>最关键的就是对于总和的处理 需要额外写个函数计算二位数及以上的火柴数<br>也可以用递推求出10-1000的  节省时间到原来的三分之一<br>也要记得剪枝 如果还没枚举完 火柴数都超了 那么直接return</p><figure class="highlight plaintext"><figcaption><span>[p1149] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,res=0;</span><br><span class="line">int num[10010]=&#123;6,2,5,5,4,5,6,3,7,6&#125;;</span><br><span class="line">int arr[10010];</span><br><span class="line"></span><br><span class="line">int col(int x)</span><br><span class="line">&#123;</span><br><span class="line">int sum2=0;</span><br><span class="line">if(num[x]&gt;0) return num[x];</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    while(x)</span><br><span class="line">    &#123;</span><br><span class="line"> sum2+=num[x%10];</span><br><span class="line"> x/=10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return sum2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int x,int sum)</span><br><span class="line">&#123;</span><br><span class="line">if(sum&gt;n) return;</span><br><span class="line">if(x&gt;3)</span><br><span class="line">&#123;</span><br><span class="line">if(arr[1]+arr[2]==arr[3] &amp;&amp; sum==n)  res++;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;=1000;i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[x]=i;</span><br><span class="line">dfs(x+1,sum+col(i));</span><br><span class="line">arr[x]=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">n-=4; //预处理一下 清晰一点 </span><br><span class="line">dfs(1,0);</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题是有坑的 就是至少添加一个调料<br>我们可以全局定义一个bool 选择先搜不选 因为从不选搜到第一个有选以后 之后都起码选了一个<br>也可以定义在函数里 先搜全选</p><figure class="highlight plaintext"><figcaption><span>[p2036] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=20;</span><br><span class="line">int n;</span><br><span class="line">int res=1e9;</span><br><span class="line">int s[N],b[N],st[N];</span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(x&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">bool has_s=false;</span><br><span class="line">int sum1=1;</span><br><span class="line">int sum2=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(st[i]==1)</span><br><span class="line">&#123;</span><br><span class="line">has_s=true;</span><br><span class="line">sum1*=s[i];</span><br><span class="line">sum2+=b[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(has_s==true) res=min(res,abs(sum1-sum2));</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">st[x]=1;</span><br><span class="line">dfs(x+1);</span><br><span class="line">st[x]=0;</span><br><span class="line"></span><br><span class="line">st[x]=2;</span><br><span class="line">dfs(x+1);</span><br><span class="line">st[x]=0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s[i];</span><br><span class="line">cin&gt;&gt;b[i];</span><br><span class="line">&#125;</span><br><span class="line">dfs(1);</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是迷宫环节<br>这道题有一个剪枝难点 和之前的电梯一样<br>namo就是 走过一次的话 就没必要走多次<br>还有一点就是 这道题不能回溯 因为路径是单一的 回溯了会重复计数</p><figure class="highlight plaintext"><figcaption><span>[P1683] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=30;</span><br><span class="line">int w,h,res=0;</span><br><span class="line">char zi[N][N];</span><br><span class="line">bool st[N][N];</span><br><span class="line">int zoux[]=&#123;-1,0,1,0&#125;;</span><br><span class="line">int zouy[]=&#123;0,1,0,-1&#125;;</span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int a=x+zoux[i];</span><br><span class="line">int b=y+zouy[i];</span><br><span class="line">if(a&lt;1 ||a&gt;h ||b&lt;1 ||b&gt;w) continue;</span><br><span class="line">if(zi[a][b]!=&#x27;.&#x27;) continue;</span><br><span class="line">if(st[a][b]) continue;</span><br><span class="line">st[a][b]=true;</span><br><span class="line">res++;</span><br><span class="line">dfs(a,b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;w&gt;&gt;h;</span><br><span class="line">for(int i=1;i&lt;=h;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=w;j++) cin&gt;&gt;zi[i][j];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=h;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=w;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(zi[i][j]==&#x27;@&#x27;)</span><br><span class="line">&#123;</span><br><span class="line">st[i][j]=true;</span><br><span class="line">dfs(i,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;++res&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>透彻の学习DFS2.0</title>
      <link href="/2023/02/28/%E7%AE%97%E6%B3%95-%E6%B7%B1%E6%90%9CDFS/"/>
      <url>/2023/02/28/%E7%AE%97%E6%B3%95-%E6%B7%B1%E6%90%9CDFS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先通过上台阶这道题 我们理解了搜索树这个东西</p><p>1.就像树结构一样 向深处搜索 每一个路径一定会走到头 走到头以后回溯 继续往可以走的路径移动..再回溯  回溯个人理解：n个子节点的状态都需由父节点推出 所以父节点每次推子节点的时候初始状态是相同的  需要子节点恢复到之前的状态得到父节点 这便是回溯<br>2.使用栈<br>3.空间O(n)<br>4.不具有最短性</p><p>重点 回溯与剪枝</p><figure class="highlight plaintext"><figcaption><span>[acwing92递归实现指数型枚举] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1000;</span><br><span class="line">int n;</span><br><span class="line">int st[N],p[N];//1表示选 2表示不选 </span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(x&gt;n) //枚举到第n+1个位置 那么说明前面n个排完了 输出</span><br><span class="line">&#123;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(st[i]==1) cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">return; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st[x]=1;//如果选</span><br><span class="line">dfs(x+1);//这个位置选了之后 进行标记 看下个位置 </span><br><span class="line">st[x]=0;//回溯 恢复现场</span><br><span class="line"></span><br><span class="line">st[x]=2;//不选</span><br><span class="line">dfs(x+1);</span><br><span class="line">    st[x]=0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">dfs(1);</span><br><span class="line">return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对于字典序不重复排列 那么我们还是以 依次枚举每个位置枚举应该放哪个数的思路<br>之前那道对于一个数由三个状态 选 不选 没考虑到<br>而这道题因为要以字典序排列 所以只有 用了和没用两个状态 </p><figure class="highlight plaintext"><figcaption><span>[洛谷] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1000;</span><br><span class="line">int n;</span><br><span class="line">bool st[N];</span><br><span class="line">int p[N];</span><br><span class="line"></span><br><span class="line">void dfs(int x) //熟悉的味道 还是枚举位置</span><br><span class="line">&#123;</span><br><span class="line">if(x&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">return; //注意这有一步输出后回到其父节点的状态</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(!st[i]) //如果这个数没用过</span><br><span class="line">&#123;</span><br><span class="line">p[x]=i; // 这个位置就填它</span><br><span class="line">st[i]=true; //用过了</span><br><span class="line">dfs(x+1);</span><br><span class="line">p[x]=0; //恢复现场</span><br><span class="line">st[i]=false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">dfs(1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>n个元素抽r个组合 这个就有所不同了<br>如 5 3<br>就有123 124 125 134 135<br>因为是组合 不难发现前位数一定是大于后位数的</p><figure class="highlight plaintext"><figcaption><span>[输出数字组合] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1000;</span><br><span class="line"></span><br><span class="line">int n,r;</span><br><span class="line">int arr[N];//记录选了哪些数</span><br><span class="line"></span><br><span class="line">void dfs(int x,int start )//start记录当前位置从几开始枚举</span><br><span class="line">&#123;</span><br><span class="line">if(x&gt;r)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=1;i&lt;=r;i++) cout&lt;&lt;setw(3)&lt;&lt;arr[i];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=start;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[x]=i;</span><br><span class="line">dfs(x+1,i+1);</span><br><span class="line">arr[x]=0;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;r;</span><br><span class="line">dfs(1,1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[P1036选数] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 100;</span><br><span class="line">int q[N],arr[N];</span><br><span class="line">int n,k;</span><br><span class="line">int cnt=0;</span><br><span class="line"></span><br><span class="line">bool is_prime(int sum)</span><br><span class="line">&#123;</span><br><span class="line">if(sum&lt;2) return false;</span><br><span class="line">for(int i=2;i&lt;=sqrt(sum);i++)</span><br><span class="line">&#123;</span><br><span class="line">if(sum%i==0) return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int x,int start)</span><br><span class="line">&#123;</span><br><span class="line">if(x&gt;k)</span><br><span class="line">&#123;</span><br><span class="line">int sum=0;</span><br><span class="line">for(int i=1;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum+=arr[i];</span><br><span class="line">&#125;</span><br><span class="line">if(is_prime(sum)) cnt++;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for(int i=start;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[x]=q[i];</span><br><span class="line">dfs(x+1,i+1);</span><br><span class="line">arr[x]=0;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;q[i];</span><br><span class="line">dfs(1,1);</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先得注意 输入的是字符 所以不能直接cin&gt;&gt;a[i][j] (没有输出 我想了二十分钟为什么)<br>其次 其实遇到一个没有used的 就cnt++ 再从这个点搜一下就行了很简单</p><figure class="highlight plaintext"><figcaption><span>[P1451细胞数量] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,cnt=0;</span><br><span class="line">int a[120][120];</span><br><span class="line">bool used[120][120];</span><br><span class="line">int dx[4]=&#123;-1,1,0,0&#125;;</span><br><span class="line">int dy[4]=&#123;0,0,-1,1&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">used[x][y]=1;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int nx=x+dx[i];</span><br><span class="line">int ny=y+dy[i];</span><br><span class="line">if(used[nx][ny]==1 || a[nx][ny]==0) continue;</span><br><span class="line">dfs(nx,ny);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">memset(a,0,sizeof(a));</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">char c;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">a[i][j]=c-&#x27;0&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i][j]!=0 &amp;&amp;used[i][j]==0)</span><br><span class="line">&#123;</span><br><span class="line">dfs(i,j);</span><br><span class="line">    cnt++; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;cnt;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集2.0</title>
      <link href="/2023/02/26/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2023/02/26/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一般处理的问题<br>1.将两个集合合并<br>2.询问两个元素是否在一个集合当中</p><p>如果是暴力做法 数组存储每个元素属于哪一个集合<br>1.<br>belong[x]&#x3D;a<br>if(belong[x]&#x3D;belong[y]) O(1)<br>2.如果想合并 极其麻烦 元素多了就寄了</p><p>基本原理<br>用树的形式维护每一个集合 树根的编号就是集合的编号<br>每个节点存储它的父节点p[x]表示x的父节点<br>1.<br>将一棵树插到另一棵树<br>px是x的集合编号 py是y的集合编号 合并就是p[x]&#x3D;y</p><ol start="2"><li>求某个点属于哪个集合 通过其父节点<br>求x的集合编号 while(p[x]!&#x3D;x) x&#x3D;p[x]; 路径压缩优化 一旦找到根节点 整个路径上所有结点直接指向根节点</li></ol><figure class="highlight plaintext"><figcaption><span>[并查集] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1000010;</span><br><span class="line">int n,m;</span><br><span class="line">int p[N]; //存父节点</span><br><span class="line"></span><br><span class="line">int find(int x) //返回x的祖宗节点+路径压缩</span><br><span class="line">&#123;</span><br><span class="line">    if(p[x]==x) return x;//没错 就两行 如果x不是根节点 就让x的父节点等于它的祖宗节点</span><br><span class="line">    return p[x]=find(p[x]); //递归将路径上所有结点的父节点都是根节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) p[i]=i;</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        char op[2];</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        if(op[0]==&#x27;M&#x27;) p[find(a)]=find(b) //合并操作 让a的祖宗节点的父亲等于b的祖宗节点 相当于插入了</span><br><span class="line">        else //判断是否在同一个集合里</span><br><span class="line">        &#123;</span><br><span class="line">            if(find(a)==find(b)) puts(&quot;Yes&quot;)</span><br><span class="line">            else puts(&quot;No&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>acwing 837<br>其实思路十分相近 所谓连通块可以直接用集合来维护 只需模板代码稍作改变<br>主要问题是怎么维护size 也就是集合里元素数量</p><figure class="highlight plaintext"><figcaption><span>[连通块中点的数量] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1000010;</span><br><span class="line">int n,m;</span><br><span class="line">int p[N],size[N]; //每一个集合里点的数量</span><br><span class="line"></span><br><span class="line">int find(int x) </span><br><span class="line">&#123;</span><br><span class="line">    if(p[x]==x) return x;</span><br><span class="line">    return p[x]=find(p[x])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=i;</span><br><span class="line">        size[i]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        char op[5];</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        if(op[0]==&#x27;C&#x27;)//合并</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            if(find(a)==find(b)) continue;//此题有自己连自己的情况 需要特判</span><br><span class="line">            size[find(b)]+=size[find(a)];</span><br><span class="line">            p[find(a)]=find(b);</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        else if(op[1]==&#x27;1&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            if(find(a)==find(b)) puts(&quot;Yes&quot;);</span><br><span class="line">            else puts(&quot;No&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else // 问数量</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">            cout&lt;&lt;size[(find(a))];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树的遍历</title>
      <link href="/2023/02/26/%E7%AE%97%E6%B3%95-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2023/02/26/%E7%AE%97%E6%B3%95-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先序遍历: 从一棵二叉树根节点为起点 沿着二叉树外沿 逆时针走一圈回到根节点 路上遇到的元素顺序 就是先序遍历的结果</p><p>中序遍历:二叉树每个节点垂直方向投影下来（可以理解为每个节点从最左边开始垂直掉到地上） 然后从左往右数 得出的结果便是中序遍历的结果</p><p>后序遍历：围着树的外围绕一圈 如果发现一剪刀就能剪下的葡萄（必须是一颗葡萄）（也就是葡萄要一个一个掉下来，不能一口气掉超过1个这样） 就把它剪下来 组成的就是后序遍历了</p><p>层序遍历：先根再左再右</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>完全背包</title>
      <link href="/2023/02/24/%E7%AE%97%E6%B3%95-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%982/"/>
      <url>/2023/02/24/%E7%AE%97%E6%B3%95-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>回顾一下<br>f[i][j] 所有只考虑前i个物品 且总体积不大于j的所有选法</p><p>当前种类的物品，“选了多少个”：<br>选0个，就是前面物品在当前体积下的最大价值：f[i-1][j]；<br>选1个，前面物品在去掉当前1个物品体积的最大价值+当前1个物品的价值：f[i-1][j-1<em>v[i]]+1</em>w[i];<br>选2个，前面物品在去掉当前2个物品体积的最大价值+当前2个物品的价值：f[i-1][j-2<em>v[i]]+2</em>w[i];<br>不难能推导出 完全背包的动态转移方程 f[i,j]&#x3D;f[i-1,j-v[i]*k]+w[i]*k (注意k有限制条件的)<br>将其展开<br>f[i,j]&#x3D;max(f[i-1,j],f[i-1,j-v[i]]+W,f[i-1,j-2v[i]]+2W…)<br>f[i,j-v[i]]&#x3D;max(f[i-1],j-v[i],f[i-1,j-2v]+w…)<br>两者相似 从第二项开始每项差一个w<br>所以f[i,j]&#x3D;max(f[i-1,j],f[i,j-v]+w) 这样就不用枚举k了</p><p>这时我们便发现 二维完全背包和二维01背包非常的相似 其实唯一的区别就是<br>01背包 f[i][j]&#x3D;max(f[i][j],f[i-1][j-v[i]]+w[i])<br>完全背包 f[i][j]&#x3D;max(f[i][j],f[i][j-v[i]]+w[i])<br>便于记忆</p><figure class="highlight plaintext"><figcaption><span>[完全背包] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line">int n,m,v[N],w[N],f[N][N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">    f[i][j]=f[i-1][j];</span><br><span class="line">    if(j&gt;=v[i]) f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全背包一维就非常简单了 从v[i]开始枚举 不用倒序 把第一维删掉即可</p><figure class="highlight plaintext"><figcaption><span>[完全背包一维] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line">int n,m,v[N],w[N],f[N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    for(int j=v[i];j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[j]=f[j];</span><br><span class="line">        f[j]=max(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们其实就能发现 一维的话 貌似除了枚举部分 其它都一样？？</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01背包(超详细透彻の基础铺垫)</title>
      <link href="/2023/02/22/%E7%AE%97%E6%B3%95-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2023/02/22/%E7%AE%97%E6%B3%95-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>01背包是重中之重 是其它所有背包的铺垫<br>01背包 n种物品 每种只有一个<br>完全背包 n种物品 每种无限个<br>多重背包 n种物品每种个数不一样</p><p>f[i][j]  下标0到i的物品任取 放到容量为j的背包里</p><p>01背包 每种物品仅有一件 可以选择放或者不放<br>只考虑第i件物品<br>1.如果体积超了 那么一定就是f[i-1][j]<br>2.如果不放 容量价值不变 转化为前i-1件物品放入容量为j的背包最大价值f[i-1][j]<br>3.放了之后 容量减重量 价值增加f[i-1][j-w[i]]+v[i]<br>max(f[i-1][j],f[i-1][j-w[i]]+v[i])就是对于第i件物品的最优解</p><p>f数组的初始化<br>f[i][j]<br>对应表格如下<br>       0 1 2 3 4<br>     0 a b c d e<br>     1 f g h i j<br>     2 k l m n o    </p><p>i即f[1][3]<br>由递推公式 一定是由左上角递推得到的 那么第一列第一行一定要初始化<br>背包容量为0 价值一定为0 所以第一列初始化为0<br>除此之外b一定要初始化为0 不然递推会出错 其它的非0下标不用初始化 均会被覆盖</p><figure class="highlight plaintext"><figcaption><span>[01背包二维] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1010;</span><br><span class="line">int n,m;</span><br><span class="line">int v[N],w[N];</span><br><span class="line">int f[N][N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; //注意由表格 物品从1开始遍历 体积从0 </span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=f[i-1][j];</span><br><span class="line">            if(j&gt;=v[i])  f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.f[j]与f[i][j]中j意思相同 表示容量为j的背包能装的最大价值<br>2.二维中递推公式是max(f[i-1][j],f[i-1][j-w[i]]+v[i]) 放与不放取最大值<br>在二维中不放物品是f[i-1][j] 则在一维中 不放物品 重量没变化 价值也没变化 就直接将上一层数据拷贝下来没有变化 所以还是f[j]<br>如果放物品 那么一维中需要把重量减下去 价值加上  则是f[j-w[i]]+v[i]</p><p>为什么从v[i]开始？<br>因为物品体积大了肯定装不了 那么重量价值无变化 直接拷贝</p><p>为什么二维不用倒序 一维必须倒序呢?<br>例如你现在背包容量为10 g[10] 有一个重量6 价值9的东西<br>如果不装 例 g[10]&#x3D;g[10] 因为还是取的之前的值 左边是现在更新的 右边是上一轮循环的<br>如果装 g[4]+9  这时候便是对应f[i-1][j-v[i]]+w[i] 此时的g[4]便是上一个循环里的g[4]<br>但如果从前往后循环 在你给g[10]赋值之前 g[4]已经更新了！ g[4]状态不同步 g[4]一定偏差了</p><figure class="highlight plaintext"><figcaption><span>[01背包一维优化内存] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1010;</span><br><span class="line">int n,m;</span><br><span class="line">int v[N],w[N];</span><br><span class="line">int f[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=m;j&gt;=v[i];j--) </span><br><span class="line">        &#123;</span><br><span class="line">            //f[j]=f[j]; 恒等变换后是恒等式可省略</span><br><span class="line">            f[j]=max(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl; //优化成一维了当然是f[m]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双指针例题</title>
      <link href="/2023/02/16/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E4%BE%8B%E9%A2%98/"/>
      <url>/2023/02/16/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E4%BE%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不能小瞧双指针 有时候十分重要</p><figure class="highlight plaintext"><figcaption><span>[模板] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0,j=0; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    while(j&lt;i&amp;&amp;check(i,j) j++) </span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line">直接可以替代for i 循环</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最简单情况 将几个词分别输出<br>例abc def ghi</p><figure class="highlight plaintext"><figcaption><span>[例1] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char str[1000];</span><br><span class="line">    gets(str);</span><br><span class="line">    int n=strlen(str);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int j=i;</span><br><span class="line">        while(j&lt;n &amp;&amp; str[i]!=&#x27; &#x27;) j++; </span><br><span class="line">        for(int k=i;k&lt;j;k++) cout&lt;&lt;str[k]; //输出两指针之间的就行了</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[最长连续不重复子序列] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=10010;</span><br><span class="line">int a[N],s[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    int ans=0;</span><br><span class="line">     for(int i=0,j=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[a[i]]++;  //i是在j之后 从后往前的</span><br><span class="line">        while(s[a[j]]&gt;1) //此处不用j&lt;=i 因为一直有重复的话 i j最终在同一位置</span><br><span class="line">        &#123;</span><br><span class="line">            s[a[j]]--; </span><br><span class="line">            j++;//有重复 j往前移一格 有点像队列</span><br><span class="line">        &#125;</span><br><span class="line">        ans=max(i-j+1,ans); //更新长度</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要根据时间由小到大排列<br>注意对应的是什么还有答案输出</p><figure class="highlight plaintext"><figcaption><span>[acwing1238] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100010;</span><br><span class="line">pair&lt;int, int&gt; logs[N];</span><br><span class="line"></span><br><span class="line">int cnt[N];</span><br><span class="line"></span><br><span class="line">int  st[N];</span><br><span class="line">int n,d,k;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;d&gt;&gt;k;</span><br><span class="line">for(int i=0;i&lt;n;i++) cin&gt;&gt;logs[i].first&gt;&gt;logs[i].second;</span><br><span class="line">sort(logs,logs+n); //时间小到大 </span><br><span class="line">for(int i=0,j=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cnt[logs[i].second]++;</span><br><span class="line">while(logs[i].first - logs[j].first&gt;=d)</span><br><span class="line">&#123;</span><br><span class="line">cnt[logs[j].second]--;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">if(cnt[logs[i].second]&gt;=k) st[logs[i].second]=1;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(st[i]) cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>unordered_set</title>
      <link href="/2023/02/15/%E7%AE%97%E6%B3%95-unordered-set/"/>
      <url>/2023/02/15/%E7%AE%97%E6%B3%95-unordered-set/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>unordered_set<int> set1; 构造<br>unordered_set<int> set2(set1); 拷贝构造<br>set1.count(2); 出现次数<br>unordered_set 无序 set 容器可以和字符串哈希有着类似的作用 也可以一起用</p><p>例题acwing1460</p><figure class="highlight plaintext"><figcaption><span>[unordered_set做法] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">int n,l,r;</span><br><span class="line"></span><br><span class="line">bool check(int mid)</span><br><span class="line">&#123;</span><br><span class="line">unordered_set&lt;string&gt; hash; </span><br><span class="line">for(int i=0;i+mid-1&lt;str.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">auto s1=str.substr(i,mid);</span><br><span class="line">if(hash.count(s1)) return false; //查找出现次数 如果重复直接寄</span><br><span class="line">hash.insert(s1);</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">l=1,r=n;</span><br><span class="line">while(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">int mid=(l+r)&gt;&gt;1;</span><br><span class="line">if(check(mid)) r=mid;</span><br><span class="line">else l=mid+1; </span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串前缀哈希</title>
      <link href="/2023/02/15/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%93%88%E5%B8%8C/"/>
      <url>/2023/02/15/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>字符串前缀哈希<br>当遇到如比较两个区间内的字符是否相同时 可以用这种方法 十分快速</p><p>此方法精髓在于用数来表示哈希值 便于理解与记忆 用P&#x3D;10即十进制来理解<br>如1234<br>h[0]&#x3D;0  注意从h[1]开始存 不然A为0 算下去AA也为0 所以从1开始<br>h[1]&#x3D;h[0]<em>P+str[1]&#x3D;0</em>10+1&#x3D;1<br>h[2]&#x3D;h[1]<em>P+str[2]&#x3D;1</em>10+2&#x3D;12<br>h[3]&#x3D;h[2]<em>P+str[3]&#x3D;12</em>10+3&#x3D;123<br>h[4]&#x3D;h[3]<em>P+str[4]&#x3D;123</em>10+4&#x3D;1234</p><p>若求一个区间 如L&#x3D;3 R&#x3D;4 即34<br>则是 1234-12*10^2<br>即 h[4]-h[2]*P^2<br>即L到R之间的哈希值为 h(R)-h(L-1)*P^(R-L+1) 题里这个P的次方用数组p[]存 需要初始化一下<br>P一般取131</p><p>防止长度过长本需mod Q<br> unsigned long long来存储h 它可以溢出 溢出时就相当于模了一个2的64次方</p><figure class="highlight plaintext"><figcaption><span>[字符串前缀哈希法] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef unsigned long long ULL;</span><br><span class="line">const int N=100010,P=131;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">char str[N];</span><br><span class="line">ULL h[N],p[N];//h[]存某个前缀的哈希值 p[]存是多少次方</span><br><span class="line"></span><br><span class="line">ULL get(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    return h[r]-h[l-1]*p[r-l+1]; //本来h[r]的高位更大</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;str+1;</span><br><span class="line">    p[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=p[i-1]*P; //这一步一定要理解</span><br><span class="line">        h[i]=h[i-1]*P+str[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        int l1,r1,l2,r2;</span><br><span class="line">        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;</span><br><span class="line"></span><br><span class="line">        if(get(l1,r1)==get(l2,r2)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">        else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一般比较字符串就用这个方法</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛寒5补题</title>
      <link href="/2023/02/02/%E7%AE%97%E6%B3%95-%E7%89%9B5/"/>
      <url>/2023/02/02/%E7%AE%97%E6%B3%95-%E7%89%9B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>A题贪心二分前缀和<br>可以直接upper_bound(x)找到大于x的第一个数的下标再减一<br>自己感觉还是板子好用</p><figure class="highlight plaintext"><figcaption><span>[A] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long n,q,a[100010],v[100010],ans;</span><br><span class="line">long long k,x,m;</span><br><span class="line">long long check(long long x1 ) //升序 找到小于等于x的第一个下标</span><br><span class="line">&#123;</span><br><span class="line">    long long l=0,r=n;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        long long mid=(l+r+1)/2;</span><br><span class="line">        if(v[mid]&lt;=x1) l=mid;</span><br><span class="line">        else r=mid-1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i];</span><br><span class="line">    sort(v+1,v+n+1);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) a[i]=a[i-1]+v[i]; //前缀和一下 sort升序</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    while(q--)</span><br><span class="line">    &#123;</span><br><span class="line">         </span><br><span class="line">        cin&gt;&gt;k&gt;&gt;x; </span><br><span class="line">        m=check(x);</span><br><span class="line">        if(m-k&lt;=0) ans=a[m];</span><br><span class="line">        else  ans=a[m]-a[m-k];</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;    </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B题难点:读懂题<br>字典序比较就是从左往右的第一个<br>所以最优的就是每个人拿一个石子放空的格子<br>如果是偶数 大家都是这么多格子 平手<br>如果是奇数 先手多拿了一个 那么后手必胜</p><p>C题 贪心<br>长度一样只要两个串完全一样肯定是等于<br>而如1234和1243 我们只要找到第一个不一样的数 其大小关系随映射关系而变化</p><p>经典错解就是长度一样长的一定大<br>如11444和222 如果1-&gt;0 2-&gt;3 4-&gt;1 则变成了00111和333 由于前导0的存在 长的不一定大 主要矛盾就是这</p><p>解决方法就是找到让长的不一定大的方法<br>若长度分别为nx,,ny 相差nx-ny 若x的前n个数映射后有一个不为0 那么肯定x大<br>所以我们可以假设前n个数映射后都是0 再比较后面的<br>那么我们就根据前导零分类讨论找一定大于和一定小于两种情况<br>其它的都是！</p><figure class="highlight plaintext"><figcaption><span>[C] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string a, b;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cout.tie(NULL);</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">     </span><br><span class="line">    char ans = &#x27;&gt;&#x27;;//假定a更大</span><br><span class="line">    if(a.length() &lt; b.length())&#123;</span><br><span class="line">        ans = &#x27;&lt;&#x27;;//如果a更短，则为小于号</span><br><span class="line">        swap(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    int n = a.length();</span><br><span class="line">    int m = b.length();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    if(a == b) &#123;//相等就一定相等</span><br><span class="line">        cout &lt;&lt; &quot;=&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    if(n == m)&#123;//长度相等，但两者不等一定不确定答案</span><br><span class="line">        cout &lt;&lt; &quot;!&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //因为排列不同，数字间的大小就变的无意义，在一个排列下大于的是小于，另一种排列大于的还是大于</span><br><span class="line">    //长度不同，若无前导0则一定是长的大，所以我们假设a前面全是前导0最坏情况，看是否有可能 长的数 &lt;= 短的数</span><br><span class="line">    int id1 = 0;</span><br><span class="line">    for(int i = 1; i &lt; n; i ++)&#123;</span><br><span class="line">        if(a[i] == a[0]) id1 = i;</span><br><span class="line">        else break ;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //因为假设a前面全是前导0，所以若b前面数字相同的也是前导0也不能算</span><br><span class="line">    int id2 = -1;</span><br><span class="line">    for(int i = 0; i &lt; m; i ++)&#123;</span><br><span class="line">        if(b[i] == a[0]) id2 = i;</span><br><span class="line">        else break;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    int len1 = n - id1 - 1;//a最小情况下的有效长度</span><br><span class="line">    int len2 = m - id2 - 1;//b最小情况下的有效长度</span><br><span class="line"> </span><br><span class="line">    if(len1 &gt; len2)&#123;</span><br><span class="line">        cout &lt;&lt; ans;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(len1 == len2)&#123;//因为已经确定a[0]所代表的数字就是最小的0，所以还需要比较一下</span><br><span class="line">        for(int i = 1; i &lt;= len1; i ++)&#123;</span><br><span class="line">            if(a[id1 + i] == b[id2 + i]) continue;</span><br><span class="line">            if(b[id2 + i] == a[0])&#123;</span><br><span class="line">                cout &lt;&lt; ans;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else break;//a可能更小</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else cout &lt;&lt; &quot;!&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设当前答案为num 得到一个区间后 如果左端点在num里 num扩大到其右端点</p><figure class="highlight plaintext"><figcaption><span>[D] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 补题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛寒4补题</title>
      <link href="/2023/01/31/%E7%AE%97%E6%B3%95-%E7%89%9B4/"/>
      <url>/2023/01/31/%E7%AE%97%E6%B3%95-%E7%89%9B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>A题是个数学题<br>就是比较x的y次方和y的x次方哪个大<br>取对数就是ylnx和xlny 直接写代码比较就行</p><figure class="highlight plaintext"><figcaption><span>[A] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    long long  x,y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    double x1=y*log(x);</span><br><span class="line">    double y1=x*log(y);</span><br><span class="line">    if(x1==y1) cout&lt;&lt;min(x,y);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(x1&gt;y1) cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">        else cout&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>L题解方程组 注意题目要的是正整数</p><p>E题<br>将情况分为两类 全死或打不死 只考虑打不死的情况 只要一个怪打不死那么就失败<br>先v[i]<em>&#x3D;t 就是一次加多少血<br>分析可知攻击间隔t</em>恢复速度v[i]若大于等于攻击力a 且一刀没打死 那么永远打不死<br>一开始就检查是否全死<br>如何求花多少时间呢<br>由题意 如果不能秒杀 那么这怪物必定会掉血+回血一次循环 而最后一次攻击 击杀死亡就不会回血<br>一个攻击 回血循环扣的血量 delta&#x3D;a-v (如果此次扣的血量小于等于0 无解)<br>所以我们先把最后一刀放到最前面来算<br>轮数就是这个怪先砍最后一刀剩下的血量除以一次循环扣的血量向上取整 再加1(最后一刀)<br>总时间就是(总轮数-1)*时间间隔+1</p><figure class="highlight plaintext"><figcaption><span>[E] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=100005;</span><br><span class="line">long long n,t,a,ans,h[MAXN],v[MAXN];</span><br><span class="line">bool check()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(v[i]&gt;=a&amp;&amp;h[i]&gt;a)return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">long long f(const long long &amp;h,const long long &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    if(h&lt;=a)return 1;</span><br><span class="line">    long long delta=a-v;</span><br><span class="line">    return ceil( ((h-a)*1.0)/delta)+1;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;t,&amp;a);</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%lld %lld&quot;,&amp;h[i],&amp;v[i]);</span><br><span class="line">        v[i]*=t;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!check())</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;-1&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=f(h[i],v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,(ans-1)*t+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>b题数论大礼包<br>cd是背包问题 日后填坑</p><p>L简单数学题 注意要判断小数的情况</p><figure class="highlight plaintext"><figcaption><span>[L] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long v[10],a[10],sum;</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">long long v1,v2,v3;</span><br><span class="line">cin&gt;&gt;v[0]&gt;&gt;v[1]&gt;&gt;v[2];</span><br><span class="line">sum=(v[0]+v[1]+v[2])/2;</span><br><span class="line">    if(sum*2!=v[0]+v[1]+v[2]) //如果有边不是整数</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;3;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=sum-v[i];</span><br><span class="line">        if(v[i]&lt;=a[i] ||v[i]&lt;=0) break;</span><br><span class="line">        else ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans!=3) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; </span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">        for(int i=0;i&lt;3;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line">while(T--)</span><br><span class="line">&#123;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>M题告诉我们 非传统题样例(specialjudge)可能是骗人的 样例是斐波那契数列 然而并不是<br>只需要一直输出112112112。。就行了</p>]]></content>
      
      
      <categories>
          
          <category> 补题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛寒3补题</title>
      <link href="/2023/01/27/%E7%AE%97%E6%B3%95-%E7%89%9B3%E8%A1%A5%E9%A2%98/"/>
      <url>/2023/01/27/%E7%AE%97%E6%B3%95-%E7%89%9B3%E8%A1%A5%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自己太菜 只过了四道签到题 必须好好补补题</p><p>A题重大教训 没有用long long 浪费了几次提交</p><p>D是博弈题<br>结论是只要是偶数 先手必胜<br>一个奇数的因数一定是奇数 因为如果是偶数 这个偶数与某个整数的乘积一定不会是奇数<br>这个奇数减掉某个因子后 就变成了偶数<br>所以</p><ol><li>偶数总可以变成奇数</li><li>奇数只可以变成偶数</li><li>1是奇数 谁拿到谁就输了<br>综上 总拿到奇数的肯定就输了<br>这道题其实很简单 但是自己没去想过这种博弈问题</li></ol><p>C题是一个构造题<br>构造题也没做过 想不出什么思路呜呜<br>原则是找到有既有一般性又有可行性的方式<br>一般考虑将输入分成几类 再分别构造 以满足所有情况</p><p>实例是3 4 1 2 则可以构造出n&#x3D;4k的所有情况 如n&#x3D;8则有3 4 1 2 7 8 5 6<br>n&#x3D;5时可以构造出4 5 1 2 3 n&#x3D;6时有4 5 6 1 2 3<br>这样 n&#x3D;4k+5 n&#x3D;4k+6 n&#x3D;4k+11分别就是nmod4为1 2 3的情况 就覆盖了基本所有整数<br>但是n&#x3D;7 n&lt;4是肯定无解的需要特判</p><figure class="highlight plaintext"><figcaption><span>[C忽远忽近的距离] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">if(n &lt;= 3 || n==7) </span><br><span class="line">    &#123;</span><br><span class="line">cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n%2==0) //如果是偶数 只有是四的倍数以及其它</span><br><span class="line">    &#123;</span><br><span class="line">        if(n%4==0)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1; i&lt;=n/4; i++) //看是几倍</span><br><span class="line">            &#123;</span><br><span class="line">                int m=i*4;</span><br><span class="line">                cout&lt;&lt;m-1&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;m-3&lt;&lt;&quot; &quot;&lt;&lt;m-2&lt;&lt;&quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else //那么就是6的倍数了</span><br><span class="line">        &#123;</span><br><span class="line">            int p=n-6; //先把最后六个数单独拿出来 把可能的四的倍数用完</span><br><span class="line">            for(int i=1; i&lt;=p/4; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                int m=i*4;</span><br><span class="line">                cout&lt;&lt;m-1&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;m-3&lt;&lt;&quot; &quot;&lt;&lt;m-2&lt;&lt;&quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;n - 2&lt;&lt;&quot; &quot;&lt;&lt;n - 1&lt;&lt;&quot; &quot;&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;n - 5&lt;&lt;&quot; &quot;&lt;&lt;n - 4&lt;&lt;&quot; &quot;&lt;&lt;n - 3&lt;&lt;&quot; &quot;; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">int m = n - 5;</span><br><span class="line">if(m % 4 == 0) //如果拿出最后五个剩下是四的倍数 直接就用了</span><br><span class="line">        &#123;</span><br><span class="line">for(int i = 1;i &lt;= m / 4;i++) </span><br><span class="line">            &#123;</span><br><span class="line">int x = i * 4;</span><br><span class="line">cout&lt;&lt;x-1&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;x-3&lt;&lt;&quot; &quot;&lt;&lt;x-2&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">        &#123;</span><br><span class="line">int mm = m - 6;//一个奇数 减去5 还不是四的倍数 只能是六的倍数了 把最后六个再拿出来 把四的倍数用光</span><br><span class="line">for(int i = 1;i &lt;= mm / 4;i++) </span><br><span class="line">            &#123;</span><br><span class="line">int x = i * 4;</span><br><span class="line">cout&lt;&lt;x-1&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;x-3&lt;&lt;&quot; &quot;&lt;&lt;x-2&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;m - 2&lt;&lt;&quot; &quot;&lt;&lt;m-1&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;m-5&lt;&lt;&quot; &quot;&lt;&lt;m-4&lt;&lt;&quot; &quot;&lt;&lt;m-3&lt;&lt;&quot; &quot;; //输出拿出的6</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;n-1&lt;&lt;&quot; &quot;&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;n-4&lt;&lt;&quot; &quot;&lt;&lt;n-3&lt;&lt;&quot; &quot;&lt;&lt;n-2&lt;&lt;&quot; &quot;; //输出拿出的5</span><br><span class="line">&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慢慢学习这种思考方式</p><p>B题更是闻所未闻了 二分图 感觉很思维<br>主要是不理解为什么那样摆放是最优解? 虽然感觉是正确的<br>1.摆放后解不等式可以直接得答案<br>2.可以二分答案<br>3.把图画出来找规律(12个起步)</p><figure class="highlight plaintext"><figcaption><span>[勉强拼凑的记忆] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">long long i,j,k,n,m,t,l,r,res,md;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">ios::sync_with_stdio(0);</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">if(n==2)</span><br><span class="line">        &#123;</span><br><span class="line">cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">            continue;</span><br><span class="line">&#125;</span><br><span class="line">l=1;r=n;res=0;</span><br><span class="line">i=(n+1)/2;</span><br><span class="line">while(l&lt;=r)&#123;</span><br><span class="line">md=(l+r)/2;</span><br><span class="line">k=(md/i)*md+(md%i)*((md+i-1)/i);  //通过画图得的关系式</span><br><span class="line">if(k&lt;=n)&#123;</span><br><span class="line">res=max(res,md);l=md+1;</span><br><span class="line">&#125;</span><br><span class="line">else r=md-1;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;res&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>E题 高中数学题 向量算算就能得答案</p><p>K题 数学大礼包 考查因字数公式 逆元等<br>H题 dp<br>J题 反悔贪心？<br>留坑</p>]]></content>
      
      
      <categories>
          
          <category> 补题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛寒1补题</title>
      <link href="/2023/01/22/%E7%AE%97%E6%B3%95-%E7%89%9B1%E8%A1%A5%E9%A2%98/"/>
      <url>/2023/01/22/%E7%AE%97%E6%B3%95-%E7%89%9B1%E8%A1%A5%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以后学习这种解题写法<br>一道简单模拟<br>当时卡了一会儿就是因为“当前双方比分已经使得无论之后的罚球结果如何都不会影响比赛的结果”没有转过来 用了一个变量记轮数<br>其实不用  只需要两个新变量记剩下几个球可以进就可以了</p><figure class="highlight plaintext"><figcaption><span>[A模拟点球] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void work()</span><br><span class="line">&#123;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">int a=0,b=0,la=5,lb=5;</span><br><span class="line">for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">if(i%2)&#123;</span><br><span class="line">lb--;</span><br><span class="line">if(s[i]==&#x27;1&#x27;)&#123;</span><br><span class="line">b++;</span><br><span class="line">if(b&gt;a+la)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,i+1);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(a&gt;b+lb)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,i+1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">la--;</span><br><span class="line">if(s[i]==&#x27;1&#x27;)&#123;</span><br><span class="line">a++;</span><br><span class="line">if(a&gt;b+lb)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,i+1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(b&gt;a+la)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,i+1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;-1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int m;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">while(m--)</span><br><span class="line">&#123;</span><br><span class="line">work();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>头一次遇到这种诈骗题 说是dfs 其实不用还原拼图<br>直接总造价&#x3D;给出拼图的造价+确实拼图的造价</p><figure class="highlight plaintext"><figcaption><span>[拼图] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0); </span><br><span class="line">int T; </span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line">while(T--)</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">int ans=10;  </span><br><span class="line">string s;</span><br><span class="line">for(int i=0;i&lt;n*n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">for(int j=0;j&lt;4;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[j]==&#x27;1&#x27;) ans++;</span><br><span class="line">else if(s[j]==&#x27;2&#x27;) ans--;</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"> cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line">return 0;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上就是推数学公式<br>首先得读懂题意 大致就是给了(0,0) (x,y)的一个矩形 给你一个点xp yp作为顶点<br>求这个点与其对角顶点构成的矩形和之前矩形的 交集&#x2F;并集最大<br>实际上就要分类讨论xp yp对于x y的相对位置<br>如果在右上 那么对角顶点肯定是0 0<br>如果在左下 枚举(0,0)(x,y)的四个顶点<br>在左上 枚举(0,0) (x,0)两个顶点<br>在右下 枚举(0,0) (y,0)两个顶点<br>猜结论比较困难感觉</p><figure class="highlight plaintext"><figcaption><span>[学术时间] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int x,y,px,py;</span><br><span class="line"> </span><br><span class="line">void work()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y&gt;&gt;px&gt;&gt;py;</span><br><span class="line">    double ans;</span><br><span class="line">    if(px&lt;=x&amp;&amp;py&lt;=y)ans=1.0*max(&#123;px*py,(x-px)*py,px*(y-py),(x-px)*(y-py)&#125;)/(x*y);</span><br><span class="line">    else if(px&gt;x&amp;&amp;py&gt;y)ans=1.0*x*y/(px*py);</span><br><span class="line">    else if(px&lt;=x)ans=max(1.0*y*px/(x*y+px*(py-y)),1.0*y*(x-px)/(x*y+(x-px)*(py-y)));</span><br><span class="line">    else ans=max(1.0*x*py/(x*y+py*(px-x)),1.0*x*(y-py)/(x*y+(y-py)*(px-x)));</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(0);</span><br><span class="line">    cin.tie(0);cout.tie(0);</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;setprecision(9);</span><br><span class="line">    int _=1;</span><br><span class="line">    cin&gt;&gt;_;</span><br><span class="line">    while(_--)</span><br><span class="line">        work();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面是快读模板<br>当时看到是动态规划就放弃了 学都没学到<br>但是现在看来其实非常巧妙<br>首先满足条件:字符串长为n m个字符为1<br>所以怎么坏区间总数最少呢?<br>那么就是<br>前缀都是100 100 100 这样是好区间<br>把1都堆到最后 这样一个坏区间就占了3个1<br>枚举i 前i个都变成100 100这种 后面全部是1 当前得出坏区间个数和之前答案取小的</p><figure class="highlight plaintext"><figcaption><span>[本题主要考查dp] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;ll, ll&gt; PII;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">inline ll read() &#123;</span><br><span class="line">    char ch;</span><br><span class="line">    ll x = 0;</span><br><span class="line">    bool f = true;</span><br><span class="line">    for (ch = getchar(); !isdigit(ch); ch = getchar())</span><br><span class="line">        if (ch == &#x27;-&#x27;)</span><br><span class="line">            f ^= f;</span><br><span class="line">    for (; isdigit(ch); ch = getchar())</span><br><span class="line">        x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - 48;</span><br><span class="line">    return f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    int n=read(),m=read(),t = n - m;</span><br><span class="line">    vector&lt;int&gt; s;</span><br><span class="line">    while(m || t)&#123;</span><br><span class="line">        if(m)s.push_back(1),m--; </span><br><span class="line">        if(t)s.push_back(0),t--;</span><br><span class="line">        if(t)s.push_back(0),t--;//这三步就巧妙实现了100100..1111</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0 ;</span><br><span class="line">    for(int i=1;i&lt;n-1;i++)</span><br><span class="line">        if(s[i] + s[i-1] + s[i+1] &gt;=2)</span><br><span class="line">            ans ++;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt;&quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int T = 1;</span><br><span class="line">    for (int i = 1; i &lt;= T; i++)</span><br><span class="line">        solve();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此处跳过两道dp 日后填坑</p>]]></content>
      
      
      <categories>
          
          <category> 补题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛寒2补题</title>
      <link href="/2023/01/19/%E7%AE%97%E6%B3%95-%E7%89%9B2%E8%A1%A5%E9%A2%98/"/>
      <url>/2023/01/19/%E7%AE%97%E6%B3%95-%E7%89%9B2%E8%A1%A5%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一题和第二题只是数据不同<br>第一题可以通过a+b&#x3D;n 不枚举第二个区间 直接把b算成n-a就能过<br>第二题只要有枚举那么必超时 所以肯定是推式子<br>可知答案是取[L2,R2] [n-R1,n-L1]的交集<br>求交集有固定写法<br>这个交集就是[max(L2,n-R1),min(R2,n-L1)]<br>当然可能没有交集 所以最后要和0max一下</p><figure class="highlight plaintext"><figcaption><span>[a+b=n] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,l1,r1,l2,r2,a;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0); </span><br><span class="line">    int a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    while(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        int tot=0;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        cin&gt;&gt;l1&gt;&gt;r1;</span><br><span class="line">        cin&gt;&gt;l2&gt;&gt;r2;</span><br><span class="line">        l1=max(l1,n-r2);</span><br><span class="line">        r1=min(r1,n-l2);</span><br><span class="line">        tot=max(0,r1-l1+1);</span><br><span class="line">        cout&lt;&lt;tot&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>j题是个奇怪的思维题 结论就是2n*(abs(a1)+abs(a2)+….+abs(an))<br>是通过数轴上分类讨论知道的</p><figure class="highlight plaintext"><figcaption><span>[j] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void work()</span><br><span class="line">&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    LL ans=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int m;</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        ans+=n*std::abs(m);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans*2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    int T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>H题 萌新必学题?<br>集训2最妙的一道题</p><p>单独考虑算贡献</p><p>不同种类数之间单独考虑如1111223<br>若2 3已放只考虑1的放法 2和3对答案的贡献是不会变的</p><p>那么我们假设只考虑1 1出现了x次 要分成k个子序列<br>贡献最大的情况便可以分类讨论一下 </p><p>就是x&gt;k时 前k-1个子序列都放一个1 剩下的都放到最后一个子序列 这样就贡献了k-1<br>若x&lt;&#x3D;k 那么每个子序列放一个1就行了 总共为答案贡献了x </p><p>知道以上信息 若k是定值 就可以做了<br>但是题目要求输出k为1到n的所有情况 所以还需要特殊处理</p><p>若从k&#x3D;n开始减 若k一直大于等于最大的每个数出现的个数x(某个)时 贡献就是每个数的x相加 这不会变<br>变化的情况就是k&#x3D;x(max)-1<br>那么我们用一个set集合存这个变化的贡献</p><figure class="highlight plaintext"><figcaption><span>[h] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int T,n,a[100010],c[100010];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        memset(c,0,sizeof(c));</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">            c[a[i]]++;  </span><br><span class="line">        &#125;</span><br><span class="line">        multiset&lt;int&gt;st; //不会去掉重复元素的集合 存每种数的x(出现次数)</span><br><span class="line">        for(int i=1;i&lt;=100000;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            st.insert(c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        long long lesum=0,ge=((int)st.size());</span><br><span class="line">        // ge存有多少种数的出现次数大于k</span><br><span class="line">        for(int i=1;i&lt;=n;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            while(!st.empty()&amp;&amp;*st.begin()&lt;=i) </span><br><span class="line">            &#123;</span><br><span class="line">                lesum+=(long long)(*st.begin()); </span><br><span class="line">                // 若这个数的出现次数小于等于k 那么这个数的贡献就是出现次数</span><br><span class="line">                st.erase(st.begin());</span><br><span class="line">                ge--; //</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;lesum+ge*(i-1)&lt;&lt;endl; //对于这个k 总贡献就是lesum与剩下的数的贡献之和 剩下的这些数的出现次数都大于k 所以每种数的贡献都是k-1</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d题是一个树的dfs<br>是用到了一个经典但我没见过的结论 两个向量内部允许任意重排 点积最大为升序排列</p><p>也就是深度序列由小向大排列 能量值序列由小向大排列 相乘相加</p><p>那么剩下就是如何求每个节点的深度了 便用dfs</p><figure class="highlight plaintext"><figcaption><span>[h] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,fa[200010];</span><br><span class="line">vector&lt;int&gt; g[200010];</span><br><span class="line">long long v[200010],dep[200010];</span><br><span class="line">void dfs(int now,int d) //求每个节点的depth</span><br><span class="line">&#123;</span><br><span class="line">    dep[now]=d;</span><br><span class="line">    for(auto to:g[now])</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(to,d+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;fa[i];</span><br><span class="line">        g[fa[i]].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i];</span><br><span class="line">    dfs(1,1);</span><br><span class="line">    sort(v+1,v+1+n);</span><br><span class="line">    sort(dep+1,dep+1+n);</span><br><span class="line">    long long ans=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=dep[i]*v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 补题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树和图的优先遍历</title>
      <link href="/2023/01/08/%E7%AE%97%E6%B3%95-%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
      <url>/2023/01/08/%E7%AE%97%E6%B3%95-%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>tips:树是一种特殊的图 是无环连通图</p><p>有向图边有方向 如a-&gt;b<br>无向图边没有方向 a&lt;-&gt;b<br>无向图是特殊的有向图 我们就先理解有向图的储存</p><p>1.邻接矩阵 其实就是一个二维数组 g[a][b]就存储a-&gt;b 有权重就是权重 没有就是bool值表示有无边 邻接矩阵不能有重边 只能保留一条 这个比较浪费空间</p><p>2.邻接表 就是n个节点 每个都开单链表 就跟哈希拉链法一样</p><figure class="highlight plaintext"><figcaption><span>[树的存储] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=10010,M=N*2;</span><br><span class="line"></span><br><span class="line">int h[N],e[N],ne[N];  //h链表头 e节点的值 ne指每个节点的next指针 与之前的单链表一样</span><br><span class="line"></span><br><span class="line">void add(int a, int b) //添加一条边a-&gt;b</span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=b; //新用到的节点值为b</span><br><span class="line">    ne[idx]=h[a];//这个节点的next指针指向a所在点的链表原本的头结点</span><br><span class="line">    h[a]=idx; //更新头节点</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    memset(h,-1,sizeof h); //和单链表head初始化-1一样 现在把所有链表都初始化</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[树的重心(dfs用法)] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=10010,M=N*2;</span><br><span class="line">bool st[N]; //存有没有遍历过</span><br><span class="line"></span><br><span class="line">int h[N],e[N],ne[N]; </span><br><span class="line"></span><br><span class="line">void add(int a, int b) </span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=b; </span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx; </span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    memset(h,-1,sizeof h); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    st[u]=true;</span><br><span class="line"></span><br><span class="line">    for(int i=h[u];i!=-1;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        int j=e[i]; </span><br><span class="line">        if(!st[j]) dfs(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>stl 2.0</title>
      <link href="/2023/01/06/%E7%AE%97%E6%B3%95-stl2-0/"/>
      <url>/2023/01/06/%E7%AE%97%E6%B3%95-stl2-0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>系统为某一个程序分配空间时,所需时间基本与空间大小无关,与申请次数有关<br>例 vector最开始就分配了32位空间 不够时再申请64的空间 将之前的copy过来<br>实际上是一个倍增的思想</p><figure class="highlight plaintext"><figcaption><span>[vector与pair] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; a(10); //定义长度为10的vector</span><br><span class="line">vector&lt;int&gt; b(10,3); //长度为10且初始化为3的vector</span><br><span class="line"></span><br><span class="line">a.size();//a元素个数 所有容器都有 时间复杂度O(1)</span><br><span class="line">a.empty();//返回是否为空</span><br><span class="line">a.clear(); //清空 注意队列没有clear</span><br><span class="line">a.front();//首位</span><br><span class="line">a.back();//末位</span><br><span class="line">push_back(); //末尾添加</span><br><span class="line">pop_back(); //删掉最后一个数</span><br><span class="line">a.erase(a.begin()+2); //删除第3个元素</span><br><span class="line">a.insert(a.begin()+i,b); //在第i+1个元素前面插入b;</span><br><span class="line">begin() end() //迭代器 前者就是a[0] 后者是最后一个数后面的一个数a[a.size]</span><br><span class="line">[] //可以和数组一样</span><br><span class="line"></span><br><span class="line">//推荐的遍历方式</span><br><span class="line">1. for(int i=0;i&lt;a.size;i++) cout&lt;&lt;a[i];</span><br><span class="line">2. for(auto x:a) cout&lt;&lt;x;</span><br><span class="line"></span><br><span class="line">//常用于多属性 排序 等于一个结构体</span><br><span class="line">pair&lt;int string&gt; p; //定义 中间两个类型参考要求</span><br><span class="line"></span><br><span class="line">//也可以存三个属性</span><br><span class="line">pair&lt;int,pair&lt;int,int&gt;&gt;p2;</span><br><span class="line"></span><br><span class="line">p.first; //一对pair中第一个元素</span><br><span class="line">p.second;</span><br><span class="line">p=&#123;20,&quot;abc&quot;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用字符数组存不方便 string方便</p><figure class="highlight plaintext"><figcaption><span>[string] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string a=&quot;abc&quot;;</span><br><span class="line">a+=&quot;def&quot;; //可以直接这么加</span><br><span class="line"></span><br><span class="line">string b=a.substr(1,2); //从下标为1的元素开始截取长度为2的字串 此处就是bc</span><br><span class="line">//如果长度超过了 那么就输出到最后一个字符为止</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>queue 队列 先进先出</p><figure class="highlight plaintext"><figcaption><span>[队列] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queue 队列</span><br><span class="line">push() 队尾插入</span><br><span class="line">pop() 弹出队头元素</span><br><span class="line">front()</span><br><span class="line">back()</span><br><span class="line">//注意没有队列clear函数 可以直接</span><br><span class="line">queue&lt;int&gt;q;</span><br><span class="line">q=queue&lt;int&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>priority queue 优先队列 就是堆</p><figure class="highlight plaintext"><figcaption><span>[优先队列] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;int&gt; heap; //一定要注意 优先队列默认大根堆</span><br><span class="line"></span><br><span class="line">heap.push(-x); // 想弄小根堆 都插负数就行了</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q1; //或者这样</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>栈和之前的基本一致 该有的都有</p><figure class="highlight plaintext"><figcaption><span>[栈] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push() //向栈顶插入一个元素</span><br><span class="line">top() //返回栈顶元素</span><br><span class="line">pop() //弹出栈顶元素</span><br><span class="line">size...empty...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>双端队列deque 之前没怎么见过<br>是一种在两端均可以扩展或者收缩的序列化容器 可以在头部和尾部进行插入和删除操作<br>就是个升级版vector 缺点是速度较慢</p><figure class="highlight plaintext"><figcaption><span>[deque] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size..empty...clear...</span><br><span class="line">push_back()/pop_back() </span><br><span class="line">push_front()/pop_front() //头尾插入删除</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有时可能出现需要去掉重复元素的情况 而且有可能因这些元素比较大或者类型不是int型而不能直接开散列表 在这种情况下就可以用set来保留元素本身而不考虑它的个数<br>就相当于集合</p><figure class="highlight plaintext"><figcaption><span>[set/multiset] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt;S; //set里不会有重复元素 插入重复元素的操作会被忽略</span><br><span class="line">multiset&lt;int&gt;Q; //可以有重复元素</span><br><span class="line">size()..empty()</span><br><span class="line">insert() //插入</span><br><span class="line">find() 查找一个数 不存在返回end迭代器</span><br><span class="line">count() 返回某个数的个数</span><br><span class="line">erase()</span><br><span class="line">      (1) 输入一个数x 删除所有x    O(k+logn)</span><br><span class="line">      (2) 输入一个迭代器,删除这个迭代器(针对有重复元素的multiset)</span><br><span class="line">lower_bound(x) 返回大于等于x的最小的数的迭代器</span><br><span class="line">upper_bound(x) 返回大于x的最小的数的迭代器 如果没有返回end迭代器</span><br><span class="line">例子</span><br><span class="line">int a[] = &#123;1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4&#125;;</span><br><span class="line">cout &lt;&lt; (lower_bound(a, a + 12, 4) - a) &lt;&lt; endl;//输出9即第一个大于等于4的数的下标</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>map参考stl.map</p>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希散列表</title>
      <link href="/2023/01/05/%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E6%95%A3%E5%88%97%E8%A1%A8/"/>
      <url>/2023/01/05/%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E6%95%A3%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>将-10^9-10^9的数指向0-10^5的数 称为哈希函数<br>一般情况 x mod 10^5<br>但是这个简单方法可能将两个数映射到一个数而冲突</p><p>1.拉链法 如果两条链是冲突的 那么在同一位置用一个链将两个数都存下来<br>2.开放寻址法 (感觉这个简单一点)</p><figure class="highlight plaintext"><figcaption><span>[拉链法模拟散列表] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100003; //模的数是质数且离2的n次方远 冲突概率最小</span><br><span class="line">int h[N];//&quot;给拉链开槽&quot;</span><br><span class="line">int e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line">void insert(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int k= (x%N+N)%N; //c++里负数mod整数是负数 modN再+N再modN就是正的 k就是哈希值</span><br><span class="line">    e[idx]=k; //先把新点值赋好</span><br><span class="line">    ne[idx]=h[k]; //这一点的next指针指向槽里的下一个点</span><br><span class="line">    h[k]=idx;//再让h[k]指向新点</span><br><span class="line">    idx++;</span><br><span class="line">    //插入操作 让新的点的next指针为h[k],让h[k]再指向这个新点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int k=(x%N+N)%N;</span><br><span class="line">    for(int i=h[k];i!=-1;i=ne[i])</span><br><span class="line">        if(e[i]=x)</span><br><span class="line">            return true;</span><br><span class="line">        else return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    memset(h,-1,sizeof h); //清空</span><br><span class="line">    while(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        char op[2];</span><br><span class="line">        int x;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">        if(*op==&#x27;I&#x27;) insert(x);</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(find(x)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">            else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开放寻址法不用开链表 但是一维数组开的长度要是题目的三倍<br>添加操作:先算k 从数组中第k个开始找 找到第一个空的就填<br>查找操作: 也是从第k位开始找 如果有数 对比是不是k 不是就找下一个 如果找到空就不存在<br>删除(不常用): 查找到后bool标记</p><figure class="highlight plaintext"><figcaption><span>[开放寻址法模拟散列表] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=200003; //需要开两到三倍</span><br><span class="line">const int null=0x3f3f3f; //在数据之外的一个数 表示此位置无数</span><br><span class="line">int h[N];</span><br><span class="line">int e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line">bool find(int x) </span><br><span class="line">&#123;</span><br><span class="line">    int k=(x%N+N)%N;</span><br><span class="line">    </span><br><span class="line">    while(h[k]!=null&amp;&amp;h[k]!=x) //如果这个位置有数 且不等于x 就下个位置</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        if(k==N) k=0; //如果直到最后也没找到 从0开始循环</span><br><span class="line">    &#125;</span><br><span class="line">    return k; //如果存在返回下标 不然返回应该存储的位置的下标</span><br><span class="line">              //所以如果h[k]=null 那么就说明没有这个数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    memset(h,0x3f,sizeof h); //全初始化为null</span><br><span class="line">    while(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        char op[2];</span><br><span class="line">        int x;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">        if(*op==&#x27;I&#x27;) //插入</span><br><span class="line">        &#123;</span><br><span class="line">            int k=find(x);</span><br><span class="line">            h[k]=x;</span><br><span class="line">        &#125;</span><br><span class="line">        else //查找</span><br><span class="line">        &#123;</span><br><span class="line">            if(h[k]!=null) cout&lt;&lt;&quot;Yes&quot;;</span><br><span class="line">            else cout&lt;&lt;&quot;No&quot;; //如果h[k]是null  所以k不存在</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/2023/01/04/%E7%AE%97%E6%B3%95-%E5%A0%86/"/>
      <url>/2023/01/04/%E7%AE%97%E6%B3%95-%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>就是stl里的优先队列<br>堆是一棵完全二叉树<br>除了最后一层 上面所有节点都是满的 最后一层是从左到右排列</p><p>小根堆 每一个点都小于等于左右子节点的 根节点就是最小值<br>存储<br>根节点是1 x的左儿子是2x 右儿子是2x+1 </p><p>1.插入一个数 heap[++size]&#x3D;x; up[size];<br>2.求集合当中最小值 heap[1]; 根节点就是最小的<br>3.删除最小值 heap[1]&#x3D;heap[size]; size–; down(1); 用尾节点替换最小的堆顶 向下调整<br>4.删除任意一个元素 heap[k]&#x3D;heap[size]; size–; down(k);up(k) &#x2F;&#x2F;不知大小关系<br>5.修改任意一个元素 heap[k]&#x3D;x; down(x);up(x);&#x2F;&#x2F;同理 不知大小关系直接down了在up</p><figure class="highlight plaintext"><figcaption><span>[堆排序] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//思路就是将序列建成堆结构 每一次输出堆顶</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int h[N].size;</span><br><span class="line"></span><br><span class="line">void down(int u) //往下调整 up是往上调整</span><br><span class="line">&#123;</span><br><span class="line">    int t=u;</span><br><span class="line">    if (u*2&lt;=size &amp;&amp; h[u*2]&lt;h[t]) t=u*2;</span><br><span class="line">    if (u*2+1&lt;=size &amp;&amp; h[u*2+1]&lt;h[t]) t=u*2+1; //经过操作t是u和其两个儿子里最小的</span><br><span class="line">    if(u!=t) //如果u不是三个节点里最小的</span><br><span class="line">    &#123;</span><br><span class="line">        swap(h[u],h[t]);</span><br><span class="line">        down(t);//对交换前儿子节点的下标进行递归操作</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void up(int u)</span><br><span class="line">&#123;</span><br><span class="line">    while(u/2 &amp;&amp; h[u/2]&gt;h[u] ) //由于向下取整 两个儿子除二就是父节点</span><br><span class="line">    &#123;</span><br><span class="line">        swap(h[u],h[u/2]);</span><br><span class="line">        u/=2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;h[i];</span><br><span class="line">    size=n;</span><br><span class="line"></span><br><span class="line">    for(int i=n/2;i;i--) down(i);//建堆 二分之n是从倒数第二层开始调整每一个点 保证每一次down的时候下面的两个儿子已经是堆了</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;h[1];//根节点是最小的 将其输出后用尾节点替换 再将尾节点删除 递归down</span><br><span class="line">        h[1]=h[size];</span><br><span class="line">        size--;</span><br><span class="line">        down(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>I x 插入一个数x<br>PM 输出当前集合中最小值<br>DM 删除当前集合最小值(不唯一时删除最早插入的)<br>D k 删除第k个插入的数<br>C k x 修改第k个插入的数为x</p><figure class="highlight plaintext"><figcaption><span>[模拟堆] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int h[N],size;</span><br><span class="line">int ph[N],hp[N]; //ph[k]存第k个插入的数的下标 hp[q]存堆中下标为q的 点是第几个插入的点 ph与hp是类似于反函数的关系</span><br><span class="line"></span><br><span class="line">//因为要准确知道第k个数 手写维护映射关系比较麻烦 直接新定义个swap</span><br><span class="line">void heap_swap(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    swap(ph[hp[a]],ph[hp[b]]); //a b是第a1 b1个插入的点 将第a1 b1个插入的数的下标交换</span><br><span class="line">    swap(hp[a],hp[b]);</span><br><span class="line">    swap(h[a],h[b]); //交换值</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void down(int u)</span><br><span class="line">&#123;</span><br><span class="line">    int t=u;</span><br><span class="line">    if (u*2&lt;=size &amp;&amp; h[u*2]&lt;h[t]) t=u*2;</span><br><span class="line">    if (u*2+1&lt;=size &amp;&amp; h[u*2+1]&lt;h[t]) t=u*2+1;</span><br><span class="line">    if(u!=t) </span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u,t);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void up(int u)</span><br><span class="line">&#123;</span><br><span class="line">    while(u/2 &amp;&amp; h[u/2]&gt;h[u] ) </span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(h[u],h[u/2]);</span><br><span class="line">        u/=2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m=0; // m表示第k个插入的数</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        char op[10];</span><br><span class="line">        int k,x;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        if(!strcmp(op,&quot;I&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            size++;</span><br><span class="line">            m++;</span><br><span class="line">            ph[m]=size,hp[size]=m;</span><br><span class="line">            h[size]=x;</span><br><span class="line">            up(size); //插入是插到最后嘛 由下而上ip</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!strcmp(op,&quot;PM&quot;)) cout&lt;&lt;h[1];</span><br><span class="line">        else if(!strcmp(op,&quot;DM&quot;)) //删除堆顶</span><br><span class="line">        &#123;</span><br><span class="line">            heap_swap(1,size);</span><br><span class="line">            size--;</span><br><span class="line">            down(1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!strcmp(op,&quot;D&quot;)) //删除第k个插入的元素</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            k=ph[k]; //第k个插入的数的下标</span><br><span class="line">            heap_swap(k,size);</span><br><span class="line">            size--;</span><br><span class="line">            down(k),up(k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else //修改第k个插入的数</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            k=ph[k];</span><br><span class="line">            h[k]=x;</span><br><span class="line">            down(k),up(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实一般遇不到有这种映射关系的堆 只需普通up down就行了<br>但是这是为之后搜索内容做铺垫</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Trie树</title>
      <link href="/2023/01/02/%E7%AE%97%E6%B3%95-Trie/"/>
      <url>/2023/01/02/%E7%AE%97%E6%B3%95-Trie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一个用来高效存储与查找字符串集合的数据结构<br>注意要标记每个字符串的结尾</p><figure class="highlight plaintext"><figcaption><span>[Trie树] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bit/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const ing N=100010;</span><br><span class="line"></span><br><span class="line">int sun[N][26],cnt[N],idx;    </span><br><span class="line"> //每一个节点最多26个边 子节点就设置26 cnt表示以当前这个点结尾的词有多少个 idx表示当前用到了哪个下标 下标为0 既是根节点 又是空节点</span><br><span class="line"></span><br><span class="line">//插入</span><br><span class="line"> void insert(char str[])</span><br><span class="line"> &#123;</span><br><span class="line">    int p=0;</span><br><span class="line">    for(int i=0;str[i];i++) //c++字符串结尾为/0</span><br><span class="line">    &#123;</span><br><span class="line">        int u=str[i]-&#x27;a&#x27;; 将a-z映射为0-25</span><br><span class="line">        if(!son[p][u]) son[p][u]=++idx; //如果遍历到的该字母未出现过，开辟新空间存储该字母</span><br><span class="line">        p=son[p][u]; //无论之前有无此子节点 现在反正是有了 就移动过去</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++; //每插入一次字符串，用cnt[p]将该单词出现的次数+1</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">//查询</span><br><span class="line">int query(char str[]) </span><br><span class="line">&#123;</span><br><span class="line">    int p=0;</span><br><span class="line">    for(int i=0;syr[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u=str[i]-&#x27;a&#x27;;</span><br><span class="line">        if(!son[p][u]) return 0;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[最大异或对] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kmp字符串</title>
      <link href="/2023/01/01/%E7%AE%97%E6%B3%95-kmp%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/01/01/%E7%AE%97%E6%B3%95-kmp%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如果是朴素做法 暴力循环</p><figure class="highlight plaintext"><figcaption><span>[字符串暴力循环] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s[N],p[N];</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    bool flag =true;</span><br><span class="line">    for(int j=1;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if s[i]!=p[i] flag=false;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现匹配慢就是因为回溯的步骤太多了 所以要优化<br>代码不好理解 但是原理简单<br>首先得知道最长前缀和最长后缀怎么求<br>我们发现匹配慢就是因为回溯的步骤太多了</p><figure class="highlight plaintext"><figcaption><span>[升级算法] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=10010，M=10010；</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">char p[N],s[M];</span><br><span class="line">int ne[N];//定义next[N]概率性报错</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1;  注意 都是从1开始存的 方便操作</span><br><span class="line">    //求ne[N]过程 </span><br><span class="line">    for(int i=2,j=0;i&lt;=n;i++)   //ne[1]=0 第一个元素肯定最长相等前后缀为0</span><br><span class="line">    &#123;</span><br><span class="line">        while(j&amp;&amp;p[i]!=p[j+1]) j=ne[j];</span><br><span class="line">        if(p[i]==p[j+1]) j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    //kmp匹配过程</span><br><span class="line">    for(int i=1,j=0;i&lt;=m;i++) </span><br><span class="line">    //从i=1开始从原字符串第一个字符遍历 试图与s[i]匹配的是p[j+1]</span><br><span class="line">    &#123;</span><br><span class="line">        while(j&amp;&amp;s[i]!=p[j+1]) j=ne[j]; </span><br><span class="line">        //ne[j]是 字串下标j与j之前的元素 的最长相等前后缀</span><br><span class="line">        // j=0则代表重新匹配 只要j不退回起点 且匹配不成功时 j回溯到ne[j] 此时子串j与j之前的元素是和原字符串相同的 继续比较i与j+1</span><br><span class="line">        if(s[i]==p[j+1]) j++; 如果下一个相同 继续操作</span><br><span class="line">        if(j==n) //如果完全符合</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;i-n;//输出匹配位置</span><br><span class="line">            j=ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子<br>下标 1  2  3  4  5  6  7  8<br>s&#x3D;   a  b  a  b  a  b  c<br>p&#x3D;   a  b  a  b  a  b  a  b<br>i    1  2  3  4  5  6  7  8<br>j+1  1  2  3  4  5  6  7  8<br>ne[]&#x3D;0  0  1  2  3  4  5  6</p><p>首先下标为1均是a 所以i++ j++<br>这么比较下去 当i&#x3D;7时 不相等了<br>此时j&#x3D;6 ne[6]&#x3D;4 所以j回溯到4 j+1为5<br>s&#x3D;   a  b  a  b  a  b  c<br>p&#x3D;               a  b  a  b  a  b  a  b<br>接着继续相同操作</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/2022/12/31/%E7%AE%97%E6%B3%95-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2022/12/31/%E7%AE%97%E6%B3%95-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>栈 先进后出 就像一个桶一样 先进的到栈底 最后进的是栈顶<br>队列 先进先出</p><figure class="highlight plaintext"><figcaption><span>[模拟栈] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">略</span><br><span class="line">const int N=100010;</span><br><span class="line"></span><br><span class="line">int stk[N],tt; tt表示栈顶下标</span><br><span class="line">//插入</span><br><span class="line">stk[++tt] =x;</span><br><span class="line"></span><br><span class="line">//弹出</span><br><span class="line">tt--；</span><br><span class="line"></span><br><span class="line">//判断栈是否为空</span><br><span class="line">if(tt&gt;0) not empty</span><br><span class="line">else empty</span><br><span class="line"></span><br><span class="line">//栈顶</span><br><span class="line">stk[tt];</span><br></pre></td></tr></table></figure><p>单调栈<br>很抽象 类似于删掉逆序的对 最后得到单调的栈<br>单调栈主要解决以下问题：<br>寻找下一个更大元素<br>寻找前一个更大元素<br>寻找下一个更小元素<br>寻找前一个更小元素 诸如此类<br>有点抽象 类似于删掉逆序的对 最后得到单调的栈<br>例 给定一个长为N的整数数列 输入每个数左边第一个比它小的数 不存在则-1</p><figure class="highlight plaintext"><figcaption><span>[单调栈] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100010;</span><br><span class="line"></span><br><span class="line">int n,stk[N],tt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        while(tt&amp;stk[tt]&gt;=x) tt--; //如果栈不为空且栈顶大于当前数 那么栈顶必不是答案了 直接删掉</span><br><span class="line">        if(tt) cout&lt;&lt;stk[tt]&lt;&lt;&quot; &quot;; 如果这样处理了 栈不为空 那么栈顶就是答案</span><br><span class="line">        else cout&lt;&lt;-1&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">        stk[++tt]=x; //记得将新数入栈</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样时间复杂度就超级屌 O(n)</p><figure class="highlight plaintext"><figcaption><span>[模拟队列] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//队尾插入元素 队头弹出元素</span><br><span class="line">int q[N],hh,tt=-1; //hh队头 tt队尾 头在左边便于数组操作</span><br><span class="line"></span><br><span class="line">//插入</span><br><span class="line">q[++tt]=x;</span><br><span class="line"></span><br><span class="line">//弹出</span><br><span class="line">hh++; 队头指针右移一个位置</span><br><span class="line"></span><br><span class="line">//判断是否为空</span><br><span class="line">if(hh&lt;tt) not empty</span><br><span class="line">else empty</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>单调队列经典例题 滑动窗口 求窗口内最小值</p><p>只要前面的数比后面大 前面的数就无用了 只要存在这种逆序对 就删掉大的</p><figure class="highlight plaintext"><figcaption><span>[单调队列] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1000010;</span><br><span class="line">int n,k;</span><br><span class="line">int a[N],q[N]; //数组a存原数列 q存的单调队列下标 注意是下标</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    ios::sync_with_stdio(false)</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    int hh=0,tt=-1;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //判断队头是否划出窗口 直接对比下标就可以了</span><br><span class="line">        if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++; //没有用while 因为每次只移动一次 最多就窗口左边一个位置</span><br><span class="line"></span><br><span class="line">        while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--; //求窗口最小值 若插入的数比队尾小 队尾一定不是答案了 就删去</span><br><span class="line">        q[++tt]=i;//更新右端点 与下一个插入的a[i]比较</span><br><span class="line">        if(i&gt;=k-1) cout&lt;&lt;a[q[hh]];//一开始 元素不满k时不输出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>区间合并</title>
      <link href="/2022/12/28/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
      <url>/2022/12/28/%E7%AE%97%E6%B3%95-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>比较简单的一个小算法 直接上代码</p><figure class="highlight plaintext"><figcaption><span>[区间合并] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt;PII;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line">int nl</span><br><span class="line">vector&lt;PII&gt; segs;</span><br><span class="line">void merge(vector&lt;PII&gt; &amp;segs)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    sort(segs.begin(),segs.end());//由左端点排序</span><br><span class="line">    int st=-2e9,ed=-2e9 //初始化左右端点无穷小</span><br><span class="line">    for(auto seg:segs)</span><br><span class="line">        if(ed&lt;seg.first) //如果当前枚举区间在右边 没有任何交集</span><br><span class="line">        &#123;</span><br><span class="line">            if(st!=-2e9) res.push_back(&#123;st,ed&#125;);//区间不为空且无交集 保存结果 此结果区间判断已结束</span><br><span class="line">            st=seg.first,ed=seg.second;//更新当前维护的区间</span><br><span class="line">        &#125;</span><br><span class="line">        else ed=max(ed,seg.second);//如果有交集 由之前对左端点排过序 只用比较右端点的大小 取大的哪一个到答案中</span><br><span class="line"></span><br><span class="line">        if(st!=-2e9) res.push_back(&#123;st,ed&#125;); //循环结束时st ed是最后一个序列 不需要继续维护了 直接加到res数组里</span><br><span class="line">        segs=res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        segs.push_back(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    merge(segs);</span><br><span class="line">    cout&lt;&lt;segs.size()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>离散化</title>
      <link href="/2022/12/27/%E7%AE%97%E6%B3%95-%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
      <url>/2022/12/27/%E7%AE%97%E6%B3%95-%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>是一种极其特殊的hash方式 必须保序<br>把无限空间中有限的个体映射到有限的空间中去以提高空间效率</p><figure class="highlight plaintext"><figcaption><span>[离散化vector] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; a;//用普通数组也不是不行 操作差不多</span><br><span class="line">sort(a.begin(),a.end()); //将所有元素排序</span><br><span class="line">a.erase(unique(a.begin(),a.end()),a.end()); </span><br><span class="line">//去重 unique非重复的元素在数组开头  erase返回下标到最后中间的元素 就是去重</span><br><span class="line"></span><br><span class="line">int find(int x) //找到第一个大于等于x的位置 当然也可以lower_bound</span><br><span class="line">&#123;</span><br><span class="line">    int l=0,r=a.size()-1;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid=(l+r)&gt;&gt;1;</span><br><span class="line">        if(a[mid]&gt;=x) r=mid;</span><br><span class="line">        else l=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l+1； 储存是从0开始的 加1 元素映射到1到n  不加1就是映射到0到n-1 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为从1开始vector不方便 </p><figure class="highlight plaintext"><figcaption><span>[离散化普通数组] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int lsh[N];</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;lsh[i];</span><br><span class="line">sort(lsh + 1 , lsh + n + 1);//排序</span><br><span class="line">cnt = unique(lsh + 1, lsh + n + 1) - lsh - 1;//去重并求出离散化数组大小</span><br><span class="line">// 二分求出x对应的离散化的值</span><br><span class="line">int find(int x) // 找到第一个大于等于x的位置</span><br><span class="line">&#123;</span><br><span class="line">    int l = 1, r = cnt;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        if (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return r; 前面存储是从1开始的 所以这直接return r</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>区间和</p><figure class="highlight plaintext"><figcaption><span>[区间和] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; PII;//操作读入是成对的 定义这么一个结构</span><br><span class="line"></span><br><span class="line">const int N=300010;</span><br><span class="line">int n,m;</span><br><span class="line">int a[N],s[N];</span><br><span class="line">vector&lt;int&gt; alls;</span><br><span class="line">vector&lt;PII&gt; add,query; //定义两个PII 一个存操作c 一个存给的l r</span><br><span class="line"></span><br><span class="line">int find(int x) // 找到第一个大于等于x的位置</span><br><span class="line">&#123;</span><br><span class="line">    int l = 0, r = alls.size()-1;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        if (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return r+1; 本题是映射到从1开始 因为要用到前缀和</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x,c;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        add.push_back(&#123;x,c&#125;);</span><br><span class="line">        alls.push_back(x);//待离散化的值</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        query.push_back(&#123;l,r&#125;); //注意pair类型插入需要大括号</span><br><span class="line">        alls.push_back(l);</span><br><span class="line">        alls.push_back(r);//将l r存入待离散化数组</span><br><span class="line">    &#125;</span><br><span class="line">    sort(alls.begin(),alls.end());//排序</span><br><span class="line">    alls.erase(unique(alls.begin(),alls.end()),alls.end());//去重</span><br><span class="line"></span><br><span class="line">    for(auto ite:add )</span><br><span class="line">    &#123;</span><br><span class="line">        int x=find(ite.first);</span><br><span class="line">        a[x]+=ite.second;//离散化 对应加上c</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=alls.size();i++) s[i]=s[i-1]+a[i]; //预处理前缀和</span><br><span class="line"></span><br><span class="line">    for(auto item: query)</span><br><span class="line">    &#123;</span><br><span class="line">        int l=find(item.first);</span><br><span class="line">        int r=find(item.second);</span><br><span class="line">        cout&lt;&lt;s[r]-s[l-1]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2022/12/26/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2022/12/26/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>普通的函数写循环 时间就寄了 所以需要快速幂<br>已知(a<em>b)%c&#x3D;((a%c)</em>(b%c))%c 可以初步优化 但是依然不够<br>核心思想就是每一步都把指数分成两半 而相应的底数做平方运算 如<br>3^10&#x3D;3<em>3</em>3<em>3</em>3<em>3</em>3<em>3</em>3<em>3<br>3^10&#x3D;(3</em>3)<em>(3</em>3)<em>(3</em>3)<em>(3</em>3)<em>(3</em>3)<br>3^10&#x3D;(3<em>3)^5<br>3^10&#x3D;9^5<br>而当指数为奇数时 指数减一化为偶数<br>9^5&#x3D;（9^4）</em>（9^1）继续操作<br>9^5&#x3D;（81^2）*(9^1)<br>9^5&#x3D;（6561^1）*(9^1)<br>最后(9^1)<em>(6561^1)&#x3D;9</em>6561&#x3D;59049<br>最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积</p><p>求a的b次方取余1000</p><figure class="highlight plaintext"><figcaption><span>[快速幂] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">long long FastPower(long long base,long long power)</span><br><span class="line">&#123;</span><br><span class="line">    long long result=1;</span><br><span class="line">    while(power&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (power % 2 == 0) &#123;</span><br><span class="line">            //如果指数为偶数</span><br><span class="line">            power/=2;//把指数砍一半</span><br><span class="line">            base=base*base%1000;//底数变大成原来的平方</span><br><span class="line">    &#125;   else&#123;//如果是奇数</span><br><span class="line">            power-=1;//先变成偶数</span><br><span class="line">            result=result*base%1000;//独立出来的1必须记得</span><br><span class="line">            power/=2;</span><br><span class="line">            base=base*base%1000;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此之外 可以再理解原理的基础上由向下取整简化</p><figure class="highlight plaintext"><figcaption><span>[快速幂] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">power-=1;</span><br><span class="line">power/=2;</span><br><span class="line">等价于</span><br><span class="line">power/=2;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>素数筛与欧拉筛</title>
      <link href="/2022/12/24/%E7%AE%97%E6%B3%95-%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
      <url>/2022/12/24/%E7%AE%97%E6%B3%95-%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>朴素算法<br>优化方法<br>1.只判断奇数<br>2.因子是成对出现，并且分布在 sqrt (n) 两侧的 所以只判断到n的根</p><figure class="highlight plaintext"><figcaption><span>[素数筛] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int IsPrime(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if(n&lt;2||(n!=2&amp;&amp;n%2==0))</span><br><span class="line">        return 0;</span><br><span class="line">    else //n都是奇数</span><br><span class="line">    &#123;</span><br><span class="line">        for(i=3;i*i&lt;=n;i+=2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(n%i==0)</span><br><span class="line">                return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然如此优化依旧不够</p><p>埃氏筛1.0<br>便是数组a储存已经筛选过的素数 数组b包含范围内所有数字，用来标记是否被访问过 从2开始循环 对其进行倍增操作<br>优化方法<br>1.易知很多倍增其实重复了 浪费了时间空间 优化方法便是只对素数进行倍增<br>2.倍增从i开始 而不是从2开始 减少一半计算量</p><figure class="highlight plaintext"><figcaption><span>[素数筛] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int vis[N];//判断是否被访问过</span><br><span class="line">int prime[N];//存储筛选出来的素数</span><br><span class="line"></span><br><span class="line">int s(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,k;//i是逐个访问 j二轮标记，k标记prime数组的位置</span><br><span class="line">    k=0; //这样定义 每次函数调用时都清空</span><br><span class="line">    memset(vis,0,sizeof(int)*N); //清空访问数组</span><br><span class="line">    vis[0]=vis[1]=1;//此步无所谓 因为从2开始</span><br><span class="line">    for(int i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(vis[i]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            prime[k++]=i;//如果没有被访问过 那么就是最小的素数</span><br><span class="line">            for(int j=i;j&lt;=n;j++) vis[i*j]=1; //标记在上界内 这个素数数倍增后的数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>埃氏筛2.0 除了上述优化<br>1.只判断奇数<br>2.由于因子是成对出现的，如果左侧范围数字不是因子，则右侧范围中也没有因子，因此可以说明这个数字是素数<br>即x在[2，sqrt (x) ] 范围内的数倍增时 已经得到了<br>于是有了最终埃氏筛</p><figure class="highlight plaintext"><figcaption><span>[埃氏筛] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int E(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&lt;2) return 0;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    k=0;</span><br><span class="line">    memset(vis,0,sizeof(int)*N);</span><br><span class="line">    vis[0]=vis[1]=1;//0 1都是非素数</span><br><span class="line"></span><br><span class="line">    for(i=4;i&lt;=n;i+=2) vis[i]=1;//把偶数全部标记了 都是非素数</span><br><span class="line">    for(i=3;i*i&lt;=n;i+=2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(vis[i]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            for(j=i;i*j&lt;=n;j++) vis[i*j]=1;//这里把j=2改为j=i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    prime[k++]=2; //上面循环 只循环到了sqrt(n) 所以需要从头循环一次</span><br><span class="line">    for(i=3;i&lt;=n;i+=2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(vis[i]==0) prime[k++]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>埃氏筛的最终版本 是只要是素数就进行倍增<br>欧拉筛 在埃氏筛的基础上 保证了每个合数只被筛选一次</p><figure class="highlight plaintext"><figcaption><span>[欧拉筛] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//欧拉筛函数</span><br><span class="line">int E2(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    k=0;//保存素数的个数</span><br><span class="line">    memset(vis,0,sizeof(int)*maxn);//初始化数组</span><br><span class="line">    for(i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(vis[i]==0)//i是素数，则存起来</span><br><span class="line">            prime[k++]=i;</span><br><span class="line">        for(j=0;j&lt;k;j++)//进行倍增，用i去乘以i之前(包括i)的素数</span><br><span class="line">        &#123;</span><br><span class="line">            if(i*prime[j]&gt;n)//倍增结果超出范围，退出</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            vis[ i*prime[j] ]=1;//将倍增结果进行标记</span><br><span class="line"></span><br><span class="line">            if(i%prime[j]==0)//i是前面某个素数的倍数时，也需要退出</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2022/12/17/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/12/17/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>head 表示头结点的下标<br>e[i] 表示节点i的值<br>ne[i] 表示节点i的next指针是多少 (下一个节点的下标)<br>idx 存储当前已经用到了哪一个点</p><figure class="highlight plaintext"><figcaption><span>[数组模拟单链表] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100010;</span><br><span class="line">int head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line">void init() //初始化</span><br><span class="line">&#123;</span><br><span class="line">    head=-1;</span><br><span class="line">    idx=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add_to_head(int x) //将x插到头结点</span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=x;//这个结点赋值</span><br><span class="line">    ne[idx]=head;//新头结点的下一个结点是之前的头结点</span><br><span class="line">    head=idx; head变成新的头结点的下标</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int k,int x)//将x插到下标为k的位置的后面 注意不是第k个点 是下标为k的点</span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=x;//还是先赋值到新节点</span><br><span class="line">    ne[idx]=ne[k]; //新节点的下一个坐标更新为k节点原本的下一个坐标</span><br><span class="line">    ne[k]=idx;//k的下一个下标是新节点</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void remove(int k,int x) //删掉k之后的一个元素</span><br><span class="line">&#123;</span><br><span class="line">    ne[k]=ne[ne[k]];直接跳过就得了</span><br><span class="line">&#125;</span><br><span class="line">遍历</span><br><span class="line">for(int i=head;i!=-1;i=ne[i]) 略</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每个点有两个指针</p><figure class="highlight plaintext"><figcaption><span>[数组模拟双链表] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100010;</span><br><span class="line"></span><br><span class="line">int m;</span><br><span class="line">int e[N],l[N],r[N],idx; l是左边的点的下标 r是右边的点的下标</span><br><span class="line"></span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    r[0]=1;</span><br><span class="line">    l[1]=0;</span><br><span class="line">    idx =2;//0 1已经被占用过了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int k, int x) 在下标为k的点的右边插入x</span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    r[idx]=r[k];</span><br><span class="line">    l[idx]=k;</span><br><span class="line">    l[r[k]]=idx;//注意倒数二三个不能换位置 不然没法完成</span><br><span class="line">    r[k]=idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line">在k的左边 直接add(l[k],int x)</span><br><span class="line"></span><br><span class="line">void remove(int k) //删除第k个节点</span><br><span class="line">&#123;</span><br><span class="line">    r[l[k]]=r[k]; //k上一个元素的右边下标直接等于k右边边的元素下标</span><br><span class="line">    l[r[k]]=l[k]; //k下一个元素的左边下标直接等于k左边的元素下标</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = r[0]; i != 1; i = r[i])  // 从左向右遍历</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">邻接表 就是n个单链表</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小技巧</title>
      <link href="/2022/12/12/%E7%AE%97%E6%B3%95-small-tips/"/>
      <url>/2022/12/12/%E7%AE%97%E6%B3%95-small-tips/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>cin，cout之所以效率低，是因为先把要输出的东西存入缓冲区，再输出，导致效率降低.<br>在调用下列代码后，效率与scanf与printf相差无几,但是不能再用scanf了</p><figure class="highlight plaintext"><figcaption><span>[tips] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0);</span><br></pre></td></tr></table></figure><p>多层循环提高效率</p><figure class="highlight plaintext"><figcaption><span>[tips] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register int</span><br></pre></td></tr></table></figure><p>auto的原理就是根据后面的值，来自己推测前面的类型是什么<br>针对迭代器 可以如下操作</p><figure class="highlight plaintext"><figcaption><span>[tips] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; ve;</span><br><span class="line">ve.push_back(1);</span><br><span class="line">ve.push_back(2);</span><br><span class="line">ve.push_back(3);</span><br><span class="line"></span><br><span class="line">for(auto i:ve) cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>快读 字符串输入 再转为数字 超级快</p><figure class="highlight plaintext"><figcaption><span>[int快读] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int read()</span><br><span class="line">&#123;</span><br><span class="line">    int s=0,w=1;</span><br><span class="line">    char ch=getchar();</span><br><span class="line">    if(ch==&#x27;-&#x27;) //先判断是不是个负数</span><br><span class="line">    &#123;</span><br><span class="line">        w=-1;</span><br><span class="line">        ch=getchar();继续读下一个字符</span><br><span class="line">    &#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=9)</span><br><span class="line">    &#123;</span><br><span class="line">        s=s*10+ch-&#x27;0&#x27;;极其重要 记得-0</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return w*s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[double快读] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">double read()</span><br><span class="line">&#123;</span><br><span class="line">    double s=0,w=1;</span><br><span class="line">    char ch=getchar();</span><br><span class="line">    if(ch==&#x27;-&#x27;) </span><br><span class="line">    &#123;</span><br><span class="line">        w=-1;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">     while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=9)</span><br><span class="line">    &#123;</span><br><span class="line">        s=s*10+ch-&#x27;0&#x27;;</span><br><span class="line">        ch=getchar();前面都一样</span><br><span class="line">    &#125;</span><br><span class="line">    if(ch==&#x27;.&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        ch=getchar();</span><br><span class="line">        double f=0;</span><br><span class="line">        int i=0;//计算小数尾数</span><br><span class="line">        while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            f=f*10+ch-&#x27;0&#x27;;</span><br><span class="line">            i++;</span><br><span class="line">            ch=getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        s+=f</span><br><span class="line">    &#125;</span><br><span class="line">    return w*s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[int 快写] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void write(int x) &#123;</span><br><span class="line">     if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">     if(x&gt;9) write(x/10);</span><br><span class="line">     putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前缀和与差分</title>
      <link href="/2022/12/11/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
      <url>/2022/12/11/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>例 输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和。如果暴力遍历，时间复杂度为O(m*n) 可能超时<br>则采用前缀和算法并查询<br>a[N]记得是从1开始,a[0]&#x3D;0, 因为如果是求（1，r) 需要sum[r]-sum[0]</p><figure class="highlight plaintext"><figcaption><span>[前缀和] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const int N = 1e5 + 10;</span><br><span class="line">int sum[N], a[N]; //sum[i]=a[1]+a[2]+a[3].....a[i];</span><br><span class="line">for(int i = 1;i &lt;= n; i++)</span><br><span class="line">&#123; </span><br><span class="line">    sum[i] = sum[i - 1] + a[i];   //前缀和的初始化</span><br><span class="line">&#125;</span><br><span class="line">while(m--)</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    cout&lt;&lt;sum[r] - sum[l - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。<br>对于每个询问输出子矩阵中所有数的和。<br>二维前缀和思路相同 但是要推导公式</p><figure class="highlight plaintext"><figcaption><span>[二维前缀和] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1010;</span><br><span class="line">int n, m, q;</span><br><span class="line">int a[N][N];s[N][M];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ )</span><br><span class="line">        for (int j = 1; j &lt;= m; j ++ )</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ )</span><br><span class="line">        for (int j = 1; j &lt;= m; j ++ )</span><br><span class="line">            s[i][j]= s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]+a[i][j]; //前缀和的初始化</span><br><span class="line">     while (q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        int x1, y1, x2, y2;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        cout&lt;&lt;s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1])&lt;&lt;endl; //算子矩阵的和</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一维差分类似于数学中的求导和积分，差分可以看成前缀和的逆运算<br>首先给定一个原数组a：a[1], a[2], a[3],,,,,, a[n];<br>然后我们构造一个数组b ： b[1], b[2], b[3],,,,,, b[i];<br>使得 a[i] &#x3D; b[1] + b[2] + b[3] + ,,,,,, + b[i]<br>也就是说，a数组是b数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。</p><p>例<br>输入一个长度为n的整数序列。<br>接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。<br>请你输出进行完所有操作后的序列。</p><figure class="highlight plaintext"><figcaption><span>[一维差分] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line">int a[N],b[N],n,m; </span><br><span class="line">void insert(int l,int r,int c)</span><br><span class="line">&#123;</span><br><span class="line">    b[l]+=c;</span><br><span class="line">    b[r+1]-=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++) insert(i,i,a[i]);</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r,c;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        insert(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) b[i]+=b[i-1];</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cout&lt;&lt;b[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>二维思路相似</p><figure class="highlight plaintext"><figcaption><span>[二维差分] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e3 + 10;</span><br><span class="line">int a[N][N], b[N][N];</span><br><span class="line">void insert(int x1, int y1, int x2, int y2, int c)</span><br><span class="line">&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + 1][y1] -= c;</span><br><span class="line">    b[x1][y2 + 1] -= c;</span><br><span class="line">    b[x2 + 1][y2 + 1] += c;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        for (int j = 1; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            insert(i, j, i, j, a[i][j]);      //其实也不能算构造 差分数组创建的时候就直接行了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        int x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        insert(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];  //二维前缀和</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%d &quot;, b[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acwing 3729<br>这道题一开始想的区间合并 听了讲解发现居然能差分<br>因为每个位置的数只会增加 所以只要操作次数不是0 那么值就为1<br>怎么记录操作次数呢 就需要用差分<br>b[1]到b[i]的前缀和就是第i个元素的操作次数 极大节省时间<br>差分数组不用刻意去构造 创建的时候就能直接弄出来</p><figure class="highlight plaintext"><figcaption><span>[3729] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long n,mid;</span><br><span class="line">const int N=2e5+10;</span><br><span class="line">long long b[N];</span><br><span class="line">void add(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">b[l]+=1;</span><br><span class="line">b[r+1]-=1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0);</span><br><span class="line">cout.tie(0);</span><br><span class="line">long long t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">memset(b,0,sizeof b);</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">if(x==0) continue;</span><br><span class="line">else if(x&gt;=i) add(1,i);</span><br><span class="line">else add(i-x+1,i);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++) b[i]+=b[i-1]; //此时b[i]存的是操作次数</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(b[i]!=0) cout&lt;&lt;1&lt;&lt;&quot; &quot;;</span><br><span class="line">    else cout&lt;&lt;0&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>stl-map</title>
      <link href="/2022/12/03/%E7%AE%97%E6%B3%95-stl-map/"/>
      <url>/2022/12/03/%E7%AE%97%E6%B3%95-stl-map/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>map是c++的一个关联容器 提供一对一的映射<br>第一个称为关键字key（有唯一性） 第二个称为关键字的值value<br>和python里的字典很像</p><figure class="highlight plaintext"><figcaption><span>[map] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">如你想建立一个姓名-电话对应关系</span><br><span class="line">定义一个map对象</span><br><span class="line">map&lt;string,string&gt;friends;</span><br><span class="line">cout&lt;&lt;friends.find(&quot;jack&quot;); 找到jack的对应号码</span><br><span class="line">cout&lt;&lt;friedns.find(123); 找123对应的姓名 找不到返回null</span><br><span class="line"></span><br><span class="line">用insert函数插入</span><br><span class="line">friends.insert(pair&lt;string, string&gt;(&quot;judy&quot;, &quot;789&quot;));</span><br><span class="line"></span><br><span class="line">遍历 不能写小于</span><br><span class="line">for(iter=friends.begin();iter!=friends.end();iter++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">推荐使用数组插入 因为对于同一关键字 新的值可以覆盖旧的</span><br><span class="line">friends[234]=&quot;sam&quot;;</span><br><span class="line">friends[456]=&quot;mark&quot;;</span><br><span class="line"></span><br><span class="line">查找元素与删除 清空</span><br><span class="line">iter=firends.find(&quot;123&quot;);</span><br><span class="line">friends.erase(iter);</span><br><span class="line">friends.clear;</span><br><span class="line"></span><br><span class="line">查看有多少元素</span><br><span class="line">int num=friends.size();</span><br><span class="line"></span><br><span class="line">返回头部/尾部迭代器</span><br><span class="line">friends.begin();</span><br><span class="line">friends.end();</span><br><span class="line"></span><br><span class="line">返回键值&gt;=给定元素的第一个位置</span><br><span class="line">lower_bound()</span><br><span class="line"></span><br><span class="line">返回键值&gt;给定元素的第一个位置</span><br><span class="line">upper_bound();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整道简单例题<br><img src="/images/p2.png"><br>一看就用映射关系解决 注意要求谁先到最高分 所以多定义一个b</p><figure class="highlight plaintext"><figcaption><span>[map例] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int x[10010];</span><br><span class="line">string s[10010]</span><br><span class="line">map&lt;string,int&gt;a,b;//定义</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n</span><br><span class="line">    for(int i=0;i&lt;n;i++&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s[i]&gt;&gt;x[i];</span><br><span class="line">        a[s[i]]+=x[i]; //赋value</span><br><span class="line">    &#125;</span><br><span class="line">    int max=0; //通过a先求出最大值 </span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[s[i]]&gt;max) max=a[s[i]];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)//再通过b求谁先到最大值</span><br><span class="line">&#123;</span><br><span class="line">b[s[i]]+=x[i];</span><br><span class="line">if((b[s[i]])&gt;=max&amp;&amp;a[s[i]]&gt;=max)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;s[i];</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>stl-其它</title>
      <link href="/2022/12/01/%E7%AE%97%E6%B3%95-stl-%E5%85%B6%E5%AE%83/"/>
      <url>/2022/12/01/%E7%AE%97%E6%B3%95-stl-%E5%85%B6%E5%AE%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><figcaption><span>[stl] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; a(&#123;1,2,3,4,5&#125;);动态数组</span><br><span class="line">array.pop_back(); //删除向量的最后一个元素</span><br><span class="line">array.push_back(a); //尾部插入数字a</span><br><span class="line">array.insert(array.begin()+i,a); //在第i+1个元素前面插入a;</span><br><span class="line">array.erase(array.begin()+2); //删除第3个元素</span><br><span class="line">array.erase(array.begin()+i,array.end()+j); //删除区间[i,j-1],区间从0开始</span><br><span class="line">array.clear();</span><br><span class="line">array.back();//返回最后一个元素</span><br><span class="line">array.front(); //返回第一个元素</span><br><span class="line"></span><br><span class="line">reverse(a.begin().a.end()); 翻转 必须用迭代器 数组不用 注意是都是前闭后开 end()是back()的后一位</span><br><span class="line"></span><br><span class="line">必须相同元素排一起才能去重 返回值是去重后元素的下一个位置</span><br><span class="line">int m=unique(a,a+n)-a;</span><br><span class="line">int n=unique(a.begin(),a.end())-a.begin(); 不同元素的数量 此时原数组也改变（其实是生成了新数组)</span><br><span class="line">a.erase(unique(a.begin(),a.end()),a.end()); 相当于只留不同元素</span><br><span class="line"></span><br><span class="line">random_shuffle(a.begin(),a.end()); 随机顺序</span><br><span class="line"></span><br><span class="line">sort(a.begin(),a.end()); 从小到大排序</span><br><span class="line"></span><br><span class="line">bool cmp(a,b)</span><br><span class="line">&#123;</span><br><span class="line">    return a&lt;b; 如果符合返回true a排b前面</span><br><span class="line">&#125;</span><br><span class="line">sort(a.begin(),a.end(),cmp);从大到小</span><br><span class="line"></span><br><span class="line">lower_bound      查找大于等于x的第一个元素的下标 元素存放在1到n中</span><br><span class="line">upper_bound      查找大于x的第一个元素的下标</span><br><span class="line"></span><br><span class="line">对于数组</span><br><span class="line">int *p = lower_bound(a, a + 5, 3); 从a数组中找到第一个不小于3的元素</span><br><span class="line">int t = lower_bound(a, a + 5, 3)-a 减去数组第一位的地址 得到下标</span><br><span class="line"></span><br><span class="line">神器</span><br><span class="line">nth_element(数组名,数组名+第k小元素,数组名+元素个数)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分答案</title>
      <link href="/2022/11/30/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
      <url>/2022/11/30/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>二分答案与二分查找模板又有些许不同</p><figure class="highlight plaintext"><figcaption><span>[二分答案] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while(l&lt;=r)//此处是小于等于</span><br><span class="line">&#123;</span><br><span class="line">    mid=(l+r)&gt;&gt;1;</span><br><span class="line">    if(check(mid))</span><br><span class="line">    &#123;</span><br><span class="line">        ans =mid;</span><br><span class="line">        l=mid+1</span><br><span class="line">    &#125;</span><br><span class="line">    else r=mid-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>洛谷P2678 跳石头<br>当一道题目直接求解答案会很困难，但是根据题意去验证答案会很简单，那么我们就利用逆向思维，直接枚举答案，利用刚刚学到的二分查找去查找答案，然后去直接按照题意验证答案，验证成功即可输出，所以二分更多的就是逆向思维</p><figure class="highlight plaintext"><figcaption><span>[跳石头] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e5+7;</span><br><span class="line">int a[N],ans;</span><br><span class="line">bool check(int x,int b[],int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">int now=0,tot=0;</span><br><span class="line">for(int j=1;j&lt;=n+1;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[j]-a[now]&lt;x) tot++;//如果距离小 这颗石头可以搬走 </span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">now=j;// 如果距离大,就跳过去  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(tot&gt;m) return false;</span><br><span class="line">else return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int L,n,m;</span><br><span class="line">cin&gt;&gt;L&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">a[n+1]=L;</span><br><span class="line">int l=1,r=L;</span><br><span class="line">while(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">int mid=(l+r)&gt;&gt;1;</span><br><span class="line">if (check(mid,a,n,m))</span><br><span class="line">&#123;</span><br><span class="line">ans=mid;</span><br><span class="line">l=mid+1;//如果搬的石头少 最短跳跃距离可能可以更大 </span><br><span class="line">    &#125;</span><br><span class="line">else r=mid-1;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高精度四则</title>
      <link href="/2022/11/29/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>/2022/11/29/%E7%AE%97%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用数组存大整数 模拟人工加法的过程<br>数组中正向小的索引存高位</p><figure class="highlight plaintext"><figcaption><span>[高精度加法] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1e6+10;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B)//加&amp;是引用 不用创造新的动态数组</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line"></span><br><span class="line">    int t=0;//表示进位</span><br><span class="line">    for(int i=0;i&lt;A.size()||i&lt;B.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i&lt;A.size()) t+=B[i];</span><br><span class="line">        if (i&lt;B.size()) t+=B[i];</span><br><span class="line">        C.push_back(t%10);</span><br><span class="line">        t/=10;</span><br><span class="line">    &#125;</span><br><span class="line">if (t) C.push_back(1);//如果最高位还有进位 那么最高位补1</span><br><span class="line">return C;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;int&gt;A,B;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b; //a=&quot;123456&quot;</span><br><span class="line">    for(int i=a.size()-1;i&gt;=0;i--) A.push_back(a[i]-&#x27;0&#x27;);//字符型数字变成整型数字</span><br><span class="line">    for(int i=b.size()-1;i&gt;=0;i--) B.push_back(b[i]-&#x27;0&#x27;);//A=[6,5,4,3,2,1]</span><br><span class="line">    auto C=add(A,B);</span><br><span class="line">    for(int i=C.size()-1;i&gt;=0;i--) cout&lt;&lt;C[i];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[高精度减法] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool cmp(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B) //减法模板必须大的减小的</span><br><span class="line">&#123;</span><br><span class="line">    if(A.size()!=B.size()) return A.size()&gt;B.size();</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=A.size()-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(A[i]!=B[i]) return A[i]&gt;B[i];//从高位开始判断大小</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line"></span><br><span class="line">    int t=0;//进位</span><br><span class="line">    for(int i=0,t=0;i&lt;A.size()||i&lt;B.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t=A[i]-t;</span><br><span class="line">        if(i&lt;B.size()) t-=B[i];  //判断B有没有这一位 有就减</span><br><span class="line">        C.push_back((t+10)%10); //如果t大于0 那么就是t 如果t小于0 借10</span><br><span class="line">        if (t&lt;0) t=1;</span><br><span class="line">        else t=0; //判断有无借10</span><br><span class="line">    &#125;</span><br><span class="line">    while(C.size()&gt;1&amp;&amp;C.back()==&#x27;0&#x27;) C.pop_back(); //去掉首位0 避免出现如0032的情况</span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;int&gt;A,B;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b; //a=&quot;123456&quot;</span><br><span class="line">    for(int i=a.size()-1;i&gt;=0;i--) A.push_back(a[i]-&#x27;0&#x27;);//字符型数字变成整型数字</span><br><span class="line">    for(int i=b.size()-1;i&gt;=0;i--) B.push_back(b[i]-&#x27;0&#x27;);//A=[6,5,4,3,2,1]</span><br><span class="line">    auto C=sub(A,B);</span><br><span class="line">    for(int i=C.size()-1;i&gt;=0;i--) cout&lt;&lt;C[i];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是大数据乘小数据 可以这么写 比较方便</p><figure class="highlight plaintext"><figcaption><span>[高精度乘法1] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A,int b);//乘法一个乘数可以直接int表示了</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    int t=0;</span><br><span class="line">    for(int i=0;i&lt;A.size()||t;i++) //A未遍历完或还有进位 就继续</span><br><span class="line">    &#123;</span><br><span class="line">        t+=A[i]*b;</span><br><span class="line">        C.push_back(t%10)</span><br><span class="line">        t/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个都是大数据的话 笑死</p><figure class="highlight plaintext"><figcaption><span>[高精度乘法2] [p3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=int(input())</span><br><span class="line">b=int(input())</span><br><span class="line">print(a*b)</span><br></pre></td></tr></table></figure><p>注意除法是从最高位开始除的 跟之前的不同 但是为了统一 此处也是倒着存 略</p><figure class="highlight plaintext"><figcaption><span>[高精度除法] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; div(vector&lt;int&gt; &amp;A,int b，int &amp;r);//r是余数</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    r=0;</span><br><span class="line">    for(int i=A.size()-1;i&gt;=0;i--)//比如a是1234 则A是4321 除法从a的最低位 也就是A的最高位开始 </span><br><span class="line">    &#123;</span><br><span class="line">        r=r*10+A[i];//除法中下一位数直接放在余数右边</span><br><span class="line">        C.push_back(r/b);</span><br><span class="line">        r%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.begin(),C.end()); //顺逆关系</span><br><span class="line">    while(C.size()&gt;1&amp;&amp;C.back=&#x27;0&#x27;) C.pop_back();</span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串语法</title>
      <link href="/2022/11/29/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/11/29/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>字符串就是字符数组加上结束符\0<br>常用的不忽略空格的字符串读入方式<br>针对string类型(多用)</p><figure class="highlight plaintext"><figcaption><span>[读入1] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">略 </span><br><span class="line">    string a;</span><br><span class="line">    getline(cin,a);//这个只能读string不能读字符串</span><br><span class="line">    cout&lt;&lt;a.size()&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure><p>针对char类型</p><figure class="highlight plaintext"><figcaption><span>[读入2] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">略</span><br><span class="line">    char s[100];</span><br><span class="line">    fgets(s,100,stdin);//100表示最多读入字符</span><br><span class="line">    //stdin表示定义好的系统变量</span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure><p>字符串流（形式有点像py列表）<br>先把字符串初始化为字符串流 再从中读出 用法与cin相似</p><figure class="highlight plaintext"><figcaption><span>[字符串流] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">略</span><br><span class="line">string s;</span><br><span class="line">getline(cin,s);</span><br><span class="line">stringstream ssin(s);//ssin自定义 s被初始化</span><br><span class="line">string str;</span><br><span class="line">while(ssin&gt;&gt;str)//读出</span><br><span class="line">   pass</span><br><span class="line">int a,b；</span><br><span class="line">double c,d;</span><br><span class="line">string e;</span><br><span class="line">ssin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d&lt;&lt;endl;//可读出任何形式</span><br></pre></td></tr></table></figure><p>一些常用的</p><figure class="highlight plaintext"><figcaption><span>[常用函数] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">略</span><br><span class="line">string a,b,c</span><br><span class="line">strcmp(a,b) 比较两个字符串大小 a大返回1 相等返回0 否则-1</span><br><span class="line">a.size();//长度</span><br><span class="line">strcpy(a,b);将字符串b复制给从a开始的字符数组</span><br><span class="line">a.substr(m,n);</span><br><span class="line">str.back()//最后一个字符 其实等价于str[str.size()-1]</span><br><span class="line">str.pop_back//去除最后一个字符</span><br><span class="line">c=a.find(b,2);从下标为2开始（包含2）寻找b 输出b第一个字符的位置下标 如果没有 输出c.npos</span><br><span class="line">string str=&quot;abcd&quot;;</span><br><span class="line">reverse(str.begin(),str.end());</span><br><span class="line"></span><br><span class="line">string str2=&quot;abcd&quot;;</span><br><span class="line">reverse(str2.begin()+1,str2.end());翻转</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2022/11/28/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/11/28/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>二分的本质是边界 对于整数二分与浮点数二分有不同的模板<br>数组里的查找<br>整数二分（单个)</p><figure class="highlight plaintext"><figcaption><span>[整数二分] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int bsearch_one(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid=(l+r)/2;</span><br><span class="line">        if(q[mid]==goal) return mid;</span><br><span class="line">        else if(q[mid]&gt;goal) r=mid;</span><br><span class="line">        else l=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">寻找左分界点</span><br><span class="line">int bsearch_one(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid=(l+r)/2;</span><br><span class="line">        if(q[mid]&gt;=goal) r=mid; //右边端点不断靠左边移动</span><br><span class="line">        else l=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(q[l]!=goal) return -1;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line">寻找右分界点</span><br><span class="line">int bsearch_one(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid=(l+r+1)/2;</span><br><span class="line">        if(q[mid]&lt;=goal) l=mid; //右边端点不断靠左边移动</span><br><span class="line">        else r=mid-1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(q[l]!=goal) return -1;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line">若不存在对应数 l是找的最近的满足check的索引</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>浮点数二分 因为没有整除 所以有严格边界</p><figure class="highlight plaintext"><figcaption><span>[浮点数二分(例题三次方根)] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double x；</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">double l=0,r=x;</span><br><span class="line">while(r-l&gt;1e-8)//精度尽量大</span><br><span class="line">&#123;</span><br><span class="line">    double mid=(l+r)/2;</span><br><span class="line">    if(mid*mid&gt;=x)&#123;</span><br><span class="line">        r=mid;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        l=mid;//不用考虑边界</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之浮点数二分简单多了~</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快排 归并</title>
      <link href="/2022/11/26/%E7%AE%97%E6%B3%95-%E5%BF%AB%E6%8E%92%E5%B9%B6%E5%BD%92/"/>
      <url>/2022/11/26/%E7%AE%97%E6%B3%95-%E5%BF%AB%E6%8E%92%E5%B9%B6%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><figcaption><span>[快排] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N =1e6+10;</span><br><span class="line">int n,q[N];</span><br><span class="line">void quick_sort(int q[],int l,int r) //l r指起点终点索引</span><br><span class="line">&#123;</span><br><span class="line">    if (l&gt;=r) return;</span><br><span class="line">    int x=q[l],//确定分界点</span><br><span class="line">    int i=l-1，j=r+1； //先移动指针 再进行比较判断 所以指针先放边界两侧外</span><br><span class="line">    while(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        do i++; while(q[i]&lt;x);</span><br><span class="line">        do j--; while(q[j]&gt;x);//通过分界点分到两侧</span><br><span class="line">        if(i&lt;j) swap(q[i],q[j]);  </span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q,l,j); //两侧分别递归</span><br><span class="line">    quick_sort(q,j+1,r);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;m;i++) cin&gt;&gt;q[i];</span><br><span class="line">    quick(q,0,m-1);</span><br><span class="line">    for(int j=0;j&lt;m;j++) cout&lt;&lt;q[j]&lt;&lt;&quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1.确定分界点（通常l） 2.调整区间 3.递归处理两侧</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[归并] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1000010;</span><br><span class="line">int n;</span><br><span class="line">int q[N],tmp[N];</span><br><span class="line">void merge_sort(int q[],int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    if(l&gt;=r) return;</span><br><span class="line">    int mid=1+r&gt;&gt;1;//确定中间值</span><br><span class="line">    merge_sort(q,l,mid),merge_sort(q,mid+1,r);//递归处理使用两侧有序</span><br><span class="line">    int k=0,i=l,j=mid+1;</span><br><span class="line">    while(i&lt;=mid&amp;&amp;j&lt;=r) </span><br><span class="line">        if(q[i]&lt;=q[j]) tmp[k++]=q[i++];//比较 插入</span><br><span class="line">        else tmp[k++]=q[j++];</span><br><span class="line">    while(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line">    while(j&lt;=r) tmp[k++]=j[i++];</span><br><span class="line">    for(i=l,j=0;i&lt;=r;i++,j++) q[i]=tmp[j];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;m;i++) cin&gt;&gt;q[i];</span><br><span class="line">    merge_sort(q,0,m-1);</span><br><span class="line">    for(int j=0;j&lt;m;j++) cout&lt;&lt;q[j]&lt;&lt;&quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1.确定分界点 2.递归排序 3.归并</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法之前的自白</title>
      <link href="/2022/11/25/second/"/>
      <url>/2022/11/25/second/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>九月疫情，没能返校，因为对c语言有着一种敬畏，就花了一个月先把python的语法基础过了一遍，又通过张绪某（hhhh算法课不上就刷题的nt，当然祝你成功进队）发的邀请码，混入某不知名大专（西柚）的新生选拔赛里初步做一做。<br><img src="/images/p1.png"><br>十月中旬到了学校才知道我的专业里c语言在大一下册才会开始教，大一上就学数分高代，我就咨询了一下竞赛部的大佬，他的原话：“py也就图一乐。”我便开始课下看mooc翁恺的课，狂补c语言的基础。然而这个学长话只说一半，到十一月初我肝完了语法基础，才告诉我整算法竞赛c++是必修项<br>好家伙，竞赛部的选拔这时候已经只有两周了，我有点完美主义，又不想用比较拿手的python去做，我便又在acwing上学c++ 因为c++跟c的语法很像，我就一边看课一边刷里面的习题。<br>机试的第一道题就一棒子把我打懵了，第一道就是动态规划，我丝毫没犹豫，就去找签到题先做，再看有没有能暴力整出来的题。最后出结果，虽然我总共提交次数最多，但是因为是ioi赛制没有罚时，运气好，最后一个名额擦着进了。<br>缓了几天 这就开始更新算法章节了</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浅浅聊一聊关于博客</title>
      <link href="/2022/11/24/first/"/>
      <url>/2022/11/24/first/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在某个百无聊赖的中国近代史课上，有了想自己搭建一个网站的想法，想把自己的所学所思记录在自己定制的一个网站上。<br>由于我目前没有任何css和html的基础，也没有购买服务器的想法，就采用了现在稍微流行一点且成本较低的方式-用hexo框架和githubpage搭建博客（以后应该会换成gitee，github确实太不稳定）<br>我是个比较能折腾的人，从23号晚上开始一步步下载nodejs，git，vscode，配置环境变量。在无数的error（强烈建议严格按照知乎大佬的步骤一步步下载和配置相关文件，因为我自己擅自改了路径又不想重来，基本经历了所能遇到的一半以上的问题）25号终于搭建好了，但是看着简陋的网站，折腾之心再起，又花了一天半的时间学了markdown语法，对网页进行魔改，大幅度地修改了主题配置文件，各种插件buff叠满（好在运气好没有出现多少bug）但是这个网站还是有一堆缺点:还没有绑定自己的域名，没有高速图床，github国内访问经常抽风慢，页面不够美观……<br>在自己的博客上写文章想一想还是挺有热情的，我不期望访问量有多少，因为主要是拿来做算法的笔记用的。<br>我想如果能坚持记下来也算是自己的一个闪光点吧。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/Gallery/index.html"/>
      <url>/Gallery/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='.5'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/fps.js"/>
      <url>/js/fps.js</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>if (window.localStorage.getItem("fpson") == undefined || window.localStorage.getItem("fpson") == "1") {    var rAF = function () {        return (            window.requestAnimationFrame ||            window.webkitRequestAnimationFrame ||            function (callback) {                window.setTimeout(callback, 1000 / 60);            }        );    }();    var frame = 0;    var allFrameCount = 0;    var lastTime = Date.now();    var lastFameTime = Date.now();    var loop = function () {        var now = Date.now();        var fs = (now - lastFameTime);        var fps = Math.round(1000 / fs);        lastFameTime = now;        // 不置 0，在动画的开头及结尾记录此值的差值算出 FPS        allFrameCount++;        frame++;        if (now > 1000 + lastTime) {            var fps = Math.round((frame * 1000) / (now - lastTime));            if (fps <= 5) {                var kd = `<span style="color:#bd0000">卡成ppt🤢</span>`            } else if (fps <= 15) {                var kd = `<span style="color:red">电竞级帧率😖</span>`            } else if (fps <= 25) {                var kd = `<span style="color:orange">有点难受😨</span>`            } else if (fps < 35) {                var kd = `<span style="color:#9338e6">不太流畅🙄</span>`            } else if (fps <= 45) {                var kd = `<span style="color:#08b7e4">还不错哦😁</span>`            } else {                var kd = `<span style="color:#39c5bb">十分流畅🤣</span>`            }            document.getElementById("fps").innerHTML = `FPS:${fps} ${kd}`;            frame = 0;            lastTime = now;        };        rAF(loop);    }    loop();} else {    document.getElementById("fps").style = "display:none!important"}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/background.css"/>
      <url>/css/background.css</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>/* 页脚与头图透明 */#footer {  background: transparent !important;}#page-header {  background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}@font-face {  font-family: 'tzy';  /* 字体名自定义即可 */  /* src: url('https://cdn.jsdelivr.net/gh/tzy13755126023/BLOG_SOURCE/font/ZhuZiAWan.woff2'); */  src: url('https://npm.elemecdn.com/ethan4116-blog/lib/font/ZhuZiAWan.ttf');  /* 字体文件路径 */  font-display: swap;}body,.gitcalendar {  font-family: tzy !important;}/* 帧率检测 */#fps {  position: fixed;  /* 指定位置 */  left: 10px;  bottom: 10px;  z-index: 1919810;}[data-theme="light"] #fps {  background-color: rgba(255, 255, 255, 0.85);  backdrop-filter: var(--backdrop-filter);  padding: 4px;  border-radius: 4px;}[data-theme="dark"] #fps {  background-color: rgba(0, 0, 0, 0.72);  backdrop-filter: var(--backdrop-filter);  padding: 4px;  border-radius: 4px;}]]></content>
      
    </entry>
    
    
  
</search>
