<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>完全背包等问题</title>
      <link href="/2023/02/24/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%982/"/>
      <url>/2023/02/24/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>回顾一下<br>f[i][j] 所有只考虑前i个物品 且总体积不大于j的所有选法</p><figure class="highlight plaintext"><figcaption><span>[完全背包] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1010;</span><br><span class="line">int n,m;</span><br><span class="line">int v[N],w[N];</span><br><span class="line">int f[N][N];</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01背包(超详细透彻の基础铺垫)</title>
      <link href="/2023/02/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2023/02/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>01背包是重中之重 是其它所有背包的铺垫<br>01背包 n种物品 每种只有一个<br>完全背包 n种物品 每种无限个<br>多重背包 n种物品每种个数不一样</p><p>f[i][j]  下标0到i的物品任取 放到容量为j的背包里</p><p>01背包 每种物品仅有一件 可以选择放或者不放<br>只考虑第i件物品<br>1.如果体积超了 那么一定就是f[i-1][j]<br>2.如果不放 容量价值不变 转化为前i-1件物品放入容量为j的背包最大价值f[i-1][j]<br>3.放了之后 容量减重量 价值增加f[i-1][j-w[i]]+v[i]<br>max(f[i-1][j],f[i-1][j-w[i]]+v[i])就是对于第i件物品的最优解</p><p>f数组的初始化<br>f[i][j]<br>对应表格如下<br>       0 1 2 3 4<br>     0 a b c d e<br>     1 f g h i j<br>     2 k l m n o    </p><p>i即f[1][3]<br>由递推公式 一定是由左上角递推得到的 那么第一列第一行一定要初始化<br>背包容量为0 价值一定为0 所以第一列初始化为0<br>除此之外b一定要初始化为0 不然递推会出错 其它的非0下标不用初始化 均会被覆盖</p><figure class="highlight plaintext"><figcaption><span>[01背包二维] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1010;</span><br><span class="line">int n,m;</span><br><span class="line">int v[N],w[N];</span><br><span class="line">int f[N][N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; //注意由表格 都是从1开始遍历</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(j&lt;=v[i]) f[i][j]=f[i-1][j];</span><br><span class="line">            else  f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.f[j]与f[i][j]中j意思相同 表示容量为j的背包能装的最大价值<br>2.二维中递推公式是max(f[i-1][j],f[i-1][j-w[i]]+v[i]) 放与不放取最大值<br>在二维中不放物品是f[i-1][j] 则在一维中 不放物品 重量没变化 价值也没变化 就直接将上一层数据拷贝下来没有变化 所以还是f[j]<br>如果放物品 那么一维中需要把重量减下去 价值加上  则是f[j-w[i]]+v[i]</p><p>为什么从v[i]开始？<br>因为物品体积大了肯定装不了 那么重量价值无变化 直接拷贝</p><p>为什么二维不用倒序 一维必须倒序呢?<br>例如你现在背包容量为10 g[10] 有一个重量6 价值9的东西<br>如果不装 例 g[10]&#x3D;g[10] 因为还是取的之前的值 左边是现在更新的 右边是上一轮循环的<br>如果装 g[4]+9  这时候便是对应f[i-1][j-v[i]]+w[i] 此时的g[4]便是上一个循环里的g[4]<br>但如果从前往后循环 在你给g[10]赋值之前 g[4]已经更新了！ g[4]状态不同步 g[4]一定偏差了</p><figure class="highlight plaintext"><figcaption><span>[01背包一维优化内存] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1010;</span><br><span class="line">int n,m;</span><br><span class="line">int v[N],w[N];</span><br><span class="line">int f[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=m;j&gt;=v[i];j--) </span><br><span class="line">        &#123;</span><br><span class="line">            //f[j]=f[j]; 恒等变换后是恒等式可省略</span><br><span class="line">            f[j]=max(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双指针例题</title>
      <link href="/2023/02/16/%E5%8F%8C%E6%8C%87%E9%92%88%E4%BE%8B%E9%A2%98/"/>
      <url>/2023/02/16/%E5%8F%8C%E6%8C%87%E9%92%88%E4%BE%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不能小瞧双指针 有时候十分重要</p><figure class="highlight plaintext"><figcaption><span>[模板] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0,j=0; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    while(j&lt;i&amp;&amp;check(i,j) j++) </span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line">直接可以替代for i 循环</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最简单情况 将几个词分别输出<br>例abc def ghi</p><figure class="highlight plaintext"><figcaption><span>[例1] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char str[1000];</span><br><span class="line">    gets(str);</span><br><span class="line">    int n=strlen(str);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int j=i;</span><br><span class="line">        while(j&lt;n &amp;&amp; str[i]!=&#x27; &#x27;) j++; </span><br><span class="line">        for(int k=i;k&lt;j;k++) cout&lt;&lt;str[k]; //输出两指针之间的就行了</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[最长连续不重复子序列] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=10010;</span><br><span class="line">int a[N],s[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    int ans=0;</span><br><span class="line">     for(int i=0,j=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[a[i]]++;  //i是在j之后 从后往前的</span><br><span class="line">        while(s[a[j]]&gt;1) //此处不用j&lt;=i 因为一直有重复的话 i j最终在同一位置</span><br><span class="line">        &#123;</span><br><span class="line">            s[a[j]]--; </span><br><span class="line">            j++;//有重复 j往前移一格 有点像队列</span><br><span class="line">        &#125;</span><br><span class="line">        ans=max(i-j+1,ans); //更新长度</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要根据时间由小到大排列<br>注意对应的是什么还有答案输出</p><figure class="highlight plaintext"><figcaption><span>[acwing1238] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100010;</span><br><span class="line">pair&lt;int, int&gt; logs[N];</span><br><span class="line"></span><br><span class="line">int cnt[N];</span><br><span class="line"></span><br><span class="line">int  st[N];</span><br><span class="line">int n,d,k;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;d&gt;&gt;k;</span><br><span class="line">for(int i=0;i&lt;n;i++) cin&gt;&gt;logs[i].first&gt;&gt;logs[i].second;</span><br><span class="line">sort(logs,logs+n); //时间小到大 </span><br><span class="line">for(int i=0,j=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cnt[logs[i].second]++;</span><br><span class="line">while(logs[i].first - logs[j].first&gt;=d)</span><br><span class="line">&#123;</span><br><span class="line">cnt[logs[j].second]--;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">if(cnt[logs[i].second]&gt;=k) st[logs[i].second]=1;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(st[i]) cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>unordered_set</title>
      <link href="/2023/02/15/unordered-set/"/>
      <url>/2023/02/15/unordered-set/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>unordered_set<int> set1; 构造<br>unordered_set<int> set2(set1); 拷贝构造<br>set1.count(2); 出现次数<br>unordered_set 无序 set 容器可以和字符串哈希有着类似的作用 也可以一起用</p><p>例题acwing1460</p><figure class="highlight plaintext"><figcaption><span>[unordered_set做法] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">int n,l,r;</span><br><span class="line"></span><br><span class="line">bool check(int mid)</span><br><span class="line">&#123;</span><br><span class="line">unordered_set&lt;string&gt; hash; </span><br><span class="line">for(int i=0;i+mid-1&lt;str.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">auto s1=str.substr(i,mid);</span><br><span class="line">if(hash.count(s1)) return false; //查找出现次数 如果重复直接寄</span><br><span class="line">hash.insert(s1);</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">l=1,r=n;</span><br><span class="line">while(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">int mid=(l+r)&gt;&gt;1;</span><br><span class="line">if(check(mid)) r=mid;</span><br><span class="line">else l=mid+1; </span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串前缀哈希</title>
      <link href="/2023/02/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%93%88%E5%B8%8C/"/>
      <url>/2023/02/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>字符串前缀哈希<br>当遇到如比较两个区间内的字符是否相同时 可以用这种方法 十分快速</p><p>此方法精髓在于用数来表示哈希值 便于理解与记忆 用P&#x3D;10即十进制来理解<br>如1234<br>h[0]&#x3D;0  注意从h[1]开始存 不然A为0 算下去AA也为0 所以从1开始<br>h[1]&#x3D;h[0]<em>P+str[1]&#x3D;0</em>10+1&#x3D;1<br>h[2]&#x3D;h[1]<em>P+str[2]&#x3D;1</em>10+2&#x3D;12<br>h[3]&#x3D;h[2]<em>P+str[3]&#x3D;12</em>10+3&#x3D;123<br>h[4]&#x3D;h[3]<em>P+str[4]&#x3D;123</em>10+4&#x3D;1234</p><p>若求一个区间 如L&#x3D;3 R&#x3D;4 即34<br>则是 1234-12*10^2<br>即 h[4]-h[2]*P^2<br>即L到R之间的哈希值为 h(R)-h(L-1)*P^(R-L+1) 题里这个P的次方用数组p[]存 需要初始化一下<br>P一般取131</p><p>防止长度过长本需mod Q<br> unsigned long long来存储h 它可以溢出 溢出时就相当于模了一个2的64次方</p><figure class="highlight plaintext"><figcaption><span>[字符串前缀哈希法] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef unsigned long long ULL;</span><br><span class="line">const int N=100010,P=131;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">char str[N];</span><br><span class="line">ULL h[N],p[N];//h[]存某个前缀的哈希值 p[]存是多少次方</span><br><span class="line"></span><br><span class="line">ULL get(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    return h[r]-h[l-1]*p[r-l+1]; //本来h[r]的高位更大</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;str+1;</span><br><span class="line">    p[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=p[i-1]*P; //这一步一定要理解</span><br><span class="line">        h[i]=h[i-1]*P+str[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        int l1,r1,l2,r2;</span><br><span class="line">        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;</span><br><span class="line"></span><br><span class="line">        if(get(l1,r1)==get(l2,r2)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">        else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一般比较字符串就用这个方法</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛寒5补题</title>
      <link href="/2023/02/02/%E7%89%9B5/"/>
      <url>/2023/02/02/%E7%89%9B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>A题贪心二分前缀和<br>可以直接upper_bound(x)找到大于x的第一个数的下标再减一<br>自己感觉还是板子好用</p><figure class="highlight plaintext"><figcaption><span>[A] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long n,q,a[100010],v[100010],ans;</span><br><span class="line">long long k,x,m;</span><br><span class="line">long long check(long long x1 ) //升序 找到小于等于x的第一个下标</span><br><span class="line">&#123;</span><br><span class="line">    long long l=0,r=n;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        long long mid=(l+r+1)/2;</span><br><span class="line">        if(v[mid]&lt;=x1) l=mid;</span><br><span class="line">        else r=mid-1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i];</span><br><span class="line">    sort(v+1,v+n+1);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) a[i]=a[i-1]+v[i]; //前缀和一下 sort升序</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    while(q--)</span><br><span class="line">    &#123;</span><br><span class="line">         </span><br><span class="line">        cin&gt;&gt;k&gt;&gt;x; </span><br><span class="line">        m=check(x);</span><br><span class="line">        if(m-k&lt;=0) ans=a[m];</span><br><span class="line">        else  ans=a[m]-a[m-k];</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;    </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B题难点:读懂题<br>字典序比较就是从左往右的第一个<br>所以最优的就是每个人拿一个石子放空的格子<br>如果是偶数 大家都是这么多格子 平手<br>如果是奇数 先手多拿了一个 那么后手必胜</p><p>C题 贪心<br>长度一样只要两个串完全一样肯定是等于<br>而如1234和1243 我们只要找到第一个不一样的数 其大小关系随映射关系而变化</p><p>经典错解就是长度一样长的一定大<br>如11444和222 如果1-&gt;0 2-&gt;3 4-&gt;1 则变成了00111和333 由于前导0的存在 长的不一定大 主要矛盾就是这</p><p>解决方法就是找到让长的不一定大的方法<br>若长度分别为nx,,ny 相差nx-ny 若x的前n个数映射后有一个不为0 那么肯定x大<br>所以我们可以假设前n个数映射后都是0 再比较后面的<br>那么我们就根据前导零分类讨论找一定大于和一定小于两种情况<br>其它的都是！</p><figure class="highlight plaintext"><figcaption><span>[C] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string a, b;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cout.tie(NULL);</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">     </span><br><span class="line">    char ans = &#x27;&gt;&#x27;;//假定a更大</span><br><span class="line">    if(a.length() &lt; b.length())&#123;</span><br><span class="line">        ans = &#x27;&lt;&#x27;;//如果a更短，则为小于号</span><br><span class="line">        swap(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    int n = a.length();</span><br><span class="line">    int m = b.length();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    if(a == b) &#123;//相等就一定相等</span><br><span class="line">        cout &lt;&lt; &quot;=&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    if(n == m)&#123;//长度相等，但两者不等一定不确定答案</span><br><span class="line">        cout &lt;&lt; &quot;!&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //因为排列不同，数字间的大小就变的无意义，在一个排列下大于的是小于，另一种排列大于的还是大于</span><br><span class="line">    //长度不同，若无前导0则一定是长的大，所以我们假设a前面全是前导0最坏情况，看是否有可能 长的数 &lt;= 短的数</span><br><span class="line">    int id1 = 0;</span><br><span class="line">    for(int i = 1; i &lt; n; i ++)&#123;</span><br><span class="line">        if(a[i] == a[0]) id1 = i;</span><br><span class="line">        else break ;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //因为假设a前面全是前导0，所以若b前面数字相同的也是前导0也不能算</span><br><span class="line">    int id2 = -1;</span><br><span class="line">    for(int i = 0; i &lt; m; i ++)&#123;</span><br><span class="line">        if(b[i] == a[0]) id2 = i;</span><br><span class="line">        else break;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    int len1 = n - id1 - 1;//a最小情况下的有效长度</span><br><span class="line">    int len2 = m - id2 - 1;//b最小情况下的有效长度</span><br><span class="line"> </span><br><span class="line">    if(len1 &gt; len2)&#123;</span><br><span class="line">        cout &lt;&lt; ans;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(len1 == len2)&#123;//因为已经确定a[0]所代表的数字就是最小的0，所以还需要比较一下</span><br><span class="line">        for(int i = 1; i &lt;= len1; i ++)&#123;</span><br><span class="line">            if(a[id1 + i] == b[id2 + i]) continue;</span><br><span class="line">            if(b[id2 + i] == a[0])&#123;</span><br><span class="line">                cout &lt;&lt; ans;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else break;//a可能更小</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else cout &lt;&lt; &quot;!&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设当前答案为num 得到一个区间后 如果左端点在num里 num扩大到其右端点</p><figure class="highlight plaintext"><figcaption><span>[D] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 补题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛寒4补题</title>
      <link href="/2023/01/31/%E7%89%9B4/"/>
      <url>/2023/01/31/%E7%89%9B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>A题是个数学题<br>就是比较x的y次方和y的x次方哪个大<br>取对数就是ylnx和xlny 直接写代码比较就行</p><figure class="highlight plaintext"><figcaption><span>[A] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    long long  x,y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    double x1=y*log(x);</span><br><span class="line">    double y1=x*log(y);</span><br><span class="line">    if(x1==y1) cout&lt;&lt;min(x,y);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(x1&gt;y1) cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">        else cout&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>L题解方程组 注意题目要的是正整数</p><p>E题<br>将情况分为两类 全死或打不死 只考虑打不死的情况 只要一个怪打不死那么就失败<br>先v[i]<em>&#x3D;t 就是一次加多少血<br>分析可知攻击间隔t</em>恢复速度v[i]若大于等于攻击力a 且一刀没打死 那么永远打不死<br>一开始就检查是否全死<br>如何求花多少时间呢<br>由题意 如果不能秒杀 那么这怪物必定会掉血+回血一次循环 而最后一次攻击 击杀死亡就不会回血<br>一个攻击 回血循环扣的血量 delta&#x3D;a-v (如果此次扣的血量小于等于0 无解)<br>所以我们先把最后一刀放到最前面来算<br>轮数就是这个怪先砍最后一刀剩下的血量除以一次循环扣的血量向上取整 再加1(最后一刀)<br>总时间就是(总轮数-1)*时间间隔+1</p><figure class="highlight plaintext"><figcaption><span>[E] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=100005;</span><br><span class="line">long long n,t,a,ans,h[MAXN],v[MAXN];</span><br><span class="line">bool check()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(v[i]&gt;=a&amp;&amp;h[i]&gt;a)return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">long long f(const long long &amp;h,const long long &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    if(h&lt;=a)return 1;</span><br><span class="line">    long long delta=a-v;</span><br><span class="line">    return ceil( ((h-a)*1.0)/delta)+1;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;t,&amp;a);</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%lld %lld&quot;,&amp;h[i],&amp;v[i]);</span><br><span class="line">        v[i]*=t;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!check())</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;-1&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=f(h[i],v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,(ans-1)*t+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>b题数论大礼包<br>cd是背包问题 日后填坑</p><p>L简单数学题 注意要判断小数的情况</p><figure class="highlight plaintext"><figcaption><span>[L] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long v[10],a[10],sum;</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">long long v1,v2,v3;</span><br><span class="line">cin&gt;&gt;v[0]&gt;&gt;v[1]&gt;&gt;v[2];</span><br><span class="line">sum=(v[0]+v[1]+v[2])/2;</span><br><span class="line">    if(sum*2!=v[0]+v[1]+v[2]) //如果有边不是整数</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;3;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=sum-v[i];</span><br><span class="line">        if(v[i]&lt;=a[i] ||v[i]&lt;=0) break;</span><br><span class="line">        else ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans!=3) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; </span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">        for(int i=0;i&lt;3;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line">while(T--)</span><br><span class="line">&#123;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>M题告诉我们 非传统题样例(specialjudge)可能是骗人的 样例是斐波那契数列 然而并不是<br>只需要一直输出112112112。。就行了</p>]]></content>
      
      
      <categories>
          
          <category> 补题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/01/28/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
      <url>/2023/01/28/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>牛寒3补题</title>
      <link href="/2023/01/27/%E7%89%9B3%E8%A1%A5%E9%A2%98/"/>
      <url>/2023/01/27/%E7%89%9B3%E8%A1%A5%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自己太菜 只过了四道签到题 必须好好补补题</p><p>A题重大教训 没有用long long 浪费了几次提交</p><p>D是博弈题<br>结论是只要是偶数 先手必胜<br>一个奇数的因数一定是奇数 因为如果是偶数 这个偶数与某个整数的乘积一定不会是奇数<br>这个奇数减掉某个因子后 就变成了偶数<br>所以</p><ol><li>偶数总可以变成奇数</li><li>奇数只可以变成偶数</li><li>1是奇数 谁拿到谁就输了<br>综上 总拿到奇数的肯定就输了<br>这道题其实很简单 但是自己没去想过这种博弈问题</li></ol><p>C题是一个构造题<br>构造题也没做过 想不出什么思路呜呜<br>原则是找到有既有一般性又有可行性的方式<br>一般考虑将输入分成几类 再分别构造 以满足所有情况</p><p>实例是3 4 1 2 则可以构造出n&#x3D;4k的所有情况 如n&#x3D;8则有3 4 1 2 7 8 5 6<br>n&#x3D;5时可以构造出4 5 1 2 3 n&#x3D;6时有4 5 6 1 2 3<br>这样 n&#x3D;4k+5 n&#x3D;4k+6 n&#x3D;4k+11分别就是nmod4为1 2 3的情况 就覆盖了基本所有整数<br>但是n&#x3D;7 n&lt;4是肯定无解的需要特判</p><figure class="highlight plaintext"><figcaption><span>[C忽远忽近的距离] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">if(n &lt;= 3 || n==7) </span><br><span class="line">    &#123;</span><br><span class="line">cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n%2==0) //如果是偶数 只有是四的倍数以及其它</span><br><span class="line">    &#123;</span><br><span class="line">        if(n%4==0)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1; i&lt;=n/4; i++) //看是几倍</span><br><span class="line">            &#123;</span><br><span class="line">                int m=i*4;</span><br><span class="line">                cout&lt;&lt;m-1&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;m-3&lt;&lt;&quot; &quot;&lt;&lt;m-2&lt;&lt;&quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else //那么就是6的倍数了</span><br><span class="line">        &#123;</span><br><span class="line">            int p=n-6; //先把最后六个数单独拿出来 把可能的四的倍数用完</span><br><span class="line">            for(int i=1; i&lt;=p/4; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                int m=i*4;</span><br><span class="line">                cout&lt;&lt;m-1&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;m-3&lt;&lt;&quot; &quot;&lt;&lt;m-2&lt;&lt;&quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;n - 2&lt;&lt;&quot; &quot;&lt;&lt;n - 1&lt;&lt;&quot; &quot;&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;n - 5&lt;&lt;&quot; &quot;&lt;&lt;n - 4&lt;&lt;&quot; &quot;&lt;&lt;n - 3&lt;&lt;&quot; &quot;; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">int m = n - 5;</span><br><span class="line">if(m % 4 == 0) //如果拿出最后五个剩下是四的倍数 直接就用了</span><br><span class="line">        &#123;</span><br><span class="line">for(int i = 1;i &lt;= m / 4;i++) </span><br><span class="line">            &#123;</span><br><span class="line">int x = i * 4;</span><br><span class="line">cout&lt;&lt;x-1&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;x-3&lt;&lt;&quot; &quot;&lt;&lt;x-2&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">        &#123;</span><br><span class="line">int mm = m - 6;//一个奇数 减去5 还不是四的倍数 只能是六的倍数了 把最后六个再拿出来 把四的倍数用光</span><br><span class="line">for(int i = 1;i &lt;= mm / 4;i++) </span><br><span class="line">            &#123;</span><br><span class="line">int x = i * 4;</span><br><span class="line">cout&lt;&lt;x-1&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;x-3&lt;&lt;&quot; &quot;&lt;&lt;x-2&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;m - 2&lt;&lt;&quot; &quot;&lt;&lt;m-1&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;m-5&lt;&lt;&quot; &quot;&lt;&lt;m-4&lt;&lt;&quot; &quot;&lt;&lt;m-3&lt;&lt;&quot; &quot;; //输出拿出的6</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;n-1&lt;&lt;&quot; &quot;&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;n-4&lt;&lt;&quot; &quot;&lt;&lt;n-3&lt;&lt;&quot; &quot;&lt;&lt;n-2&lt;&lt;&quot; &quot;; //输出拿出的5</span><br><span class="line">&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慢慢学习这种思考方式</p><p>B题更是闻所未闻了 二分图 感觉很思维<br>主要是不理解为什么那样摆放是最优解? 虽然感觉是正确的<br>1.摆放后解不等式可以直接得答案<br>2.可以二分答案<br>3.把图画出来找规律(12个起步)</p><figure class="highlight plaintext"><figcaption><span>[勉强拼凑的记忆] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">long long i,j,k,n,m,t,l,r,res,md;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">ios::sync_with_stdio(0);</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">if(n==2)</span><br><span class="line">        &#123;</span><br><span class="line">cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">            continue;</span><br><span class="line">&#125;</span><br><span class="line">l=1;r=n;res=0;</span><br><span class="line">i=(n+1)/2;</span><br><span class="line">while(l&lt;=r)&#123;</span><br><span class="line">md=(l+r)/2;</span><br><span class="line">k=(md/i)*md+(md%i)*((md+i-1)/i);  //通过画图得的关系式</span><br><span class="line">if(k&lt;=n)&#123;</span><br><span class="line">res=max(res,md);l=md+1;</span><br><span class="line">&#125;</span><br><span class="line">else r=md-1;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;res&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>E题 高中数学题 向量算算就能得答案</p><p>K题 数学大礼包 考查因字数公式 逆元等<br>H题 dp<br>J题 反悔贪心？<br>留坑</p>]]></content>
      
      
      <categories>
          
          <category> 补题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛寒1补题</title>
      <link href="/2023/01/22/%E7%89%9B1%E8%A1%A5%E9%A2%98/"/>
      <url>/2023/01/22/%E7%89%9B1%E8%A1%A5%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以后学习这种解题写法<br>一道简单模拟<br>当时卡了一会儿就是因为“当前双方比分已经使得无论之后的罚球结果如何都不会影响比赛的结果”没有转过来 用了一个变量记轮数<br>其实不用  只需要两个新变量记剩下几个球可以进就可以了</p><figure class="highlight plaintext"><figcaption><span>[A模拟点球] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void work()</span><br><span class="line">&#123;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">int a=0,b=0,la=5,lb=5;</span><br><span class="line">for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">if(i%2)&#123;</span><br><span class="line">lb--;</span><br><span class="line">if(s[i]==&#x27;1&#x27;)&#123;</span><br><span class="line">b++;</span><br><span class="line">if(b&gt;a+la)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,i+1);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(a&gt;b+lb)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,i+1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">la--;</span><br><span class="line">if(s[i]==&#x27;1&#x27;)&#123;</span><br><span class="line">a++;</span><br><span class="line">if(a&gt;b+lb)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,i+1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(b&gt;a+la)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,i+1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;-1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int m;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">while(m--)</span><br><span class="line">&#123;</span><br><span class="line">work();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>头一次遇到这种诈骗题 说是dfs 其实不用还原拼图<br>直接总造价&#x3D;给出拼图的造价+确实拼图的造价</p><figure class="highlight plaintext"><figcaption><span>[拼图] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0); </span><br><span class="line">int T; </span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line">while(T--)</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">int ans=10;  </span><br><span class="line">string s;</span><br><span class="line">for(int i=0;i&lt;n*n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">for(int j=0;j&lt;4;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[j]==&#x27;1&#x27;) ans++;</span><br><span class="line">else if(s[j]==&#x27;2&#x27;) ans--;</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"> cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line">return 0;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上就是推数学公式<br>首先得读懂题意 大致就是给了(0,0) (x,y)的一个矩形 给你一个点xp yp作为顶点<br>求这个点与其对角顶点构成的矩形和之前矩形的 交集&#x2F;并集最大<br>实际上就要分类讨论xp yp对于x y的相对位置<br>如果在右上 那么对角顶点肯定是0 0<br>如果在左下 枚举(0,0)(x,y)的四个顶点<br>在左上 枚举(0,0) (x,0)两个顶点<br>在右下 枚举(0,0) (y,0)两个顶点<br>猜结论比较困难感觉</p><figure class="highlight plaintext"><figcaption><span>[学术时间] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int x,y,px,py;</span><br><span class="line"> </span><br><span class="line">void work()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y&gt;&gt;px&gt;&gt;py;</span><br><span class="line">    double ans;</span><br><span class="line">    if(px&lt;=x&amp;&amp;py&lt;=y)ans=1.0*max(&#123;px*py,(x-px)*py,px*(y-py),(x-px)*(y-py)&#125;)/(x*y);</span><br><span class="line">    else if(px&gt;x&amp;&amp;py&gt;y)ans=1.0*x*y/(px*py);</span><br><span class="line">    else if(px&lt;=x)ans=max(1.0*y*px/(x*y+px*(py-y)),1.0*y*(x-px)/(x*y+(x-px)*(py-y)));</span><br><span class="line">    else ans=max(1.0*x*py/(x*y+py*(px-x)),1.0*x*(y-py)/(x*y+(y-py)*(px-x)));</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(0);</span><br><span class="line">    cin.tie(0);cout.tie(0);</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;setprecision(9);</span><br><span class="line">    int _=1;</span><br><span class="line">    cin&gt;&gt;_;</span><br><span class="line">    while(_--)</span><br><span class="line">        work();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面是快读模板<br>当时看到是动态规划就放弃了 学都没学到<br>但是现在看来其实非常巧妙<br>首先满足条件:字符串长为n m个字符为1<br>所以怎么坏区间总数最少呢?<br>那么就是<br>前缀都是100 100 100 这样是好区间<br>把1都堆到最后 这样一个坏区间就占了3个1<br>枚举i 前i个都变成100 100这种 后面全部是1 当前得出坏区间个数和之前答案取小的</p><figure class="highlight plaintext"><figcaption><span>[本题主要考查dp] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;ll, ll&gt; PII;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">inline ll read() &#123;</span><br><span class="line">    char ch;</span><br><span class="line">    ll x = 0;</span><br><span class="line">    bool f = true;</span><br><span class="line">    for (ch = getchar(); !isdigit(ch); ch = getchar())</span><br><span class="line">        if (ch == &#x27;-&#x27;)</span><br><span class="line">            f ^= f;</span><br><span class="line">    for (; isdigit(ch); ch = getchar())</span><br><span class="line">        x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - 48;</span><br><span class="line">    return f ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    int n=read(),m=read(),t = n - m;</span><br><span class="line">    vector&lt;int&gt; s;</span><br><span class="line">    while(m || t)&#123;</span><br><span class="line">        if(m)s.push_back(1),m--; </span><br><span class="line">        if(t)s.push_back(0),t--;</span><br><span class="line">        if(t)s.push_back(0),t--;//这三步就巧妙实现了100100..1111</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0 ;</span><br><span class="line">    for(int i=1;i&lt;n-1;i++)</span><br><span class="line">        if(s[i] + s[i-1] + s[i+1] &gt;=2)</span><br><span class="line">            ans ++;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt;&quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int T = 1;</span><br><span class="line">    for (int i = 1; i &lt;= T; i++)</span><br><span class="line">        solve();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此处跳过两道dp 日后填坑</p>]]></content>
      
      
      <categories>
          
          <category> 补题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛寒2补题</title>
      <link href="/2023/01/19/%E7%89%9B2%E8%A1%A5%E9%A2%98/"/>
      <url>/2023/01/19/%E7%89%9B2%E8%A1%A5%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一题和第二题只是数据不同<br>第一题可以通过a+b&#x3D;n 不枚举第二个区间 直接把b算成n-a就能过<br>第二题只要有枚举那么必超时 所以肯定是推式子<br>可知答案是取[L2,R2] [n-R1,n-L1]的交集<br>求交集有固定写法<br>这个交集就是[max(L2,n-R1),min(R2,n-L1)]<br>当然可能没有交集 所以最后要和0max一下</p><figure class="highlight plaintext"><figcaption><span>[a+b=n] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,l1,r1,l2,r2,a;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0); </span><br><span class="line">    int a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    while(a--)</span><br><span class="line">    &#123;</span><br><span class="line">        int tot=0;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        cin&gt;&gt;l1&gt;&gt;r1;</span><br><span class="line">        cin&gt;&gt;l2&gt;&gt;r2;</span><br><span class="line">        l1=max(l1,n-r2);</span><br><span class="line">        r1=min(r1,n-l2);</span><br><span class="line">        tot=max(0,r1-l1+1);</span><br><span class="line">        cout&lt;&lt;tot&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>j题是个奇怪的思维题 结论就是2n*(abs(a1)+abs(a2)+….+abs(an))<br>是通过数轴上分类讨论知道的</p><figure class="highlight plaintext"><figcaption><span>[j] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void work()</span><br><span class="line">&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    LL ans=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int m;</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        ans+=n*std::abs(m);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans*2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    int T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>H题 萌新必学题?<br>集训2最妙的一道题</p><p>单独考虑算贡献</p><p>不同种类数之间单独考虑如1111223<br>若2 3已放只考虑1的放法 2和3对答案的贡献是不会变的</p><p>那么我们假设只考虑1 1出现了x次 要分成k个子序列<br>贡献最大的情况便可以分类讨论一下 </p><p>就是x&gt;k时 前k-1个子序列都放一个1 剩下的都放到最后一个子序列 这样就贡献了k-1<br>若x&lt;&#x3D;k 那么每个子序列放一个1就行了 总共为答案贡献了x </p><p>知道以上信息 若k是定值 就可以做了<br>但是题目要求输出k为1到n的所有情况 所以还需要特殊处理</p><p>若从k&#x3D;n开始减 若k一直大于等于最大的每个数出现的个数x(某个)时 贡献就是每个数的x相加 这不会变<br>变化的情况就是k&#x3D;x(max)-1<br>那么我们用一个set集合存这个变化的贡献</p><figure class="highlight plaintext"><figcaption><span>[h] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int T,n,a[100010],c[100010];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        memset(c,0,sizeof(c));</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">            c[a[i]]++;  </span><br><span class="line">        &#125;</span><br><span class="line">        multiset&lt;int&gt;st; //不会去掉重复元素的集合 存每种数的x(出现次数)</span><br><span class="line">        for(int i=1;i&lt;=100000;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            st.insert(c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        long long lesum=0,ge=((int)st.size());</span><br><span class="line">        // ge存有多少种数的出现次数大于k</span><br><span class="line">        for(int i=1;i&lt;=n;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            while(!st.empty()&amp;&amp;*st.begin()&lt;=i) </span><br><span class="line">            &#123;</span><br><span class="line">                lesum+=(long long)(*st.begin()); </span><br><span class="line">                // 若这个数的出现次数小于等于k 那么这个数的贡献就是出现次数</span><br><span class="line">                st.erase(st.begin());</span><br><span class="line">                ge--; //</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;lesum+ge*(i-1)&lt;&lt;endl; //对于这个k 总贡献就是lesum与剩下的数的贡献之和 剩下的这些数的出现次数都大于k 所以每种数的贡献都是k-1</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d题是一个树的dfs<br>是用到了一个经典但我没见过的结论 两个向量内部允许任意重排 点积最大为升序排列</p><p>也就是深度序列由小向大排列 能量值序列由小向大排列 相乘相加</p><p>那么剩下就是如何求每个节点的深度了 便用dfs</p><figure class="highlight plaintext"><figcaption><span>[h] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,fa[200010];</span><br><span class="line">vector&lt;int&gt; g[200010];</span><br><span class="line">long long v[200010],dep[200010];</span><br><span class="line">void dfs(int now,int d) //求每个节点的depth</span><br><span class="line">&#123;</span><br><span class="line">    dep[now]=d;</span><br><span class="line">    for(auto to:g[now])</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(to,d+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;fa[i];</span><br><span class="line">        g[fa[i]].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i];</span><br><span class="line">    dfs(1,1);</span><br><span class="line">    sort(v+1,v+1+n);</span><br><span class="line">    sort(dep+1,dep+1+n);</span><br><span class="line">    long long ans=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=dep[i]*v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 补题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>宽度优先搜索BFS</title>
      <link href="/2023/01/09/%E5%AE%BD%E6%90%9CBFS/"/>
      <url>/2023/01/09/%E5%AE%BD%E6%90%9CBFS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>BFS<br>1.是宽度搜索 一次搜一层<br>2.使用队列<br>3.空间O(2^n)<br>4.最短路<br>最短路问题包含dp问题</p><p>acwing844<br>经典的走迷宫问题<br>这道题深搜能获得答案 但是不能保证路径最短<br>广搜模板性质更强</p><figure class="highlight plaintext"><figcaption><span>[宽搜] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt;PII;</span><br><span class="line">const int N=110;</span><br><span class="line">int n,m;</span><br><span class="line">int g[N][N];//存图</span><br><span class="line">int d[N][N];//存到起点的距离</span><br><span class="line">PII q[N*N];</span><br><span class="line"></span><br><span class="line">int bfs()</span><br><span class="line">&#123;</span><br><span class="line">    int hh=0,tt=0; //手写一个队列</span><br><span class="line">    q[0]=&#123;0,0&#125;;</span><br><span class="line"></span><br><span class="line">    memser(d,-1,sizeof(d)); // 先将图上所有点的距离初始化 表示没走过</span><br><span class="line">    d[0][0]=0; //起点已经走过了</span><br><span class="line"></span><br><span class="line">    int dx[4]=&#123;-1,0,1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;</span><br><span class="line">    while(hh&lt;=tt) //如果队列不空</span><br><span class="line">    &#123;</span><br><span class="line">        auto t=q[hh++]; //每一次取出队头</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;4;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            int x=t.first+dx[i],y=t.second+dy[i];//往上下左右拓展 得到拓展后坐标</span><br><span class="line">            if(x&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;m&amp;&amp;g[x][y]==0&amp;&amp;d[x][y]=-1)//在边界内 可走且没走过 可以拓展</span><br><span class="line">            &#123;</span><br><span class="line">                d[x][y]=d[t.first][t.second]+1;//被拓展的点距离加1</span><br><span class="line">                q[++tt]=&#123;x,y&#125;;//再把这个点入列 之后从这个点开始拓展</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return d[n-1][m-1]; //这是根据题意 输出终点的距离值</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;m;j++) cin&gt;&gt;g[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;bfs()&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果想要求路径 那么定义一个数组 bfs中每一次移动的时候存一下移动前的下标<br>从终点开始推</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树和图的优先遍历</title>
      <link href="/2023/01/08/%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
      <url>/2023/01/08/%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>tips:树是一种特殊的图 是无环连通图</p><p>有向图边有方向 如a-&gt;b<br>无向图边没有方向 a&lt;-&gt;b<br>无向图是特殊的有向图 我们就先理解有向图的储存</p><p>1.邻接矩阵 其实就是一个二维数组 g[a][b]就存储a-&gt;b 有权重就是权重 没有就是bool值表示有无边 邻接矩阵不能有重边 只能保留一条 这个比较浪费空间</p><p>2.邻接表 就是n个节点 每个都开单链表 就跟哈希拉链法一样</p><figure class="highlight plaintext"><figcaption><span>[树的存储] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=10010,M=N*2;</span><br><span class="line"></span><br><span class="line">int h[N],e[N],ne[N];  //h链表头 e节点的值 ne指每个节点的next指针 与之前的单链表一样</span><br><span class="line"></span><br><span class="line">void add(int a, int b) //添加一条边a-&gt;b</span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=b; //新用到的节点值为b</span><br><span class="line">    ne[idx]=h[a];//这个节点的next指针指向a所在点的链表原本的头结点</span><br><span class="line">    h[a]=idx; //更新头节点</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    memset(h,-1,sizeof h); //和单链表head初始化-1一样 现在把所有链表都初始化</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[树的重心(dfs用法)] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=10010,M=N*2;</span><br><span class="line">bool st[N]; //存有没有遍历过</span><br><span class="line"></span><br><span class="line">int h[N],e[N],ne[N]; </span><br><span class="line"></span><br><span class="line">void add(int a, int b) </span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=b; </span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx; </span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    memset(h,-1,sizeof h); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    st[u]=true;</span><br><span class="line"></span><br><span class="line">    for(int i=h[u];i!=-1;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        int j=e[i]; </span><br><span class="line">        if(!st[j]) dfs(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>stl 2.0</title>
      <link href="/2023/01/06/stl2-0/"/>
      <url>/2023/01/06/stl2-0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>系统为某一个程序分配空间时,所需时间基本与空间大小无关,与申请次数有关<br>例 vector最开始就分配了32位空间 不够时再申请64的空间 将之前的copy过来<br>实际上是一个倍增的思想</p><figure class="highlight plaintext"><figcaption><span>[vector与pair] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; a(10); //定义长度为10的vector</span><br><span class="line">vector&lt;int&gt; b(10,3); //长度为10且初始化为3的vector</span><br><span class="line"></span><br><span class="line">a.size();//a元素个数 所有容器都有 时间复杂度O(1)</span><br><span class="line">a.empty();//返回是否为空</span><br><span class="line">a.clear(); //清空 注意队列没有clear</span><br><span class="line">a.front();//首位</span><br><span class="line">a.back();//末位</span><br><span class="line">push_back(); //末尾添加</span><br><span class="line">pop_back(); //删掉最后一个数</span><br><span class="line">a.erase(a.begin()+2); //删除第3个元素</span><br><span class="line">a.insert(a.begin()+i,b); //在第i+1个元素前面插入b;</span><br><span class="line">begin() end() //迭代器 前者就是a[0] 后者是最后一个数后面的一个数a[a.size]</span><br><span class="line">[] //可以和数组一样</span><br><span class="line"></span><br><span class="line">//推荐的遍历方式</span><br><span class="line">1. for(int i=0;i&lt;a.size;i++) cout&lt;&lt;a[i];</span><br><span class="line">2. for(auto x:a) cout&lt;&lt;x;</span><br><span class="line"></span><br><span class="line">//常用于多属性 排序 等于一个结构体</span><br><span class="line">pair&lt;int string&gt; p; //定义 中间两个类型参考要求</span><br><span class="line"></span><br><span class="line">//也可以存三个属性</span><br><span class="line">pair&lt;int,pair&lt;int,int&gt;&gt;p2;</span><br><span class="line"></span><br><span class="line">p.first; //一对pair中第一个元素</span><br><span class="line">p.second;</span><br><span class="line">p=&#123;20,&quot;abc&quot;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用字符数组存不方便 string方便</p><figure class="highlight plaintext"><figcaption><span>[string] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string a=&quot;abc&quot;;</span><br><span class="line">a+=&quot;def&quot;; //可以直接这么加</span><br><span class="line"></span><br><span class="line">string b=a.substr(1,2); //从下标为1的元素开始截取长度为2的字串 此处就是bc</span><br><span class="line">//如果长度超过了 那么就输出到最后一个字符为止</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>queue 队列 先进先出</p><figure class="highlight plaintext"><figcaption><span>[队列] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queue 队列</span><br><span class="line">push() 队尾插入</span><br><span class="line">pop() 弹出队头元素</span><br><span class="line">front()</span><br><span class="line">back()</span><br><span class="line">//注意没有队列clear函数 可以直接</span><br><span class="line">queue&lt;int&gt;q;</span><br><span class="line">q=queue&lt;int&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>priority queue 优先队列 就是堆</p><figure class="highlight plaintext"><figcaption><span>[优先队列] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;int&gt; heap; //一定要注意 优先队列默认大根堆</span><br><span class="line"></span><br><span class="line">heap.push(-x); // 想弄小根堆 都插负数就行了</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q1; //或者这样</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>栈和之前的基本一致 该有的都有</p><figure class="highlight plaintext"><figcaption><span>[栈] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push() //向栈顶插入一个元素</span><br><span class="line">top() //返回栈顶元素</span><br><span class="line">pop() //弹出栈顶元素</span><br><span class="line">size...empty...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>双端队列deque 之前没怎么见过<br>是一种在两端均可以扩展或者收缩的序列化容器 可以在头部和尾部进行插入和删除操作<br>就是个升级版vector 缺点是速度较慢</p><figure class="highlight plaintext"><figcaption><span>[deque] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size..empty...clear...</span><br><span class="line">push_back()/pop_back() </span><br><span class="line">push_front()/pop_front() //头尾插入删除</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有时可能出现需要去掉重复元素的情况 而且有可能因这些元素比较大或者类型不是int型而不能直接开散列表 在这种情况下就可以用set来保留元素本身而不考虑它的个数<br>就相当于集合</p><figure class="highlight plaintext"><figcaption><span>[set/multiset] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt;S; //set里不会有重复元素 插入重复元素的操作会被忽略</span><br><span class="line">multiset&lt;int&gt;Q; //可以有重复元素</span><br><span class="line">size()..empty()</span><br><span class="line">insert() //插入</span><br><span class="line">find() 查找一个数 不存在返回end迭代器</span><br><span class="line">count() 返回某个数的个数</span><br><span class="line">erase()</span><br><span class="line">      (1) 输入一个数x 删除所有x    O(k+logn)</span><br><span class="line">      (2) 输入一个迭代器,删除这个迭代器(针对有重复元素的multiset)</span><br><span class="line">lower_bound(x) 返回大于等于x的最小的数的迭代器</span><br><span class="line">upper_bound(x) 返回大于x的最小的数的迭代器 如果没有返回end迭代器</span><br><span class="line">例子</span><br><span class="line">int a[] = &#123;1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4&#125;;</span><br><span class="line">cout &lt;&lt; (lower_bound(a, a + 12, 4) - a) &lt;&lt; endl;//输出9即第一个大于等于4的数的下标</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>map参考stl.map</p>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希散列表</title>
      <link href="/2023/01/05/%E5%93%88%E5%B8%8C%E6%95%A3%E5%88%97%E8%A1%A8/"/>
      <url>/2023/01/05/%E5%93%88%E5%B8%8C%E6%95%A3%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>将-10^9-10^9的数指向0-10^5的数 称为哈希函数<br>一般情况 x mod 10^5<br>但是这个简单方法可能将两个数映射到一个数而冲突</p><p>1.拉链法 如果两条链是冲突的 那么在同一位置用一个链将两个数都存下来<br>2.开放寻址法 (感觉这个简单一点)</p><figure class="highlight plaintext"><figcaption><span>[拉链法模拟散列表] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100003; //模的数是质数且离2的n次方远 冲突概率最小</span><br><span class="line">int h[N];//&quot;给拉链开槽&quot;</span><br><span class="line">int e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line">void insert(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int k= (x%N+N)%N; //c++里负数mod整数是负数 modN再+N再modN就是正的 k就是哈希值</span><br><span class="line">    e[idx]=k; //先把新点值赋好</span><br><span class="line">    ne[idx]=h[k]; //这一点的next指针指向槽里的下一个点</span><br><span class="line">    h[k]=idx;//再让h[k]指向新点</span><br><span class="line">    idx++;</span><br><span class="line">    //插入操作 让新的点的next指针为h[k],让h[k]再指向这个新点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int k=(x%N+N)%N;</span><br><span class="line">    for(int i=h[k];i!=-1;i=ne[i])</span><br><span class="line">        if(e[i]=x)</span><br><span class="line">            return true;</span><br><span class="line">        else return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    memset(h,-1,sizeof h); //清空</span><br><span class="line">    while(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        char op[2];</span><br><span class="line">        int x;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">        if(*op==&#x27;I&#x27;) insert(x);</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(find(x)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">            else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开放寻址法不用开链表 但是一维数组开的长度要是题目的三倍<br>添加操作:先算k 从数组中第k个开始找 找到第一个空的就填<br>查找操作: 也是从第k位开始找 如果有数 对比是不是k 不是就找下一个 如果找到空就不存在<br>删除(不常用): 查找到后bool标记</p><figure class="highlight plaintext"><figcaption><span>[开放寻址法模拟散列表] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=200003; //需要开两到三倍</span><br><span class="line">const int null=0x3f3f3f; //在数据之外的一个数 表示此位置无数</span><br><span class="line">int h[N];</span><br><span class="line">int e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line">bool find(int x) </span><br><span class="line">&#123;</span><br><span class="line">    int k=(x%N+N)%N;</span><br><span class="line">    </span><br><span class="line">    while(h[k]!=null&amp;&amp;h[k]!=x) //如果这个位置有数 且不等于x 就下个位置</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        if(k==N) k=0; //如果直到最后也没找到 从0开始循环</span><br><span class="line">    &#125;</span><br><span class="line">    return k; //如果存在返回下标 不然返回应该存储的位置的下标</span><br><span class="line">              //所以如果h[k]=null 那么就说明没有这个数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    memset(h,0x3f,sizeof h); //全初始化为null</span><br><span class="line">    while(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        char op[2];</span><br><span class="line">        int x;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">        if(*op==&#x27;I&#x27;) //插入</span><br><span class="line">        &#123;</span><br><span class="line">            int k=find(x);</span><br><span class="line">            h[k]=x;</span><br><span class="line">        &#125;</span><br><span class="line">        else //查找</span><br><span class="line">        &#123;</span><br><span class="line">            if(h[k]!=null) cout&lt;&lt;&quot;Yes&quot;;</span><br><span class="line">            else cout&lt;&lt;&quot;No&quot;; //如果h[k]是null  所以k不存在</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/2023/01/04/%E5%A0%86/"/>
      <url>/2023/01/04/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>就是stl里的优先队列<br>堆是一棵完全二叉树<br>除了最后一层 上面所有节点都是满的 最后一层是从左到右排列</p><p>小根堆 每一个点都小于等于左右子节点的 根节点就是最小值<br>存储<br>根节点是1 x的左儿子是2x 右儿子是2x+1 </p><p>1.插入一个数 heap[++size]&#x3D;x; up[size];<br>2.求集合当中最小值 heap[1]; 根节点就是最小的<br>3.删除最小值 heap[1]&#x3D;heap[size]; size–; down(1); 用尾节点替换最小的堆顶 向下调整<br>4.删除任意一个元素 heap[k]&#x3D;heap[size]; size–; down(k);up(k) &#x2F;&#x2F;不知大小关系<br>5.修改任意一个元素 heap[k]&#x3D;x; down(x);up(x);&#x2F;&#x2F;同理 不知大小关系直接down了在up</p><figure class="highlight plaintext"><figcaption><span>[堆排序] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//思路就是将序列建成堆结构 每一次输出堆顶</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int h[N].size;</span><br><span class="line"></span><br><span class="line">void down(int u) //往下调整 up是往上调整</span><br><span class="line">&#123;</span><br><span class="line">    int t=u;</span><br><span class="line">    if (u*2&lt;=size &amp;&amp; h[u*2]&lt;h[t]) t=u*2;</span><br><span class="line">    if (u*2+1&lt;=size &amp;&amp; h[u*2+1]&lt;h[t]) t=u*2+1; //经过操作t是u和其两个儿子里最小的</span><br><span class="line">    if(u!=t) //如果u不是三个节点里最小的</span><br><span class="line">    &#123;</span><br><span class="line">        swap(h[u],h[t]);</span><br><span class="line">        down(t);//对交换前儿子节点的下标进行递归操作</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void up(int u)</span><br><span class="line">&#123;</span><br><span class="line">    while(u/2 &amp;&amp; h[u/2]&gt;h[u] ) //由于向下取整 两个儿子除二就是父节点</span><br><span class="line">    &#123;</span><br><span class="line">        swap(h[u],h[u/2]);</span><br><span class="line">        u/=2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;h[i];</span><br><span class="line">    size=n;</span><br><span class="line"></span><br><span class="line">    for(int i=n/2;i;i--) down(i);//建堆 二分之n是从倒数第二层开始调整每一个点 保证每一次down的时候下面的两个儿子已经是堆了</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;h[1];//根节点是最小的 将其输出后用尾节点替换 再将尾节点删除 递归down</span><br><span class="line">        h[1]=h[size];</span><br><span class="line">        size--;</span><br><span class="line">        down(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>I x 插入一个数x<br>PM 输出当前集合中最小值<br>DM 删除当前集合最小值(不唯一时删除最早插入的)<br>D k 删除第k个插入的数<br>C k x 修改第k个插入的数为x</p><figure class="highlight plaintext"><figcaption><span>[模拟堆] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int h[N],size;</span><br><span class="line">int ph[N],hp[N]; //ph[k]存第k个插入的数的下标 hp[q]存堆中下标为q的 点是第几个插入的点 ph与hp是类似于反函数的关系</span><br><span class="line"></span><br><span class="line">//因为要准确知道第k个数 手写维护映射关系比较麻烦 直接新定义个swap</span><br><span class="line">void heap_swap(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    swap(ph[hp[a]],ph[hp[b]]); //a b是第a1 b1个插入的点 将第a1 b1个插入的数的下标交换</span><br><span class="line">    swap(hp[a],hp[b]);</span><br><span class="line">    swap(h[a],h[b]); //交换值</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void down(int u)</span><br><span class="line">&#123;</span><br><span class="line">    int t=u;</span><br><span class="line">    if (u*2&lt;=size &amp;&amp; h[u*2]&lt;h[t]) t=u*2;</span><br><span class="line">    if (u*2+1&lt;=size &amp;&amp; h[u*2+1]&lt;h[t]) t=u*2+1;</span><br><span class="line">    if(u!=t) </span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u,t);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void up(int u)</span><br><span class="line">&#123;</span><br><span class="line">    while(u/2 &amp;&amp; h[u/2]&gt;h[u] ) </span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(h[u],h[u/2]);</span><br><span class="line">        u/=2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m=0; // m表示第k个插入的数</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        char op[10];</span><br><span class="line">        int k,x;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        if(!strcmp(op,&quot;I&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            size++;</span><br><span class="line">            m++;</span><br><span class="line">            ph[m]=size,hp[size]=m;</span><br><span class="line">            h[size]=x;</span><br><span class="line">            up(size); //插入是插到最后嘛 由下而上ip</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!strcmp(op,&quot;PM&quot;)) cout&lt;&lt;h[1];</span><br><span class="line">        else if(!strcmp(op,&quot;DM&quot;)) //删除堆顶</span><br><span class="line">        &#123;</span><br><span class="line">            heap_swap(1,size);</span><br><span class="line">            size--;</span><br><span class="line">            down(1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!strcmp(op,&quot;D&quot;)) //删除第k个插入的元素</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            k=ph[k]; //第k个插入的数的下标</span><br><span class="line">            heap_swap(k,size);</span><br><span class="line">            size--;</span><br><span class="line">            down(k),up(k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else //修改第k个插入的数</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            k=ph[k];</span><br><span class="line">            h[k]=x;</span><br><span class="line">            down(k),up(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实一般遇不到有这种映射关系的堆 只需普通up down就行了<br>但是这是为之后搜索内容做铺垫</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度优先搜索DFS</title>
      <link href="/2023/01/03/%E6%B7%B1%E6%90%9CDFS/"/>
      <url>/2023/01/03/%E6%B7%B1%E6%90%9CDFS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>DFS<br>1.就像树结构一样 向深处搜索 每一个路径一定会走到头 走到头以后回溯 继续往可以走的路径移动。。。再回溯<br>2.使用栈<br>3.空间O(n)<br>4.不具有最短性</p><p>重点 回溯与剪枝</p><figure class="highlight plaintext"><figcaption><span>[DFS排列数字] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=10;</span><br><span class="line">int n;</span><br><span class="line">int path[N];//表示已经到了第几个位置 每个位置是什么数</span><br><span class="line">bool st[N]; //true表示这个数已经被用过了</span><br><span class="line"></span><br><span class="line">void dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">   if(u==n) //u=0 看第一个位置 u=1 看第二个位置 u=n时说明前n个位置已经看到了 也就是到了最后一个位置数字填满的时候 直接输出每一个位置</span><br><span class="line">   &#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)  cout&lt;&lt;path[i];</span><br><span class="line">    puts(&quot; &quot;);</span><br><span class="line">    return;</span><br><span class="line">   &#125;</span><br><span class="line">   for(int i=1;i&lt;=n;i++)</span><br><span class="line">    if(!st[i]) //找到一个没有被用过的数</span><br><span class="line">    &#123;</span><br><span class="line">        path[u]=i; //这个位置就填这个没有用过的数</span><br><span class="line">        st[i]=true; //表示这个数已经填过了</span><br><span class="line">        dfs(u+1); //递归</span><br><span class="line">        //path[u]=0;因为会不断覆盖 所以可以省略</span><br><span class="line">        st[i]=false;//有点抽象 是回溯的时候 恢复状态</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    dfs(0);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>acwing 843<br>将n个皇后放在n*n的棋盘上 任意两个皇后不能再同一行 同一列或同一斜线上<br>输出所有摆法</p><p>可以按照全排列的思路一行一行看 注意剪枝</p><figure class="highlight plaintext"><figcaption><span>[n皇后问题1] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=20;</span><br><span class="line">char g[N][N];</span><br><span class="line">bool col[N],dg[N],udg[N]; //存列 两个对角线 </span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">if(u==n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++) cout&lt;&lt;g[i][j];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++) //枚举第u行 </span><br><span class="line">&#123;</span><br><span class="line">if(!col[i]&amp;&amp;!dg[u+i]&amp;&amp;!udg[n-u+i]) </span><br><span class="line">        //原理y=x+b、y=-x+b公式可得，两条对角线中y+x和y-x是一个定值，然后用对应的定值保存即可 因为y-x可能是负的 所以再加个n保证它是正的</span><br><span class="line">&#123;</span><br><span class="line">g[u][i]=&#x27;Q&#x27;;</span><br><span class="line">col[i]=dg[u+i]=udg[n-u+i]=true;</span><br><span class="line">dfs(u+1);</span><br><span class="line">col[i]=dg[u+i]=udg[n-u+i]=false;</span><br><span class="line">g[u][i]=&#x27;.&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++) g[i][j]=&#x27;.&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">dfs(0);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种方法 甚是巧妙啊 通过每一个只能放或者不放皇后来枚举<br>十分原始简单 </p><figure class="highlight plaintext"><figcaption><span>[n皇后问题2] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=10;</span><br><span class="line">int n;</span><br><span class="line">char g[N][N];</span><br><span class="line">bool col[N],dg[N],udg[N],row[N];</span><br><span class="line"></span><br><span class="line">void dfs(int x, int y,int s)</span><br><span class="line">&#123;</span><br><span class="line">    if(y==n) y=0,x++; //列出界了就回到第一个</span><br><span class="line">    if(x==n) //最后一行枚举完了</span><br><span class="line">    &#123;</span><br><span class="line">        if(s==n)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=0;i&lt;n;i++) puts(g[i]);</span><br><span class="line">            puts(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //不放皇后</span><br><span class="line">    dfs(x,y+1,s); //为什么不放皇后放这呢？ 只可意会</span><br><span class="line"></span><br><span class="line">    //放皇后</span><br><span class="line">    if(!row[x]&amp;&amp;!col[y]&amp;&amp;!dg[x+y]&amp;&amp;!udg[x-y+n])</span><br><span class="line">    &#123;</span><br><span class="line">        g[x][y]=&#x27;Q&#x27;;</span><br><span class="line">        row[x]=col[y]=dg[x+y]=udg[x-y+n]=true;</span><br><span class="line">        dfs(x,y+1,s+1);</span><br><span class="line">        row[x]=col[y]=dg[x+y]=udg[x-y+n]=false;</span><br><span class="line">        g[x][y]=&#x27;.&#x27;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++) g[i][j]=&#x27;.&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">dfs(0,0,0);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Trie树</title>
      <link href="/2023/01/02/Trie/"/>
      <url>/2023/01/02/Trie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一个用来高效存储与查找字符串集合的数据结构<br>注意要标记每个字符串的结尾</p><figure class="highlight plaintext"><figcaption><span>[Trie树] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bit/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const ing N=100010;</span><br><span class="line"></span><br><span class="line">int sun[N][26],cnt[N],idx;    </span><br><span class="line"> //每一个节点最多26个边 子节点就设置26 cnt表示以当前这个点结尾的词有多少个 idx表示当前用到了哪个下标 下标为0 既是根节点 又是空节点</span><br><span class="line"></span><br><span class="line">//插入</span><br><span class="line"> void insert(char str[])</span><br><span class="line"> &#123;</span><br><span class="line">    int p=0;</span><br><span class="line">    for(int i=0;str[i];i++) //c++字符串结尾为/0</span><br><span class="line">    &#123;</span><br><span class="line">        int u=str[i]-&#x27;a&#x27;; 将a-z映射为0-25</span><br><span class="line">        if(!son[p][u]) son[p][u]=++idx; //如果遍历到的该字母未出现过，开辟新空间存储该字母</span><br><span class="line">        p=son[p][u]; //无论之前有无此子节点 现在反正是有了 就移动过去</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++; //每插入一次字符串，用cnt[p]将该单词出现的次数+1</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">//查询</span><br><span class="line">int query(char str[]) </span><br><span class="line">&#123;</span><br><span class="line">    int p=0;</span><br><span class="line">    for(int i=0;syr[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u=str[i]-&#x27;a&#x27;;</span><br><span class="line">        if(!son[p][u]) return 0;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[最大异或对] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2023/01/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2023/01/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一般处理的问题<br>1.将两个集合合并<br>2.询问两个元素是否在一个集合当中</p><p>如果是暴力做法 数组存储每个元素属于哪一个集合<br>1.<br>belong[x]&#x3D;a<br>if(belong[x]&#x3D;belong[y]) O(1)<br>2.如果想合并 极其麻烦 元素多了就寄了</p><p>基本原理<br>用树的形式维护每一个集合 树根的编号就是集合的编号<br>每个节点存储它的父节点p[x]表示x的父节点<br>1.<br>将一棵树插到另一棵树<br>px是x的集合编号 py是y的集合编号 合并就是p[x]&#x3D;y</p><ol start="2"><li>求某个点属于哪个集合 通过其父节点<br>求x的集合编号 while(p[x]!&#x3D;x) x&#x3D;p[x]; 路径压缩优化 一旦找到根节点 整个路径上所有结点直接指向根节点</li></ol><figure class="highlight plaintext"><figcaption><span>[并查集] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1000010;</span><br><span class="line">int n,m;</span><br><span class="line">int p[N]; //存父节点</span><br><span class="line"></span><br><span class="line">int find(int x) //返回x的祖宗节点+路径压缩</span><br><span class="line">&#123;</span><br><span class="line">    if(p[x]==x) return x;//没错 就两行 如果x不是根节点 就让x的父节点等于它的祖宗节点</span><br><span class="line">    return p[x]=find(p[x]); //递归将路径上所有结点的父节点都是根节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) p[i]=i;</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        char op[2];</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        if(op[0]==&#x27;M&#x27;) p[find(a)]=find(b) //合并操作 让a的祖宗节点的父亲等于b的祖宗节点 相当于插入了</span><br><span class="line">        else //判断是否在同一个集合里</span><br><span class="line">        &#123;</span><br><span class="line">            if(find(a)==find(b)) puts(&quot;Yes&quot;)</span><br><span class="line">            else puts(&quot;No&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>acwing 837<br>其实思路十分相近 所谓连通块可以直接用集合来维护 只需模板代码稍作改变<br>主要问题是怎么维护size 也就是集合里元素数量</p><figure class="highlight plaintext"><figcaption><span>[连通块中点的数量] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1000010;</span><br><span class="line">int n,m;</span><br><span class="line">int p[N],size[N]; //每一个集合里点的数量</span><br><span class="line"></span><br><span class="line">int find(int x) </span><br><span class="line">&#123;</span><br><span class="line">    if(p[x]==x) return x;</span><br><span class="line">    return p[x]=find(p[x])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=i;</span><br><span class="line">        size[i]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        char op[5];</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        if(op[0]==&#x27;C&#x27;)//合并</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            if(find(a)==find(b)) continue;//此题有自己连自己的情况 需要特判</span><br><span class="line">            size[find(b)]+=size[find(a)];</span><br><span class="line">            p[find(a)]=find(b);</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        else if(op[1]==&#x27;1&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            if(find(a)==find(b)) puts(&quot;Yes&quot;);</span><br><span class="line">            else puts(&quot;No&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else // 问数量</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">            cout&lt;&lt;size[(find(a))];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kmp字符串</title>
      <link href="/2023/01/01/kmp%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/01/01/kmp%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如果是朴素做法 暴力循环</p><figure class="highlight plaintext"><figcaption><span>[字符串暴力循环] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s[N],p[N];</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    bool flag =true;</span><br><span class="line">    for(int j=1;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if s[i]!=p[i] flag=false;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现匹配慢就是因为回溯的步骤太多了 所以要优化<br>代码不好理解 但是原理简单<br>首先得知道最长前缀和最长后缀怎么求<br>我们发现匹配慢就是因为回溯的步骤太多了</p><figure class="highlight plaintext"><figcaption><span>[升级算法] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=10010，M=10010；</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">char p[N],s[M];</span><br><span class="line">int ne[N];//定义next[N]概率性报错</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1;  注意 都是从1开始存的 方便操作</span><br><span class="line">    //求ne[N]过程 </span><br><span class="line">    for(int i=2,j=0;i&lt;=n;i++)   //ne[1]=0 第一个元素肯定最长相等前后缀为0</span><br><span class="line">    &#123;</span><br><span class="line">        while(j&amp;&amp;p[i]!=p[j+1]) j=ne[j];</span><br><span class="line">        if(p[i]==p[j+1]) j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    //kmp匹配过程</span><br><span class="line">    for(int i=1,j=0;i&lt;=m;i++) </span><br><span class="line">    //从i=1开始从原字符串第一个字符遍历 试图与s[i]匹配的是p[j+1]</span><br><span class="line">    &#123;</span><br><span class="line">        while(j&amp;&amp;s[i]!=p[j+1]) j=ne[j]; </span><br><span class="line">        //ne[j]是 字串下标j与j之前的元素 的最长相等前后缀</span><br><span class="line">        // j=0则代表重新匹配 只要j不退回起点 且匹配不成功时 j回溯到ne[j] 此时子串j与j之前的元素是和原字符串相同的 继续比较i与j+1</span><br><span class="line">        if(s[i]==p[j+1]) j++; 如果下一个相同 继续操作</span><br><span class="line">        if(j==n) //如果完全符合</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;i-n;//输出匹配位置</span><br><span class="line">            j=ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子<br>下标 1  2  3  4  5  6  7  8<br>s&#x3D;   a  b  a  b  a  b  c<br>p&#x3D;   a  b  a  b  a  b  a  b<br>i    1  2  3  4  5  6  7  8<br>j+1  1  2  3  4  5  6  7  8<br>ne[]&#x3D;0  0  1  2  3  4  5  6</p><p>首先下标为1均是a 所以i++ j++<br>这么比较下去 当i&#x3D;7时 不相等了<br>此时j&#x3D;6 ne[6]&#x3D;4 所以j回溯到4 j+1为5<br>s&#x3D;   a  b  a  b  a  b  c<br>p&#x3D;               a  b  a  b  a  b  a  b<br>接着继续相同操作</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/2022/12/31/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2022/12/31/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>栈 先进后出 就像一个桶一样 先进的到栈底 最后进的是栈顶<br>队列 先进先出</p><figure class="highlight plaintext"><figcaption><span>[模拟栈] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">略</span><br><span class="line">const int N=100010;</span><br><span class="line"></span><br><span class="line">int stk[N],tt; tt表示栈顶下标</span><br><span class="line">//插入</span><br><span class="line">stk[++tt] =x;</span><br><span class="line"></span><br><span class="line">//弹出</span><br><span class="line">tt--；</span><br><span class="line"></span><br><span class="line">//判断栈是否为空</span><br><span class="line">if(tt&gt;0) not empty</span><br><span class="line">else empty</span><br><span class="line"></span><br><span class="line">//栈顶</span><br><span class="line">stk[tt];</span><br></pre></td></tr></table></figure><p>单调栈<br>很抽象 类似于删掉逆序的对 最后得到单调的栈<br>单调栈主要解决以下问题：<br>寻找下一个更大元素<br>寻找前一个更大元素<br>寻找下一个更小元素<br>寻找前一个更小元素 诸如此类<br>有点抽象 类似于删掉逆序的对 最后得到单调的栈<br>例 给定一个长为N的整数数列 输入每个数左边第一个比它小的数 不存在则-1</p><figure class="highlight plaintext"><figcaption><span>[单调栈] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100010;</span><br><span class="line"></span><br><span class="line">int n,stk[N],tt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        while(tt&amp;stk[tt]&gt;=x) tt--; //如果栈不为空且栈顶大于当前数 那么栈顶必不是答案了 直接删掉</span><br><span class="line">        if(tt) cout&lt;&lt;stk[tt]&lt;&lt;&quot; &quot;; 如果这样处理了 栈不为空 那么栈顶就是答案</span><br><span class="line">        else cout&lt;&lt;-1&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">        stk[++tt]=x; //记得将新数入栈</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样时间复杂度就超级屌 O(n)</p><figure class="highlight plaintext"><figcaption><span>[模拟队列] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//队尾插入元素 队头弹出元素</span><br><span class="line">int q[N],hh,tt=-1; //hh队头 tt队尾 头在左边便于数组操作</span><br><span class="line"></span><br><span class="line">//插入</span><br><span class="line">q[++tt]=x;</span><br><span class="line"></span><br><span class="line">//弹出</span><br><span class="line">hh++; 队头指针右移一个位置</span><br><span class="line"></span><br><span class="line">//判断是否为空</span><br><span class="line">if(hh&lt;tt) not empty</span><br><span class="line">else empty</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>单调队列经典例题 滑动窗口 求窗口内最小值</p><p>只要前面的数比后面大 前面的数就无用了 只要存在这种逆序对 就删掉大的</p><figure class="highlight plaintext"><figcaption><span>[单调队列] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1000010;</span><br><span class="line">int n,k;</span><br><span class="line">int a[N],q[N]; //数组a存原数列 q存的单调队列下标 注意是下标</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    ios::sync_with_stdio(false)</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    int hh=0,tt=-1;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //判断队头是否划出窗口 直接对比下标就可以了</span><br><span class="line">        if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++; //没有用while 因为每次只移动一次 最多就窗口左边一个位置</span><br><span class="line"></span><br><span class="line">        while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--; //求窗口最小值 若插入的数比队尾小 队尾一定不是答案了 就删去</span><br><span class="line">        q[++tt]=i;//更新右端点 与下一个插入的a[i]比较</span><br><span class="line">        if(i&gt;=k-1) cout&lt;&lt;a[q[hh]];//一开始 元素不满k时不输出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>区间合并</title>
      <link href="/2022/12/28/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
      <url>/2022/12/28/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>比较简单的一个小算法 直接上代码</p><figure class="highlight plaintext"><figcaption><span>[区间合并] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt;PII;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line">int nl</span><br><span class="line">vector&lt;PII&gt; segs;</span><br><span class="line">void merge(vector&lt;PII&gt; &amp;segs)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    sort(segs.begin(),segs.end());//由左端点排序</span><br><span class="line">    int st=-2e9,ed=-2e9 //初始化左右端点无穷小</span><br><span class="line">    for(auto seg:segs)</span><br><span class="line">        if(ed&lt;seg.first) //如果当前枚举区间在右边 没有任何交集</span><br><span class="line">        &#123;</span><br><span class="line">            if(st!=-2e9) res.push_back(&#123;st,ed&#125;);//区间不为空且无交集 保存结果 此结果区间判断已结束</span><br><span class="line">            st=seg.first,ed=seg.second;//更新当前维护的区间</span><br><span class="line">        &#125;</span><br><span class="line">        else ed=max(ed,seg.second);//如果有交集 由之前对左端点排过序 只用比较右端点的大小 取大的哪一个到答案中</span><br><span class="line"></span><br><span class="line">        if(st!=-2e9) res.push_back(&#123;st,ed&#125;); //循环结束时st ed是最后一个序列 不需要继续维护了 直接加到res数组里</span><br><span class="line">        segs=res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        segs.push_back(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    merge(segs);</span><br><span class="line">    cout&lt;&lt;segs.size()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>离散化</title>
      <link href="/2022/12/27/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
      <url>/2022/12/27/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>是一种极其特殊的hash方式 必须保序<br>把无限空间中有限的个体映射到有限的空间中去以提高空间效率</p><figure class="highlight plaintext"><figcaption><span>[离散化vector] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; a;//用普通数组也不是不行 操作差不多</span><br><span class="line">sort(a.begin(),a.end()); //将所有元素排序</span><br><span class="line">a.erase(unique(a.begin(),a.end()),a.end()); </span><br><span class="line">//去重 unique非重复的元素在数组开头  erase返回下标到最后中间的元素 就是去重</span><br><span class="line"></span><br><span class="line">int find(int x) //找到第一个大于等于x的位置 当然也可以lower_bound</span><br><span class="line">&#123;</span><br><span class="line">    int l=0,r=a.size()-1;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid=(l+r)&gt;&gt;1;</span><br><span class="line">        if(a[mid]&gt;=x) r=mid;</span><br><span class="line">        else l=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l+1； 储存是从0开始的 加1 元素映射到1到n  不加1就是映射到0到n-1 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为从1开始vector不方便 </p><figure class="highlight plaintext"><figcaption><span>[离散化普通数组] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int lsh[N];</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;lsh[i];</span><br><span class="line">sort(lsh + 1 , lsh + n + 1);//排序</span><br><span class="line">cnt = unique(lsh + 1, lsh + n + 1) - lsh - 1;//去重并求出离散化数组大小</span><br><span class="line">// 二分求出x对应的离散化的值</span><br><span class="line">int find(int x) // 找到第一个大于等于x的位置</span><br><span class="line">&#123;</span><br><span class="line">    int l = 1, r = cnt;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        if (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return r; 前面存储是从1开始的 所以这直接return r</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>区间和</p><figure class="highlight plaintext"><figcaption><span>[区间和] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; PII;//操作读入是成对的 定义这么一个结构</span><br><span class="line"></span><br><span class="line">const int N=300010;</span><br><span class="line">int n,m;</span><br><span class="line">int a[N],s[N];</span><br><span class="line">vector&lt;int&gt; alls;</span><br><span class="line">vector&lt;PII&gt; add,query; //定义两个PII 一个存操作c 一个存给的l r</span><br><span class="line"></span><br><span class="line">int find(int x) // 找到第一个大于等于x的位置</span><br><span class="line">&#123;</span><br><span class="line">    int l = 0, r = alls.size()-1;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        if (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return r+1; 本题是映射到从1开始 因为要用到前缀和</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x,c;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        add.push_back(&#123;x,c&#125;);</span><br><span class="line">        alls.push_back(x);//待离散化的值</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        query.push_back(&#123;l,r&#125;); //注意pair类型插入需要大括号</span><br><span class="line">        alls.push_back(l);</span><br><span class="line">        alls.push_back(r);//将l r存入待离散化数组</span><br><span class="line">    &#125;</span><br><span class="line">    sort(alls.begin(),alls.end());//排序</span><br><span class="line">    alls.erase(unique(alls.begin(),alls.end()),alls.end());//去重</span><br><span class="line"></span><br><span class="line">    for(auto ite:add )</span><br><span class="line">    &#123;</span><br><span class="line">        int x=find(ite.first);</span><br><span class="line">        a[x]+=ite.second;//离散化 对应加上c</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=alls.size();i++) s[i]=s[i-1]+a[i]; //预处理前缀和</span><br><span class="line"></span><br><span class="line">    for(auto item: query)</span><br><span class="line">    &#123;</span><br><span class="line">        int l=find(item.first);</span><br><span class="line">        int r=find(item.second);</span><br><span class="line">        cout&lt;&lt;s[r]-s[l-1]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2022/12/26/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2022/12/26/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>普通的函数写循环 时间就寄了 所以需要快速幂<br>已知(a<em>b)%c&#x3D;((a%c)</em>(b%c))%c 可以初步优化 但是依然不够<br>核心思想就是每一步都把指数分成两半 而相应的底数做平方运算 如<br>3^10&#x3D;3<em>3</em>3<em>3</em>3<em>3</em>3<em>3</em>3<em>3<br>3^10&#x3D;(3</em>3)<em>(3</em>3)<em>(3</em>3)<em>(3</em>3)<em>(3</em>3)<br>3^10&#x3D;(3<em>3)^5<br>3^10&#x3D;9^5<br>而当指数为奇数时 指数减一化为偶数<br>9^5&#x3D;（9^4）</em>（9^1）继续操作<br>9^5&#x3D;（81^2）*(9^1)<br>9^5&#x3D;（6561^1）*(9^1)<br>最后(9^1)<em>(6561^1)&#x3D;9</em>6561&#x3D;59049<br>最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积</p><p>求a的b次方取余1000</p><figure class="highlight plaintext"><figcaption><span>[快速幂] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">long long FastPower(long long base,long long power)</span><br><span class="line">&#123;</span><br><span class="line">    long long result=1;</span><br><span class="line">    while(power&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (power % 2 == 0) &#123;</span><br><span class="line">            //如果指数为偶数</span><br><span class="line">            power/=2;//把指数砍一半</span><br><span class="line">            base=base*base%1000;//底数变大成原来的平方</span><br><span class="line">    &#125;   else&#123;//如果是奇数</span><br><span class="line">            power-=1;//先变成偶数</span><br><span class="line">            result=result*base%1000;//独立出来的1必须记得</span><br><span class="line">            power/=2;</span><br><span class="line">            base=base*base%1000;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此之外 可以再理解原理的基础上由向下取整简化</p><figure class="highlight plaintext"><figcaption><span>[快速幂] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">power-=1;</span><br><span class="line">power/=2;</span><br><span class="line">等价于</span><br><span class="line">power/=2;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>素数筛与欧拉筛</title>
      <link href="/2022/12/24/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
      <url>/2022/12/24/%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>朴素算法<br>优化方法<br>1.只判断奇数<br>2.因子是成对出现，并且分布在 sqrt (n) 两侧的 所以只判断到n的根</p><figure class="highlight plaintext"><figcaption><span>[素数筛] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int IsPrime(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if(n&lt;2||(n!=2&amp;&amp;n%2==0))</span><br><span class="line">        return 0;</span><br><span class="line">    else //n都是奇数</span><br><span class="line">    &#123;</span><br><span class="line">        for(i=3;i*i&lt;=n;i+=2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(n%i==0)</span><br><span class="line">                return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然如此优化依旧不够</p><p>埃氏筛1.0<br>便是数组a储存已经筛选过的素数 数组b包含范围内所有数字，用来标记是否被访问过 从2开始循环 对其进行倍增操作<br>优化方法<br>1.易知很多倍增其实重复了 浪费了时间空间 优化方法便是只对素数进行倍增<br>2.倍增从i开始 而不是从2开始 减少一半计算量</p><figure class="highlight plaintext"><figcaption><span>[素数筛] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int vis[N];//判断是否被访问过</span><br><span class="line">int prime[N];//存储筛选出来的素数</span><br><span class="line"></span><br><span class="line">int s(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,k;//i是逐个访问 j二轮标记，k标记prime数组的位置</span><br><span class="line">    k=0; //这样定义 每次函数调用时都清空</span><br><span class="line">    memset(vis,0,sizeof(int)*N); //清空访问数组</span><br><span class="line">    vis[0]=vis[1]=1;//此步无所谓 因为从2开始</span><br><span class="line">    for(int i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(vis[i]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            prime[k++]=i;//如果没有被访问过 那么就是最小的素数</span><br><span class="line">            for(int j=i;j&lt;=n;j++) vis[i*j]=1; //标记在上界内 这个素数数倍增后的数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>埃氏筛2.0 除了上述优化<br>1.只判断奇数<br>2.由于因子是成对出现的，如果左侧范围数字不是因子，则右侧范围中也没有因子，因此可以说明这个数字是素数<br>即x在[2，sqrt (x) ] 范围内的数倍增时 已经得到了<br>于是有了最终埃氏筛</p><figure class="highlight plaintext"><figcaption><span>[埃氏筛] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int E(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&lt;2) return 0;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    k=0;</span><br><span class="line">    memset(vis,0,sizeof(int)*N);</span><br><span class="line">    vis[0]=vis[1]=1;//0 1都是非素数</span><br><span class="line"></span><br><span class="line">    for(i=4;i&lt;=n;i+=2) vis[i]=1;//把偶数全部标记了 都是非素数</span><br><span class="line">    for(i=3;i*i&lt;=n;i+=2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(vis[i]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            for(j=i;i*j&lt;=n;j++) vis[i*j]=1;//这里把j=2改为j=i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    prime[k++]=2; //上面循环 只循环到了sqrt(n) 所以需要从头循环一次</span><br><span class="line">    for(i=3;i&lt;=n;i+=2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(vis[i]==0) prime[k++]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>埃氏筛的最终版本 是只要是素数就进行倍增<br>欧拉筛 在埃氏筛的基础上 保证了每个合数只被筛选一次</p><figure class="highlight plaintext"><figcaption><span>[欧拉筛] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//欧拉筛函数</span><br><span class="line">int E2(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    k=0;//保存素数的个数</span><br><span class="line">    memset(vis,0,sizeof(int)*maxn);//初始化数组</span><br><span class="line">    for(i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(vis[i]==0)//i是素数，则存起来</span><br><span class="line">            prime[k++]=i;</span><br><span class="line">        for(j=0;j&lt;k;j++)//进行倍增，用i去乘以i之前(包括i)的素数</span><br><span class="line">        &#123;</span><br><span class="line">            if(i*prime[j]&gt;n)//倍增结果超出范围，退出</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            vis[ i*prime[j] ]=1;//将倍增结果进行标记</span><br><span class="line"></span><br><span class="line">            if(i%prime[j]==0)//i是前面某个素数的倍数时，也需要退出</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2022/12/17/%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/12/17/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>head 表示头结点的下标<br>e[i] 表示节点i的值<br>ne[i] 表示节点i的next指针是多少 (下一个节点的下标)<br>idx 存储当前已经用到了哪一个点</p><figure class="highlight plaintext"><figcaption><span>[数组模拟单链表] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100010;</span><br><span class="line">int head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line">void init() //初始化</span><br><span class="line">&#123;</span><br><span class="line">    head=-1;</span><br><span class="line">    idx=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add_to_head(int x) //将x插到头结点</span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=x;//这个结点赋值</span><br><span class="line">    ne[idx]=head;//新头结点的下一个结点是之前的头结点</span><br><span class="line">    head=idx; head变成新的头结点的下标</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int k,int x)//将x插到下标为k的位置的后面 注意不是第k个点 是下标为k的点</span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=x;//还是先赋值到新节点</span><br><span class="line">    ne[idx]=ne[k]; //新节点的下一个坐标更新为k节点原本的下一个坐标</span><br><span class="line">    ne[k]=idx;//k的下一个下标是新节点</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void remove(int k,int x) //删掉k之后的一个元素</span><br><span class="line">&#123;</span><br><span class="line">    ne[k]=ne[ne[k]];直接跳过就得了</span><br><span class="line">&#125;</span><br><span class="line">遍历</span><br><span class="line">for(int i=head;i!=-1;i=ne[i]) 略</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每个点有两个指针</p><figure class="highlight plaintext"><figcaption><span>[数组模拟双链表] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100010;</span><br><span class="line"></span><br><span class="line">int m;</span><br><span class="line">int e[N],l[N],r[N],idx; l是左边的点的下标 r是右边的点的下标</span><br><span class="line"></span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    r[0]=1;</span><br><span class="line">    l[1]=0;</span><br><span class="line">    idx =2;//0 1已经被占用过了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int k, int x) 在下标为k的点的右边插入x</span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    r[idx]=r[k];</span><br><span class="line">    l[idx]=k;</span><br><span class="line">    l[r[k]]=idx;//注意倒数二三个不能换位置 不然没法完成</span><br><span class="line">    r[k]=idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line">在k的左边 直接add(l[k],int x)</span><br><span class="line"></span><br><span class="line">void remove(int k) //删除第k个节点</span><br><span class="line">&#123;</span><br><span class="line">    r[l[k]]=r[k]; //k上一个元素的右边下标直接等于k右边边的元素下标</span><br><span class="line">    l[r[k]]=l[k]; //k下一个元素的左边下标直接等于k左边的元素下标</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = r[0]; i != 1; i = r[i])  // 从左向右遍历</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">邻接表 就是n个单链表</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小技巧</title>
      <link href="/2022/12/12/small-tips/"/>
      <url>/2022/12/12/small-tips/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>cin，cout之所以效率低，是因为先把要输出的东西存入缓冲区，再输出，导致效率降低.<br>在调用下列代码后，效率与scanf与printf相差无几,但是不能再用scanf了</p><figure class="highlight plaintext"><figcaption><span>[tips] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0);</span><br></pre></td></tr></table></figure><p>多层循环提高效率</p><figure class="highlight plaintext"><figcaption><span>[tips] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register int</span><br></pre></td></tr></table></figure><p>auto的原理就是根据后面的值，来自己推测前面的类型是什么<br>针对迭代器 可以如下操作</p><figure class="highlight plaintext"><figcaption><span>[tips] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; ve;</span><br><span class="line">ve.push_back(1);</span><br><span class="line">ve.push_back(2);</span><br><span class="line">ve.push_back(3);</span><br><span class="line"></span><br><span class="line">for(auto i:ve) cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>快读 字符串输入 再转为数字 超级快</p><figure class="highlight plaintext"><figcaption><span>[int快读] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int read()</span><br><span class="line">&#123;</span><br><span class="line">    int s=0,w=1;</span><br><span class="line">    char ch=getchar();</span><br><span class="line">    if(ch==&#x27;-&#x27;) //先判断是不是个负数</span><br><span class="line">    &#123;</span><br><span class="line">        w=-1;</span><br><span class="line">        ch=getchar();继续读下一个字符</span><br><span class="line">    &#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=9)</span><br><span class="line">    &#123;</span><br><span class="line">        s=s*10+ch-&#x27;0&#x27;;极其重要 记得-0</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return w*s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[double快读] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">double read()</span><br><span class="line">&#123;</span><br><span class="line">    double s=0,w=1;</span><br><span class="line">    char ch=getchar();</span><br><span class="line">    if(ch==&#x27;-&#x27;) </span><br><span class="line">    &#123;</span><br><span class="line">        w=-1;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">     while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=9)</span><br><span class="line">    &#123;</span><br><span class="line">        s=s*10+ch-&#x27;0&#x27;;</span><br><span class="line">        ch=getchar();前面都一样</span><br><span class="line">    &#125;</span><br><span class="line">    if(ch==&#x27;.&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        ch=getchar();</span><br><span class="line">        double f=0;</span><br><span class="line">        int i=0;//计算小数尾数</span><br><span class="line">        while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            f=f*10+ch-&#x27;0&#x27;;</span><br><span class="line">            i++;</span><br><span class="line">            ch=getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        s+=f</span><br><span class="line">    &#125;</span><br><span class="line">    return w*s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[int 快写] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void write(int x) &#123;</span><br><span class="line">     if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">     if(x&gt;9) write(x/10);</span><br><span class="line">     putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前缀和与差分</title>
      <link href="/2022/12/11/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
      <url>/2022/12/11/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>例 输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和。如果暴力遍历，时间复杂度为O(m*n) 可能超时<br>则采用前缀和算法并查询<br>a[N]记得是从1开始,a[0]&#x3D;0, 因为如果是求（1，r) 需要sum[r]-sum[0]</p><figure class="highlight plaintext"><figcaption><span>[前缀和] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const int N = 1e5 + 10;</span><br><span class="line">int sum[N], a[N]; //sum[i]=a[1]+a[2]+a[3].....a[i];</span><br><span class="line">for(int i = 1;i &lt;= n; i++)</span><br><span class="line">&#123; </span><br><span class="line">    sum[i] = sum[i - 1] + a[i];   //前缀和的初始化</span><br><span class="line">&#125;</span><br><span class="line">while(m--)</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    cout&lt;&lt;sum[r] - sum[l - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。<br>对于每个询问输出子矩阵中所有数的和。<br>二维前缀和思路相同 但是要推导公式</p><figure class="highlight plaintext"><figcaption><span>[二维前缀和] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1010;</span><br><span class="line">int n, m, q;</span><br><span class="line">int a[N][N];s[N][M];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ )</span><br><span class="line">        for (int j = 1; j &lt;= m; j ++ )</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ )</span><br><span class="line">        for (int j = 1; j &lt;= m; j ++ )</span><br><span class="line">            s[i][j]= s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]+a[i][j]; //前缀和的初始化</span><br><span class="line">     while (q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        int x1, y1, x2, y2;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        cout&lt;&lt;s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1])&lt;&lt;endl; //算子矩阵的和</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一维差分类似于数学中的求导和积分，差分可以看成前缀和的逆运算<br>首先给定一个原数组a：a[1], a[2], a[3],,,,,, a[n];<br>然后我们构造一个数组b ： b[1], b[2], b[3],,,,,, b[i];<br>使得 a[i] &#x3D; b[1] + b[2] + b[3] + ,,,,,, + b[i]<br>也就是说，a数组是b数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。</p><p>例<br>输入一个长度为n的整数序列。<br>接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。<br>请你输出进行完所有操作后的序列。</p><figure class="highlight plaintext"><figcaption><span>[一维差分] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line">int a[N],b[N],n,m; </span><br><span class="line">void insert(int l,int r,int c)</span><br><span class="line">&#123;</span><br><span class="line">    b[l]+=c;</span><br><span class="line">    b[r+1]-=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++) insert(i,i,a[i]);</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r,c;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        insert(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) b[i]+=b[i-1];</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cout&lt;&lt;b[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>二维思路相似</p><figure class="highlight plaintext"><figcaption><span>[二维差分] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e3 + 10;</span><br><span class="line">int a[N][N], b[N][N];</span><br><span class="line">void insert(int x1, int y1, int x2, int y2, int c)</span><br><span class="line">&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + 1][y1] -= c;</span><br><span class="line">    b[x1][y2 + 1] -= c;</span><br><span class="line">    b[x2 + 1][y2 + 1] += c;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        for (int j = 1; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            insert(i, j, i, j, a[i][j]);      //其实也不能算构造 差分数组创建的时候就直接行了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        int x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        insert(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];  //二维前缀和</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%d &quot;, b[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acwing 3729<br>这道题一开始想的区间合并 听了讲解发现居然能差分<br>因为每个位置的数只会增加 所以只要操作次数不是0 那么值就为1<br>怎么记录操作次数呢 就需要用差分<br>b[1]到b[i]的前缀和就是第i个元素的操作次数 极大节省时间<br>差分数组不用刻意去构造 创建的时候就能直接弄出来</p><figure class="highlight plaintext"><figcaption><span>[3729] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long n,mid;</span><br><span class="line">const int N=2e5+10;</span><br><span class="line">long long b[N];</span><br><span class="line">void add(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">b[l]+=1;</span><br><span class="line">b[r+1]-=1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0);</span><br><span class="line">cout.tie(0);</span><br><span class="line">long long t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">memset(b,0,sizeof b);</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">if(x==0) continue;</span><br><span class="line">else if(x&gt;=i) add(1,i);</span><br><span class="line">else add(i-x+1,i);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++) b[i]+=b[i-1]; //此时b[i]存的是操作次数</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(b[i]!=0) cout&lt;&lt;1&lt;&lt;&quot; &quot;;</span><br><span class="line">    else cout&lt;&lt;0&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>stl-map</title>
      <link href="/2022/12/03/stl-map/"/>
      <url>/2022/12/03/stl-map/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>map是c++的一个关联容器 提供一对一的映射<br>第一个称为关键字key（有唯一性） 第二个称为关键字的值value<br>和python里的字典很像</p><figure class="highlight plaintext"><figcaption><span>[map] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">如你想建立一个姓名-电话对应关系</span><br><span class="line">定义一个map对象</span><br><span class="line">map&lt;string,string&gt;friends;</span><br><span class="line">cout&lt;&lt;friends.find(&quot;jack&quot;); 找到jack的对应号码</span><br><span class="line">cout&lt;&lt;friedns.find(123); 找123对应的姓名 找不到返回null</span><br><span class="line"></span><br><span class="line">用insert函数插入</span><br><span class="line">friends.insert(pair&lt;string, string&gt;(&quot;judy&quot;, &quot;789&quot;));</span><br><span class="line"></span><br><span class="line">遍历 不能写小于</span><br><span class="line">for(iter=friends.begin();iter!=friends.end();iter++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">推荐使用数组插入 因为对于同一关键字 新的值可以覆盖旧的</span><br><span class="line">friends[234]=&quot;sam&quot;;</span><br><span class="line">friends[456]=&quot;mark&quot;;</span><br><span class="line"></span><br><span class="line">查找元素与删除 清空</span><br><span class="line">iter=firends.find(&quot;123&quot;);</span><br><span class="line">friends.erase(iter);</span><br><span class="line">friends.clear;</span><br><span class="line"></span><br><span class="line">查看有多少元素</span><br><span class="line">int num=friends.size();</span><br><span class="line"></span><br><span class="line">返回头部/尾部迭代器</span><br><span class="line">friends.begin();</span><br><span class="line">friends.end();</span><br><span class="line"></span><br><span class="line">返回键值&gt;=给定元素的第一个位置</span><br><span class="line">lower_bound()</span><br><span class="line"></span><br><span class="line">返回键值&gt;给定元素的第一个位置</span><br><span class="line">upper_bound();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整道简单例题<br><img src="/images/p2.png"><br>一看就用映射关系解决 注意要求谁先到最高分 所以多定义一个b</p><figure class="highlight plaintext"><figcaption><span>[map例] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int x[10010];</span><br><span class="line">string s[10010]</span><br><span class="line">map&lt;string,int&gt;a,b;//定义</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n</span><br><span class="line">    for(int i=0;i&lt;n;i++&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s[i]&gt;&gt;x[i];</span><br><span class="line">        a[s[i]]+=x[i]; //赋value</span><br><span class="line">    &#125;</span><br><span class="line">    int max=0; //通过a先求出最大值 </span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[s[i]]&gt;max) max=a[s[i]];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)//再通过b求谁先到最大值</span><br><span class="line">&#123;</span><br><span class="line">b[s[i]]+=x[i];</span><br><span class="line">if((b[s[i]])&gt;=max&amp;&amp;a[s[i]]&gt;=max)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;s[i];</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>stl-其它</title>
      <link href="/2022/12/01/stl-%E5%85%B6%E5%AE%83/"/>
      <url>/2022/12/01/stl-%E5%85%B6%E5%AE%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><figcaption><span>[stl] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; a(&#123;1,2,3,4,5&#125;);动态数组</span><br><span class="line">array.pop_back(); //删除向量的最后一个元素</span><br><span class="line">array.push_back(a); //尾部插入数字a</span><br><span class="line">array.insert(array.begin()+i,a); //在第i+1个元素前面插入a;</span><br><span class="line">array.erase(array.begin()+2); //删除第3个元素</span><br><span class="line">array.erase(array.begin()+i,array.end()+j); //删除区间[i,j-1],区间从0开始</span><br><span class="line">array.clear();</span><br><span class="line">array.back();//返回最后一个元素</span><br><span class="line">array.front(); //返回第一个元素</span><br><span class="line"></span><br><span class="line">reverse(a.begin().a.end()); 翻转 必须用迭代器 数组不用 注意是都是前闭后开 end()是back()的后一位</span><br><span class="line"></span><br><span class="line">必须相同元素排一起才能去重 返回值是去重后元素的下一个位置</span><br><span class="line">int m=unique(a,a+n)-a;</span><br><span class="line">int n=unique(a.begin(),a.end())-a.begin(); 不同元素的数量 此时原数组也改变（其实是生成了新数组)</span><br><span class="line">a.erase(unique(a.begin(),a.end()),a.end()); 相当于只留不同元素</span><br><span class="line"></span><br><span class="line">random_shuffle(a.begin(),a.end()); 随机顺序</span><br><span class="line"></span><br><span class="line">sort(a.begin(),a.end()); 从小到大排序</span><br><span class="line"></span><br><span class="line">bool cmp(a,b)</span><br><span class="line">&#123;</span><br><span class="line">    return a&lt;b; 如果符合返回true a排b前面</span><br><span class="line">&#125;</span><br><span class="line">sort(a.begin(),a.end(),cmp);从大到小</span><br><span class="line"></span><br><span class="line">lower_bound      查找大于等于x的第一个元素的下标 元素存放在1到n中</span><br><span class="line">upper_bound      查找大于x的第一个元素的下标</span><br><span class="line"></span><br><span class="line">对于数组</span><br><span class="line">int *p = lower_bound(a, a + 5, 3); 从a数组中找到第一个不小于3的元素</span><br><span class="line">int t = lower_bound(a, a + 5, 3)-a 减去数组第一位的地址 得到下标</span><br><span class="line"></span><br><span class="line">神器</span><br><span class="line">nth_element(数组名,数组名+第k小元素,数组名+元素个数)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分答案</title>
      <link href="/2022/11/30/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
      <url>/2022/11/30/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>二分答案与二分查找模板又有些许不同</p><figure class="highlight plaintext"><figcaption><span>[二分答案] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while(l&lt;=r)//此处是小于等于</span><br><span class="line">&#123;</span><br><span class="line">    mid=(l+r)&gt;&gt;1;</span><br><span class="line">    if(check(mid))</span><br><span class="line">    &#123;</span><br><span class="line">        ans =mid;</span><br><span class="line">        l=mid+1</span><br><span class="line">    &#125;</span><br><span class="line">    else r=mid-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>洛谷P2678 跳石头<br>当一道题目直接求解答案会很困难，但是根据题意去验证答案会很简单，那么我们就利用逆向思维，直接枚举答案，利用刚刚学到的二分查找去查找答案，然后去直接按照题意验证答案，验证成功即可输出，所以二分更多的就是逆向思维</p><figure class="highlight plaintext"><figcaption><span>[跳石头] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e5+7;</span><br><span class="line">int a[N],ans;</span><br><span class="line">bool check(int x,int b[],int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">int now=0,tot=0;</span><br><span class="line">for(int j=1;j&lt;=n+1;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[j]-a[now]&lt;x) tot++;//如果距离小 这颗石头可以搬走 </span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">now=j;// 如果距离大,就跳过去  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(tot&gt;m) return false;</span><br><span class="line">else return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int L,n,m;</span><br><span class="line">cin&gt;&gt;L&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">a[n+1]=L;</span><br><span class="line">int l=1,r=L;</span><br><span class="line">while(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">int mid=(l+r)&gt;&gt;1;</span><br><span class="line">if (check(mid,a,n,m))</span><br><span class="line">&#123;</span><br><span class="line">ans=mid;</span><br><span class="line">l=mid+1;//如果搬的石头少 最短跳跃距离可能可以更大 </span><br><span class="line">    &#125;</span><br><span class="line">else r=mid-1;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高精度四则</title>
      <link href="/2022/11/29/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>/2022/11/29/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用数组存大整数 模拟人工加法的过程<br>数组中正向小的索引存高位</p><figure class="highlight plaintext"><figcaption><span>[高精度加法] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1e6+10;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B)//加&amp;是引用 不用创造新的动态数组</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line"></span><br><span class="line">    int t=0;//表示进位</span><br><span class="line">    for(int i=0;i&lt;A.size()||i&lt;B.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i&lt;A.size()) t+=B[i];</span><br><span class="line">        if (i&lt;B.size()) t+=B[i];</span><br><span class="line">        C.push_back(t%10);</span><br><span class="line">        t/=10;</span><br><span class="line">    &#125;</span><br><span class="line">if (t) C.push_back(1);//如果最高位还有进位 那么最高位补1</span><br><span class="line">return C;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;int&gt;A,B;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b; //a=&quot;123456&quot;</span><br><span class="line">    for(int i=a.size()-1;i&gt;=0;i--) A.push_back(a[i]-&#x27;0&#x27;);//字符型数字变成整型数字</span><br><span class="line">    for(int i=b.size()-1;i&gt;=0;i--) B.push_back(b[i]-&#x27;0&#x27;);//A=[6,5,4,3,2,1]</span><br><span class="line">    auto C=add(A,B);</span><br><span class="line">    for(int i=C.size()-1;i&gt;=0;i--) cout&lt;&lt;C[i];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[高精度减法] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool cmp(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B) //减法模板必须大的减小的</span><br><span class="line">&#123;</span><br><span class="line">    if(A.size()!=B.size()) return A.size()&gt;B.size();</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=A.size()-1;i&gt;=0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(A[i]!=B[i]) return A[i]&gt;B[i];//从高位开始判断大小</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line"></span><br><span class="line">    int t=0;//进位</span><br><span class="line">    for(int i=0,t=0;i&lt;A.size()||i&lt;B.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t=A[i]-t;</span><br><span class="line">        if(i&lt;B.size()) t-=B[i];  //判断B有没有这一位 有就减</span><br><span class="line">        C.push_back((t+10)%10); //如果t大于0 那么就是t 如果t小于0 借10</span><br><span class="line">        if (t&lt;0) t=1;</span><br><span class="line">        else t=0; //判断有无借10</span><br><span class="line">    &#125;</span><br><span class="line">    while(C.size()&gt;1&amp;&amp;C.back()==&#x27;0&#x27;) C.pop_back(); //去掉首位0 避免出现如0032的情况</span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;int&gt;A,B;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b; //a=&quot;123456&quot;</span><br><span class="line">    for(int i=a.size()-1;i&gt;=0;i--) A.push_back(a[i]-&#x27;0&#x27;);//字符型数字变成整型数字</span><br><span class="line">    for(int i=b.size()-1;i&gt;=0;i--) B.push_back(b[i]-&#x27;0&#x27;);//A=[6,5,4,3,2,1]</span><br><span class="line">    auto C=sub(A,B);</span><br><span class="line">    for(int i=C.size()-1;i&gt;=0;i--) cout&lt;&lt;C[i];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是大数据乘小数据 可以这么写 比较方便</p><figure class="highlight plaintext"><figcaption><span>[高精度乘法1] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A,int b);//乘法一个乘数可以直接int表示了</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    int t=0;</span><br><span class="line">    for(int i=0;i&lt;A.size()||t;i++) //A未遍历完或还有进位 就继续</span><br><span class="line">    &#123;</span><br><span class="line">        t+=A[i]*b;</span><br><span class="line">        C.push_back(t%10)</span><br><span class="line">        t/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个都是大数据的话 笑死</p><figure class="highlight plaintext"><figcaption><span>[高精度乘法2] [p3]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=int(input())</span><br><span class="line">b=int(input())</span><br><span class="line">print(a*b)</span><br></pre></td></tr></table></figure><p>注意除法是从最高位开始除的 跟之前的不同 但是为了统一 此处也是倒着存 略</p><figure class="highlight plaintext"><figcaption><span>[高精度除法] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; div(vector&lt;int&gt; &amp;A,int b，int &amp;r);//r是余数</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    r=0;</span><br><span class="line">    for(int i=A.size()-1;i&gt;=0;i--)//比如a是1234 则A是4321 除法从a的最低位 也就是A的最高位开始 </span><br><span class="line">    &#123;</span><br><span class="line">        r=r*10+A[i];//除法中下一位数直接放在余数右边</span><br><span class="line">        C.push_back(r/b);</span><br><span class="line">        r%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.begin(),C.end()); //顺逆关系</span><br><span class="line">    while(C.size()&gt;1&amp;&amp;C.back=&#x27;0&#x27;) C.pop_back();</span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串语法</title>
      <link href="/2022/11/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/11/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>字符串就是字符数组加上结束符\0<br>常用的不忽略空格的字符串读入方式<br>针对string类型(多用)</p><figure class="highlight plaintext"><figcaption><span>[读入1] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">略 </span><br><span class="line">    string a;</span><br><span class="line">    getline(cin,a);//这个只能读string不能读字符串</span><br><span class="line">    cout&lt;&lt;a.size()&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure><p>针对char类型</p><figure class="highlight plaintext"><figcaption><span>[读入2] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">略</span><br><span class="line">    char s[100];</span><br><span class="line">    fgets(s,100,stdin);//100表示最多读入字符</span><br><span class="line">    //stdin表示定义好的系统变量</span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure><p>字符串流（形式有点像py列表）<br>先把字符串初始化为字符串流 再从中读出 用法与cin相似</p><figure class="highlight plaintext"><figcaption><span>[字符串流] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">略</span><br><span class="line">string s;</span><br><span class="line">getline(cin,s);</span><br><span class="line">stringstream ssin(s);//ssin自定义 s被初始化</span><br><span class="line">string str;</span><br><span class="line">while(ssin&gt;&gt;str)//读出</span><br><span class="line">   pass</span><br><span class="line">int a,b；</span><br><span class="line">double c,d;</span><br><span class="line">string e;</span><br><span class="line">ssin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d&lt;&lt;endl;//可读出任何形式</span><br></pre></td></tr></table></figure><p>一些常用的</p><figure class="highlight plaintext"><figcaption><span>[常用函数] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">略</span><br><span class="line">string a,b,c</span><br><span class="line">strcmp(a,b) 比较两个字符串大小 a大返回1 相等返回0 否则-1</span><br><span class="line">a.size();//长度</span><br><span class="line">strcpy(a,b);将字符串b复制给从a开始的字符数组</span><br><span class="line">a.substr(m,n);</span><br><span class="line">str.back()//最后一个字符 其实等价于str[str.size()-1]</span><br><span class="line">str.pop_back//去除最后一个字符</span><br><span class="line">c=a.find(b,2);从下标为2开始（包含2）寻找b 输出b第一个字符的位置下标 如果没有 输出c.npos</span><br><span class="line">string str=&quot;abcd&quot;;</span><br><span class="line">reverse(str.begin(),str.end());</span><br><span class="line"></span><br><span class="line">string str2=&quot;abcd&quot;;</span><br><span class="line">reverse(str2.begin()+1,str2.end());翻转</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2022/11/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/11/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>二分的本质是边界 对于整数二分与浮点数二分有不同的模板<br>数组里的查找<br>整数二分（单个)</p><figure class="highlight plaintext"><figcaption><span>[整数二分] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int bsearch_one(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid=(l+r)/2;</span><br><span class="line">        if(q[mid]==goal) return mid;</span><br><span class="line">        else if(q[mid]&gt;goal) r=mid;</span><br><span class="line">        else l=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">寻找左分界点</span><br><span class="line">int bsearch_one(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid=(l+r)/2;</span><br><span class="line">        if(q[mid]&gt;=goal) r=mid; //右边端点不断靠左边移动</span><br><span class="line">        else l=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(q[l]!=goal) return -1;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line">寻找右分界点</span><br><span class="line">int bsearch_one(int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid=(l+r+1)/2;</span><br><span class="line">        if(q[mid]&lt;=goal) l=mid; //右边端点不断靠左边移动</span><br><span class="line">        else r=mid-1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(q[l]!=goal) return -1;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line">若不存在对应数 l是找的最近的满足check的索引</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>浮点数二分 因为没有整除 所以有严格边界</p><figure class="highlight plaintext"><figcaption><span>[浮点数二分(例题三次方根)] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double x；</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">double l=0,r=x;</span><br><span class="line">while(r-l&gt;1e-8)//精度尽量大</span><br><span class="line">&#123;</span><br><span class="line">    double mid=(l+r)/2;</span><br><span class="line">    if(mid*mid&gt;=x)&#123;</span><br><span class="line">        r=mid;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        l=mid;//不用考虑边界</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之浮点数二分简单多了~</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快排 归并</title>
      <link href="/2022/11/26/%E5%BF%AB%E6%8E%92%E5%B9%B6%E5%BD%92/"/>
      <url>/2022/11/26/%E5%BF%AB%E6%8E%92%E5%B9%B6%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><figcaption><span>[快排] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N =1e6+10;</span><br><span class="line">int n,q[N];</span><br><span class="line">void quick_sort(int q[],int l,int r) //l r指起点终点索引</span><br><span class="line">&#123;</span><br><span class="line">    if (l&gt;=r) return;</span><br><span class="line">    int x=q[l],//确定分界点</span><br><span class="line">    int i=l-1，j=r+1； //先移动指针 再进行比较判断 所以指针先放边界两侧外</span><br><span class="line">    while(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        do i++; while(q[i]&lt;x);</span><br><span class="line">        do j--; while(q[j]&gt;x);//通过分界点分到两侧</span><br><span class="line">        if(i&lt;j) swap(q[i],q[j]);  </span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q,l,j); //两侧分别递归</span><br><span class="line">    quick_sort(q,j+1,r);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;m;i++) cin&gt;&gt;q[i];</span><br><span class="line">    quick(q,0,m-1);</span><br><span class="line">    for(int j=0;j&lt;m;j++) cout&lt;&lt;q[j]&lt;&lt;&quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1.确定分界点（通常l） 2.调整区间 3.递归处理两侧</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>[归并] [c++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1000010;</span><br><span class="line">int n;</span><br><span class="line">int q[N],tmp[N];</span><br><span class="line">void merge_sort(int q[],int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    if(l&gt;=r) return;</span><br><span class="line">    int mid=1+r&gt;&gt;1;//确定中间值</span><br><span class="line">    merge_sort(q,l,mid),merge_sort(q,mid+1,r);//递归处理使用两侧有序</span><br><span class="line">    int k=0,i=l,j=mid+1;</span><br><span class="line">    while(i&lt;=mid&amp;&amp;j&lt;=r) </span><br><span class="line">        if(q[i]&lt;=q[j]) tmp[k++]=q[i++];//比较 插入</span><br><span class="line">        else tmp[k++]=q[j++];</span><br><span class="line">    while(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line">    while(j&lt;=r) tmp[k++]=j[i++];</span><br><span class="line">    for(i=l,j=0;i&lt;=r;i++,j++) q[i]=tmp[j];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;m;i++) cin&gt;&gt;q[i];</span><br><span class="line">    merge_sort(q,0,m-1);</span><br><span class="line">    for(int j=0;j&lt;m;j++) cout&lt;&lt;q[j]&lt;&lt;&quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1.确定分界点 2.递归排序 3.归并</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法之前的自白</title>
      <link href="/2022/11/25/second/"/>
      <url>/2022/11/25/second/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>九月疫情，没能返校，因为对c语言有着一种敬畏，就花了一个月先把python的语法基础过了一遍，又通过张绪某（hhhh算法课不上就刷题的nt，当然祝你成功进队）发的邀请码，混入某不知名大专（西柚）的新生选拔赛里初步做一做。<br><img src="/images/p1.png"><br>十月中旬到了学校才知道我的专业里c语言在大一下册才会开始教，大一上就学数分高代，我就咨询了一下竞赛部的大佬，他的原话：“py也就图一乐。”我便开始课下看mooc翁恺的课，狂补c语言的基础。然而这个学长话只说一半，到十一月初我肝完了语法基础，才告诉我整算法竞赛c++是必修项<br>好家伙，竞赛部的选拔这时候已经只有两周了，我有点完美主义，又不想用比较拿手的python去做，我便又在acwing上学c++ 因为c++跟c的语法很像，我就一边看课一边刷里面的习题。<br>机试的第一道题就一棒子把我打懵了，第一道就是动态规划，我丝毫没犹豫，就去找签到题先做，再看有没有能暴力整出来的题。最后出结果，虽然我总共提交次数最多，但是因为是ioi赛制没有罚时，运气好，最后一个名额擦着进了。<br>缓了几天 这就开始更新算法章节了</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浅浅聊一聊关于博客</title>
      <link href="/2022/11/24/first/"/>
      <url>/2022/11/24/first/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在某个百无聊赖的中国近代史课上，有了想自己搭建一个网站的想法，想把自己的所学所思记录在自己定制的一个网站上。<br>由于我目前没有任何css和html的基础，也没有购买服务器的想法，就采用了现在稍微流行一点且成本较低的方式-用hexo框架和githubpage搭建博客（以后应该会换成gitee，github确实太不稳定）<br>我是个比较能折腾的人，从23号晚上开始一步步下载nodejs，git，vscode，配置环境变量。在无数的error（强烈建议严格按照知乎大佬的步骤一步步下载和配置相关文件，因为我自己擅自改了路径又不想重来，基本经历了所能遇到的一半以上的问题）25号终于搭建好了，但是看着简陋的网站，折腾之心再起，又花了一天半的时间学了markdown语法，对网页进行魔改，大幅度地修改了主题配置文件，各种插件buff叠满（好在运气好没有出现多少bug）但是这个网站还是有一堆缺点:还没有绑定自己的域名，没有高速图床，github国内访问经常抽风慢，页面不够美观……<br>在自己的博客上写文章想一想还是挺有热情的，我不期望访问量有多少，因为主要是拿来做算法的笔记用的。<br>我想如果能坚持记下来也算是自己的一个闪光点吧。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/Gallery/index.html"/>
      <url>/Gallery/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/background.css"/>
      <url>/css/background.css</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>/* 页脚与头图透明 */#footer {  background: transparent !important;}#page-header {  background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}@font-face {  font-family: 'tzy';  /* 字体名自定义即可 */  /* src: url('https://cdn.jsdelivr.net/gh/tzy13755126023/BLOG_SOURCE/font/ZhuZiAWan.woff2'); */  src: url('https://npm.elemecdn.com/ethan4116-blog/lib/font/ZhuZiAWan.ttf');  /* 字体文件路径 */  font-display: swap;}body,.gitcalendar {  font-family: tzy !important;}/* 帧率检测 */#fps {  position: fixed;  /* 指定位置 */  left: 10px;  bottom: 10px;  z-index: 1919810;}[data-theme="light"] #fps {  background-color: rgba(255, 255, 255, 0.85);  backdrop-filter: var(--backdrop-filter);  padding: 4px;  border-radius: 4px;}[data-theme="dark"] #fps {  background-color: rgba(0, 0, 0, 0.72);  backdrop-filter: var(--backdrop-filter);  padding: 4px;  border-radius: 4px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='.5'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/fps.js"/>
      <url>/js/fps.js</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>if (window.localStorage.getItem("fpson") == undefined || window.localStorage.getItem("fpson") == "1") {    var rAF = function () {        return (            window.requestAnimationFrame ||            window.webkitRequestAnimationFrame ||            function (callback) {                window.setTimeout(callback, 1000 / 60);            }        );    }();    var frame = 0;    var allFrameCount = 0;    var lastTime = Date.now();    var lastFameTime = Date.now();    var loop = function () {        var now = Date.now();        var fs = (now - lastFameTime);        var fps = Math.round(1000 / fs);        lastFameTime = now;        // 不置 0，在动画的开头及结尾记录此值的差值算出 FPS        allFrameCount++;        frame++;        if (now > 1000 + lastTime) {            var fps = Math.round((frame * 1000) / (now - lastTime));            if (fps <= 5) {                var kd = `<span style="color:#bd0000">卡成ppt🤢</span>`            } else if (fps <= 15) {                var kd = `<span style="color:red">电竞级帧率😖</span>`            } else if (fps <= 25) {                var kd = `<span style="color:orange">有点难受😨</span>`            } else if (fps < 35) {                var kd = `<span style="color:#9338e6">不太流畅🙄</span>`            } else if (fps <= 45) {                var kd = `<span style="color:#08b7e4">还不错哦😁</span>`            } else {                var kd = `<span style="color:#39c5bb">十分流畅🤣</span>`            }            document.getElementById("fps").innerHTML = `FPS:${fps} ${kd}`;            frame = 0;            lastTime = now;        };        rAF(loop);    }    loop();} else {    document.getElementById("fps").style = "display:none!important"}]]></content>
      
    </entry>
    
    
  
</search>
